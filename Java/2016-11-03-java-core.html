<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-43567748-2', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    <title>Java Core | Balance | 大道至简</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="Java 核心技术命令行参数如在控制台输入java Message –h cruel world
args的参数包含如下：
args[0]=”-g”
args[1]=”cruel”
args[2]=”world”
面向对象一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。new操作符的返回值也是一个引用。相当于C++中的对象指针。Java中的null相当于C++中的NULL。
时钟类Greg">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Core">
<meta property="og:url" content="http://blog.inching.org/Java/2016-11-03-java-core.html">
<meta property="og:site_name" content="Balance">
<meta property="og:description" content="Java 核心技术命令行参数如在控制台输入java Message –h cruel world
args的参数包含如下：
args[0]=”-g”
args[1]=”cruel”
args[2]=”world”
面向对象一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。new操作符的返回值也是一个引用。相当于C++中的对象指针。Java中的null相当于C++中的NULL。
时钟类Greg">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/2fbbe88e331ee8e61461a131ac1fe66b.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/4e7328b9c368bf0b7508109a89be607e.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/643f32a02d5aa00e3271a27b143b93c0.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/a7bff8a7bc58feb718b70c81d3d78af9.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/6ae5dfeb0f49e4fa5955fddf3bed03d8.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/37627b1ba2e931dfce0ae79410a35cc3.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/1164484a19ea497641bbe58a54f9251d.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/8f41977078b31cc060d354741f58c3b4.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/9dbfd41a06bcf9eeb35ddeb180b637d4.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/549ab38fe46c6611499683640e6cb5d6.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/435491a9225880f55872460e27df6b7a.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/783aad0ee739ec515f95f120cc24966b.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/8b8f3a36b26e30ddb326d2a551cfcfb6.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/55b82a02cfe3d23ee43b56f0dc21f2d1.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/50d1ea556afc99b53c8027315937d7b8.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/ea7f9cd9d7d32cac4cedb43d15b5a9db.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/34ecf4c74895d93e6c0ee09ac44de10a.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/eed27ac85e00dc6ca7cd99a03bfde359.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/7bc03dc4e48ee05f1a4a121b9215c4b3.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/8e9958d1d98851653d35a75bec19bd4e.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/8ff9830c531950d06c5f0dccc52b9b98.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/aea88778acf72552d7cfc0a74b71b3a5.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/b3f74bd402af48403d26772143f7b292.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/6553837b1f08b65b5f39469a58cab4f7.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/b5bfe560a21110ea04cbc0b24f6d648f.png">
<meta property="og:image" content="http://blog.inching.org/../resources/images/java/f1eb7a781c3356763aaec44f672e955e.png">
<meta property="og:updated_time" content="2018-08-19T02:44:58.274Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Core">
<meta name="twitter:description" content="Java 核心技术命令行参数如在控制台输入java Message –h cruel world
args的参数包含如下：
args[0]=”-g”
args[1]=”cruel”
args[2]=”world”
面向对象一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。new操作符的返回值也是一个引用。相当于C++中的对象指针。Java中的null相当于C++中的NULL。
时钟类Greg">
<meta name="twitter:image" content="http://blog.inching.org/../resources/images/java/2fbbe88e331ee8e61461a131ac1fe66b.png">
    
        <link rel="alternate" type="application/atom+xml" title="Balance" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/style/style.css?v=1.6.17">

    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-2846834382442028",
        enable_page_level_ads: true
      });
    </script>

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Cody Fei</h5>
          <a href="mailto:inchingcode@gmail.com" title="inchingcode@gmail.com" class="mail">inchingcode@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/android"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Android/"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/inchingorg" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/CodyFee" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.inesoi.com" target="_blank" >
                <i class="icon icon-lg icon-shopping-bag"></i>
                Shopping Bag
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java Core</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Java Core</h1>
        <h5 class="subtitle">
            
                <time datetime="2016-11-02T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2016-11-03
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java-核心技术"><span class="post-toc-text">Java 核心技术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#命令行参数"><span class="post-toc-text">命令行参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面向对象"><span class="post-toc-text">面向对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#时钟类"><span class="post-toc-text">时钟类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#java的编译"><span class="post-toc-text">java的编译</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#java程序员应该注意的几个问题"><span class="post-toc-text">java程序员应该注意的几个问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承"><span class="post-toc-text">继承</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#枚举类"><span class="post-toc-text">枚举类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#接口"><span class="post-toc-text">接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异常"><span class="post-toc-text">异常</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#记录日志"><span class="post-toc-text">记录日志</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#流与文件"><span class="post-toc-text">流与文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据流-接口类"><span class="post-toc-text">数据流(接口类)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#随即存取文件流"><span class="post-toc-text">随即存取文件流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文本流"><span class="post-toc-text">文本流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符集"><span class="post-toc-text">字符集</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文本输出"><span class="post-toc-text">文本输出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文本输入"><span class="post-toc-text">文本输入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#流的使用"><span class="post-toc-text">流的使用</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-java-core"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Java Core</h1>
        <div class="post-meta">
            <time class="post-time" title="2016-11-03 00:00:00" datetime="2016-11-02T16:00:00.000Z"  itemprop="datePublished">2016-11-03</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="Java-核心技术"><a href="#Java-核心技术" class="headerlink" title="Java 核心技术"></a>Java 核心技术</h1><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>如在控制台输入java Message –h cruel world</p>
<p>args的参数包含如下：</p>
<pre><code>args[0]=”-g”
args[1]=”cruel”
args[2]=”world”
</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。new操作符的返回值也是一个引用。相当于C++中的对象指针。Java中的null相当于C++中的NULL。</p>
<h2 id="时钟类"><a href="#时钟类" class="headerlink" title="时钟类"></a>时钟类</h2><p>GregorianGalendar类扩展了Calendar类。</p>
<p>默认构造函数构造一个表示对象被创建时的日历对象。可以创建特定年月日的对象，如</p>
<pre><code>new GregorianCalendar(1999,Calendar.December,32)或者
new GregorianCalendar(1999,11,32)
</code></pre><p>月份从0开始计数。也可以构造具有年月日时分秒的日历对象。</p>
<p>访问日历中的年月日等，如</p>
<pre><code>int month=now.get(Calendar.MONTH);
int weekday=now.get(Calendar.DAY_OF_WEEK);
</code></pre><p>设置对象的状态，如：</p>
<pre><code>deadline.set(Calendar.YEAR,2001);
deadline.set(Calendar.MONTH,Calendar.APRIL);
deadline.set(Calendar.DAY_OF_MONTH,15);
</code></pre><p>为给定的日历对象添加天数、星期数、月数等</p>
<pre><code>deadline.add(Calendar.MONTH,3);
</code></pre><p>Data与GregorianCalendar的变换(Date类无法操纵日历)</p>
<pre><code>Data time=calendar.getTime();
calendar.setTime(time);
</code></pre><p>可以通过DateFormatSymbols类来获取别国语言的星期几的名称。</p>
<h2 id="java的编译"><a href="#java的编译" class="headerlink" title="java的编译"></a>java的编译</h2><p>文件名必须和ppublic类的名字相匹配，在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。</p>
<p>编译方法：</p>
<ol>
<li>通配符调用java编译器，如java Employee.java,将编译所有以Employee开头的源文件。</li>
<li>javac EmployeeTest.java 由于EmployeeTest中使用了Employee，所以编译器将自动编译Employee类。</li>
<li>Employee number(“James Bond”,100,1950,1,1);<br>这条语句在C++中能够正常运行，但在java中不能运行。</li>
</ol>
<h2 id="java程序员应该注意的几个问题"><a href="#java程序员应该注意的几个问题" class="headerlink" title="java程序员应该注意的几个问题"></a>java程序员应该注意的几个问题</h2><ul>
<li><p>不要编写返回引用可变对象的访问器的方法，因为在类外可以改变这个引用的状态，起不到访问器的作用。</p>
<p>  一个方法可以访问所属类的所有对象的私有数据。例如：</p>
<p>  Class Employee{</p>
<pre><code>boolean equals(Employee other){
    return name.equals(**other.name**);
}
</code></pre><p>  }</p>
</li>
<li><p>final：在创建变量之后，指能够为之赋值一次，此后再也不能改变它的值了。final可以应用于局部变量两、实例变量和静态变量。不过，在定义final变量时，可以不必初始化。</p>
<p>  对于可变的类，使用final修饰符可能会对读者造成混乱，如  </p>
<pre><code>private final Date hiredate;
</code></pre><p>  仅仅意味着存储在hiredate变量中的对象引用在对象构造之后不能被改变，而并不意味着hiredate对象是一个常量，任何方法都可以对hiredate引用的对象调用setTime更改器。</p>
<p>  而对于不可变的类，用final修饰符修饰则以为着它作为一个常量，如</p>
<pre><code>private final String name;
</code></pre><p>  static(用法如：private static int nextId=1)</p>
<p>  类的所有实例共享同一个静态域，静态域属于类，而不属于任何对象。</p>
<p>  类常量，如 public static final double PI=2.1415926;</p>
</li>
<li><p>静态方法</p>
<p>  因为静态方法不能操作对象，所以不能在静态方法中访问实例域，但是，静态方法可以访问自身类中的静态域。如：</p>
<pre><code>public static int getNextID(){return nextID;}
</code></pre><p>  可以使用对象调用静态方法，但不建议这么用。</p>
<p>  每一个类(不管类的权限如何)都可以有一个main方法，用来对类进行测试。</p>
</li>
<li><p>Java中方法参数的使用情况</p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ol>
</li>
<li><p>方法重载：</p>
<p>  返回类型不是方法签名的一部分，也就是说，不能有两个名字相同，参数类型也相同却返回不同类型值的方法。</p>
</li>
<li><p>构造函数</p>
<p>  如果类中提供了至少一个构造器，但是没有提供默认的构造器，那么在构造对象时若不提供构造参数就被视为不合法。默认构造函数中，数值型数据设置为0，布尔型数据设置为false，所有对象变量将设置为null。如果希望所有域拥有默认值，则可以提供下列格式的构造器：</p>
<pre><code>public ClassName(){}
</code></pre><p>  显示域初始化，如：</p>
<pre><code>class Employee{
    private String name=“”;
}
</code></pre><p>  域也可以通过调用方法来进行初始化：</p>
<pre><code>class Employee{
    static int assignId(){
        int r=nextId;
        nextId++;
        return r;
    }
    private int id=assignId();
}
</code></pre><p>  在C++中，不能直接初始化实例域，所有的域必须在构造器中设置。但是，有一种特殊的初始化器列表语法，如：</p>
<pre><code>Employee::Employee(String n, double s):name(n),salary(s){

}
</code></pre><p>  一个构造器调用同一个类的另一个构造器，如：</p>
<p>  public Employee(double s){</p>
<pre><code>this(“Emploee \#”+nextId,s);
</code></pre><p>  }</p>
<p>  this构造函数只能写在第一行。</p>
<p>  Java中的this等价于C++的this指针，但是C++中，一个构造器不能调用另一个构造器。</p>
<p>  初始化块，如：</p>
<pre><code>{
id=nextId;
nextId++;
}
</code></pre><p>  调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值</li>
<li>按照在类声明中出现的次序依次执行所有域初始化语句和初始化块</li>
<li>如果一个构造器调用了另外一个构造器，则执行第二个构造器的主体。</li>
<li>继续执行这个构造器的主体。</li>
<li><p>静态域初始化：</p>
<p>static int nextId=1；</p>
<p>使用静态的初始化块：</p>
<p> static{</p>
<pre><code>Rondom generator=new Random();
nextId=generator.nextInt(1000);
</code></pre><p> }</p>
</li>
<li><p>当参数名与实例域名相同时，实例域被屏蔽，此时可以通过隐式参数来初始化实例域，如：</p>
<p> public Employee(String name,double salary){</p>
<pre><code>this.name=name;
this.salary=salary;
</code></pre><p> }</p>
</li>
</ol>
</li>
<li><p>使用Java编写一个没有main方法的“Hello, World”程序：</p>
<p>  public class Hello{</p>
<pre><code>static{
   System.out.println(“Hello, World”);
}
</code></pre><p>  }</p>
<p>  在静态初始化块的尾部调用System.exit(0)来避免main is not defined的错误。</p>
</li>
<li><p>类的导入(import)</p>
<p>  在所有的源代码的顶部，在package语句的后面。</p>
<p>  采用两种方式访问另一个包中的公有类</p>
<ol>
<li>添加完整的包名，如 java.util.Date today=new java.util.Date();</li>
<li><p>import语句导入一个特定的类或者整个包，如：import java.util.*;</p>
<p> 或import java.util.Date</p>
<p>当导入的包中包含相同名称的类名时，使用这个类将出现编译错误，如：</p>
<p>import java.util.*;<br>import java.sql.*;</p>
<p>使用Date today=new Date()时出错。</p>
<p>此时，可以增加一个特定的import语句来解决这个问题，如</p>
<p> import java.util.*;<br> import java.sql.*;<br> import java.util.Date;</p>
<p>当需要同时使用两个包中的类时，则在每个类名前面加上完整的包名。</p>
<p>Java中的import和package相当于C++中的using和namespace指令。</p>
</li>
</ol>
</li>
<li><p>静态导入</p>
<p>  添加一条指令，import static java.lang.System.*;</p>
<p>  则可以可用System类的静态方法和静态域，而不必加类名前缀。</p>
<p>  还可以导入特定的方法或域，如：</p>
<pre><code>import static java.lang.System.out;
</code></pre><p>  导入静态方法和静态域有两个实际的应用：</p>
<p>  算数运算，如import java.Math</p>
<pre><code>sqrt(x,2)+pow(y,2);
</code></pre><p>  笨重的常量，如</p>
<p>  if(d.get(DAY_OF_WEEK)==MONDAY)…</p>
</li>
<li><p>将类放入包中(package)</p>
<p>  如果没有在源文件中放置package语句，那么源文件中的类奖被放置在一个默认包中。</p>
<p>  编译器对带有文件分隔符和扩展名.java的文件进行操作，而java解析器对带.分隔符的包进行操作。</p>
<p>  jre/lib目录下的rt.jar包含数千个运行时的类。</p>
<p>  在UNIX下，类路径的不同项目之间是采用：分割的，Windows下采用；分隔，“.”表示当前目录。</p>
</li>
<li><p>类路径包括：</p>
<ul>
<li>基目录，如/home/user/classdir或c:\classes</li>
<li>当前目录</li>
<li><p>jar文件，如/home/user/archives/archive.jar或c:\archives\archive.jar</p>
<p>  运行时库(在jre/lib和jre/lib/ext目录下的rt.jar和一些其它的jar文件)会被自动搜索，所以不必将它们显示地列在类路径中。</p>
<p>  类路径所列出的目录和归类文件是搜索类的起始点。</p>
<p>设置类路径，两种方法：</p>
</li>
<li><p>为编译器和字节码制定-classpath选项，如：</p>
<p>  javac –classpath /home/user/classdir:./:/home/user/archives.jar MyProg.java</p>
<p>  也可以用-cp代替-classpath。</p>
</li>
<li><p>设置CLASSPAT环境变量。</p>
<p>java5.0以后不必设置类路径就可以编译当前目录的类。</p>
<p>编译技巧：javac –d . Hello.java 将编译后的字节码文件直接加到package目录下。</p>
</li>
</ul>
</li>
</ul>
<pre><code>javac编译器总是在当前目录中查找文件，而java解释器仅在类路径中有“.”目录的时候，才查看当前目录。如果没有设置类路径，并不会产生什么问题，默认的类路径包含“.”目录。然而如果设置了类路径但忘记了包含“.”目录，程序仍然可以通过编译，但不能运行。
</code></pre><ul>
<li><p>包作用域</p>
<p>  对于方法和域，标记为public的部分可以被任意的类实用，标记为private的部分只能被定义在它们的类实用。如果没有指定public和private，那么这部分可以被同一个包中的所有类实用。</p>
</li>
<li><p>文档注释</p>
<p>  javadoc 应用程序(utility)从下面的一个特性抽取信息：</p>
<p>  包、公有类和接口、公有的和受保护的方法、公有的和受保护的域</p>
<p>  每个/**…*/文档注释在标记之后紧跟着自由格式文本，标记以\@开始，如\@author等。自由格式文本中，可以使用HTML修饰符，如用于强调的\<em\>…\</em\>,用于设置等宽打字机的\<code\>…\</code\>,用于着重强调的\<strong\>…\</strong\>以及包含图像的\<img …\="">等。但是，不要用\<h1\>或\<hr\>，因为他们与文档的格式产生冲突。</hr\></h1\></p>
</li>
</ul>
<pre><code>如果文档中有到其它文件的链接，如图像文件，则应该把这些文件放到子目录doc-files中，javadoc将从源目录拷贝这些目录及其中的文件到文档目录中。

- 类注释：必须放在import语句之后，类定义之前。
- 方法注释：必须放在所描述的方法之前
- 域注释：只需要对公有域建立文档(通常指静态常量)
- 通用注释

    下列标记用在类文档的注释中

    - \@author name:产生一个“author”条目
    - \@version text 产生一个“version”条目

    下列标记用于所有的文档注释

    - \@since text:text可以使引入特性的版本描述，如\@since version
    - \@deprecated text 对类、方法或变量增加一个不再使用的注释，text给出了取代的建议，如: \@deprecated Use \&lt;code\&gt;setVisible(true)\&lt;/code\&gt; instead 通过使用\@see和\@link标记，可以使用超级链接，链接到javadoc文档的相关部分或外部文档。

    - see reference:将在see also部分添加一个超级链接，可以用于类、方法中。

    - 包与概述注释

        要想产生包注释，就需要在每一个包目录中添加一个package.html的文件。在标记\&lt;BODY\&gt;…\&lt;/BODY\&gt;之间的所有文本都会被抽取出来。还可以为所有的源文件提供一个概述性的注释，这个注释被放置在一个名为overview.html的文件中，该文件为于所有包含源文件的父目录中。

    - 注释的抽取

        在源文件目录，执行下列命令：

        javadoc –d docDirectory nameOfPackage,nameOfPackage,…

        如果在默认包中，就应该执行：

        javadoc –d docDirectory \*.java

        如果省略-d docDirecotry，则html文件提取到当前目录。
</code></pre><ul>
<li><p>类的设计技巧</p>
<ul>
<li>将数据设计为私有</li>
<li>一定要对数据初始化。Java不对局部变量进行初始化，但是会对对象的实例域进行初始化。</li>
<li>不要在类中使用过多的基本数据类型，可以用其他的类代替多个相关的基本数据类型的使用。</li>
<li>将职责过多的类进行分解。</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>继承格式</strong></p>
<pre><code>class Manager extends Employee{
}
</code></pre><p>Java用关键字代替C++中的：，在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。</p>
<p>子类不能直接访问超类的私有成员，调用超类的方法时，可以使用关键字super，如super.getSalary()。this和super不是类似的概念，因为super不是对象的引用，不能将super赋值给一个对象变量，它只是一个指示编译器调用超类方法的特有关键字。</p>
<p>C++中调用超类的方法为超类名加上：：操作符，如Employee::getSalary。</p>
<p>super可以用来调用超类的构造器，如super(n, s, month, day); 使用super调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显示地挑用超类的构造器，则将自动地调用超类默认(没有参数)的构造器。如果此时超类没有默认的构造器，则Java编译器将报告错误。</p>
<p>在C++中，使用初始化列表语法调用超类的构造函数，而不调用super，如：</p>
<pre><code>Manager::Manager(String n, double s):Employ(n, s){
    bonus=0;
}
</code></pre><p>一个对象变量可以引用多种实际类型(如Employee对象引用Employee和Manager对象)，在运行时它能够自动地选择调用的是适当的方法。Java不支持多继承。可以将一个子类对象的引用赋值给一个超类变量，但是不能用这个引用调用子类的方法，不能将一个超类的引用赋给子类变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Manager[] managers=new Manager[10];</div><div class="line">staff[0]=new</div><div class="line">Employee(…);</div></pre></td></tr></table></figure>
<p>编译器能够接纳这个赋值操作，此时，staff[0]和managers[0]引用的是用一个对象，当调用managers[0].setBonus(1000)的时候，将会导致访问一个不W在的实例域，进而搅乱邻近存储空间的内容。W</p>
<p>过程在重载解析时，由于存在类型转化(如int可以转化为double型，Manager可以转化成Employee等)，所以，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转化后又多个方法与之匹配，就会报告错误。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类的这个同签名的方法，但是子类方法的返回类型必须是原返回类型的子类型。如：</p>
<p>父类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Employee getBuddy()&#123;</div><div class="line">    …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Manager getBuddy()&#123;</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>动态绑定</strong></p>
<p>如果是private、static、final或者构造器，编译器可以准确地知道应该调用哪个方法即静态绑定。采用动态绑定时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类方法。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</p>
<p>Employee e;</p>
<p>当e引用的是它的子类的一个实例时，如果子类覆盖了父类的方法，则用e调用这个方法时，调用的将是相应子类的方法。</p>
<p><strong>阻止继承</strong>：final类和final方法</p>
<p>声明格式如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final class Executive extends Manager&#123;</div><div class="line">    …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>final类不允许扩展，其中的方法自动成为final方法，不包括域。对于final域，创建对象后酒不孕需改变它们的值。类中的方法可以被声明为final，子类就不能覆盖这个方法。</p>
<p>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理及内联，如e.getName()被替换为e.name。</p>
<p>将一个子类的引用赋值给一个超类变量编译器是允许的，但是将一个超类的引用赋值给一个子类变量，必须进行强制转换。在进行类型转换之前，先察看以下是否能够成功地转化，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(staff[1] instanceof Manager)&#123;</div><div class="line">    boss=(Manager) staff[1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果x为null，那么 x instanceof C不会产生异常，而是返回false。</p>
<p>其处理过程类似于C++中的dynamic_cast操作，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Manager boss=(Manager) staff[1];</div></pre></td></tr></table></figure>
<p>=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Manager \* boss=(dynamic_cast)\&lt;Manager \*\&gt;(staff[1]);</div></pre></td></tr></table></figure>
<p>当类型转化失败时，Java不会生成一个null对象，而是抛出一个异常。</p>
<p><strong>抽象类</strong></p>
<p>格式如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abstract class Person&#123;</div><div class="line">    public abstract String getDescription();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象类除了抽象方法之外，还可以包含具体数据和具体方法。在抽象类的子类中，仍然可以不定义抽象方法，而仍保持抽象性。即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化，但可以定义一个抽象类的对象变量，但是它只能饮用非抽象子类的对象，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p=new Student(“Vince Vu”);</div></pre></td></tr></table></figure>
<p>在C++中，只要有一个纯虚函数，这个类就是抽象类，没有提供用于表示抽象类的特殊关键字。纯虚函数的表示方法如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    public:</div><div class="line">    public string getDescription()=0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于不能构造抽象类Person的对象，所有变量p永远不会指向Person对象，而是引用诸如Employ这样的具体子类对象。如果Person超类中不定义抽象函数getDescription，则p就不能调用该方法了。</p>
<p>Java用于控制可见性的4个访问修饰符</p>
<ol>
<li>仅对本类可见：private</li>
<li>对所有类都可见：public</li>
<li>对本包和所有子类都可见：protected</li>
<li>对本报可见：默认。</li>
</ol>
<p>Object类型的变量只能用于作为各种值得通用持有者，要想对他们进行特定操作，需要清楚对象的原始类型，并进行相应得类型转换：</p>
<pre><code>Employee e=(Employee) obj.
</code></pre><p>Java中，只有基本类型不是对象，而所有的数组类型都扩展于Object类的类型，如：</p>
<pre><code>Employee[] staff=new Employee[10];
obj=staff;
obj=new int[10];
</code></pre><p>在C++中，没有根类，但是每个指针都可以转化为void。</p>
<p><strong>Object</strong></p>
<p>equals：在Object类中，这个方法将判断两个对象是否具有相同的引用。</p>
<p><img src="../resources/images/java/2fbbe88e331ee8e61461a131ac1fe66b.png" alt=""></p>
<p>getClass方法返回一个对象所属的类。比较子类是否相等的方法：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/4e7328b9c368bf0b7508109a89be607e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>一个完美的equals方法的建议</strong></p>
<p>检测this和otherObject是否引用同一个对象</p>
<pre><code>if(this==otherObject) return true;
</code></pre><p>检测otherObject是否为null</p>
<pre><code>if(otherObject==null) return false;
</code></pre><p>比较this与otherObject是否属于同一个类,如果equals的语义在每个类种有所改变，则使用getClass检测，如:</p>
<pre><code>if(getClass()!=otherObject.getClass()) return false;
</code></pre><p>如果所有的子类都拥有同一的语义，就是用instanceof检测，如:</p>
<pre><code>if(!(otherObject instanceof ClassName)) return false;
</code></pre><p>此时，可以将这个equals方法设置为final，因为它有超类确定相等概念，子类不拥有自己的相等概念。</p>
<p>将otherObject转换位相应得类型变量，对所需要比较的域进行比较，如：</p>
<pre><code>ClassName other=(ClassName) otherObject;
return filed=other.fild&amp;&amp;field.equals(other.field)…)
</code></pre><p>如果子类重新定义equals,就要在其中包含调用super.equals(other)。</p>
<p>使用\@Override对覆盖超类的方法进行标记，如：</p>
<pre><code>@Override public Boolean equals(Object other)
</code></pre><p>如果子类定义了一个新的方法，编译器就会给出错误报告。</p>
<p><strong>hashCode方法：</strong></p>
<p>散列码：由对象导出的一个整形数。</p>
<p>String类的散列码计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int hash=0;</div><div class="line">for(int i=0;i\&lt;length();i++)&#123;</div><div class="line">    hash=31\*hash+charAt(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/643f32a02d5aa00e3271a27b143b93c0.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>s和t拥有相同的散列码，缓冲sb和tb却有着不同的散列码，因为StringBuffer类中没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址。</p>
<p>equals与hashCode的定义必须一致，如果x.equals(y)返回true，那么x.hashCode就必须与y.hashCode具有相同的值。</p>
<p><strong>toString()</strong></p>
<p>绝大多数(但不是全部)的toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值，如Employee的toString的实现：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/a7bff8a7bc58feb718b70c81d3d78af9.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>其中，getClass().getName()得到类名的字符串。</p>
<p>子类可以通过调用super.toString()来写自己的toString方法。随处可见toString方法的原因是：只要对象与一个字符串通过“+”链接起来，Java编译就会自动调用toString方法，以便获得这个对象的字符串描述。在调用x.toString()的地方可以用“”+x替代。System.out.println(x);println方法将直接调用x.toString()方法。</p>
<p>Object类定义的toString方法，用来打印数出对象所属的类名和散列码，如System.out.println(System.out);输出内容为：java.io.PrintStream\@6684</p>
<p><strong>Class getClass()</strong></p>
<p>返回包含对象信息的类对象，Java提供了类运行时的描述，它的内容被封装在Class类中。</p>
<p>Class类的两个方法为：getName()返回该类的名字，getSupperclass()返回该类的超类信息。</p>
<p>Object clone() 创建一个对象的副本。</p>
<p><strong>泛型数组列表：</strong></p>
<p>在Java中，允许在运行时确定数组的大小，如：</p>
<pre><code>int actualSize= …;
Employee[] staff=new Employee[actualSize];
</code></pre><p>构造一个保存Employee对象的数组类表：ArrayList\<employee\> staff=new<br>ArrayList\<employee\>();</employee\></employee\></p>
<p>在5.0后，没有后缀\&lt;…>仍然可以使用，它将被认为是一个删去了类型参数的“原始”类型。</p>
<p>ArrayList比Vector更加有效。</p>
<p>数组列表的容量与数组的大小有一个非常重要的区别，数组具有实际的空间，而数组列表只是由相应空间的潜力，完成初始化构造之后，数组列表可能不含有任何元素。</p>
<p>C++中的赋值操作是值拷贝，而Java是引用拷贝。</p>
<p>常用方法：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/6ae5dfeb0f49e4fa5955fddf3bed03d8.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/37627b1ba2e931dfce0ae79410a35cc3.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>访问数组类表的元素</strong></p>
<pre><code>Employee e=staff.get(i);
staff.set(i,harry)
</code></pre><p>将ArrayList转换成数组，如:</p>
<pre><code>X[]a =new X[list.size()];
list.toArray(a);
</code></pre><p>类型化参数与原始列表的兼容性</p>
<p>如下类：</p>
<pre><code>public class EmployeeDB{
    public void update(ArrayList list){…}
    pubic ArrayList find(String query){…}
}
</code></pre><p>可以将一个类型化的数组列表传递给update方法，而不需要任何类型转换，如：</p>
<pre><code>ArrayList\&lt;Employee\&gt; staff=…;
employeeDB.update(staff); 此时编译器不会给出任何错误信息或警告。
</code></pre><p>将一个原始ArrayList赋值个一个类型化ArrayList会得到一个警告，如：</p>
<pre><code>ArrayList\&lt;Empployee\&gt; result=(ArrayList\&lt;Employee\&gt;)
employeeDb.find(query);此时会得到一个警告。
</code></pre><p>编译器在对类型进行检查后，如果没有发现违反规则的现象，就将所有的类型化数组类编转换成原始ArrayList对象，在程序运行时，所有的数组列表都是一样的。</p>
<p><strong>对象包装器</strong></p>
<p>泛型变量要求传入的是对象类型，因此需要将基本类型转换成相应的对象类型，如：</p>
<pre><code>ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();
</code></pre><p>list.add的参数可以传入基本类型int，编译器将自动打包成Integer对象。</p>
<p>将一个Integer对象赋给一个int值时，将会自动地拆包，如：</p>
<p>int n=list.get(i);将自动翻译成int n=list.get(i).intValue();</p>
<p>如果将经常出现的值包装到同一个对象中，那么这种比较就有可能相等。但是这种比较应该用equesl函数。Integer对象是不可变的，包含在包装器中的内容不会改变。</p>
<p><strong>基本方法：</strong></p>
<ol>
<li>以int的形式返回Interger对象的值，如int intValue();</li>
<li><p>将int类型转化为String类型，如：</p>
<pre><code>static String toString(int i)；
static String toString(int i, int radix);其中radix为进制数
</code></pre></li>
<li><p>将String类型转化为int型，如：</p>
<pre><code>static int parseInt(String s);
static int parseInt(String s);
</code></pre></li>
<li><p>将String类型转化为Integer类型</p>
<pre><code>static Integer valueOf(String s);
static Integer valueOf(String s, int radix);
</code></pre></li>
<li><p>参数数量可变的方法，如：</p>
<pre><code>public class PrintStream{
    public PrintStream printf(String fmt, Object… args){
    return format(fmt, args);
    }
}
</code></pre><p>允许将一个数组传递给可变参数方法的最后一个参数，如：</p>
<pre><code>System.out.println(“%d%s”, new Object[]{new Integer(1),“widgets”});
public static double max(double… values){

}
</code></pre><p>调用方法为：double m=max(3.1,6.2);</p>
</li>
</ol>
<p>反射：能够分析类能力的程序</p>
<p>Class类：为对象维护一个被称为运行时的类型标识，保存着每个对象所属的类足迹。</p>
<p>获得Class实例的方法：</p>
<p>getClass()方法，如：</p>
<pre><code>Employee e;
Class cl=e.getClass();
</code></pre><p>最常用Class方法是getName,它返回类的名字，如：</p>
<pre><code>System.out.println(e.getClass().getName()+“”+e.getName())，则会打印出：
Employee Harray Hacker
</code></pre><p>用静态方法获得字符串对应得Class对象，如：</p>
<pre><code>String className=“java.util.Date”;
Class cl=Class.forName(classname);//此方法抛出异常
</code></pre><p>只有在classname是类名或接口时才能够执行，否则将抛出异常处理器。</p>
<p>T.class将代表匹配的类对象，其中T为任意的类型，包括基本类型，如：</p>
<pre><code>Class cl3=Double[].class;
Class cl2=int.class;
</code></pre><p>getName方法在应用于数组类型的时候会返回一个很奇怪的名字，如:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/1164484a19ea497641bbe58a54f9251d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以用==实现两个类对象比较的操作，如：if(e.getClass()==Employee.class)…</p>
<p>快速创建一个类的无参数实例，如：</p>
<p>e.getClass().newInstance();</p>
<p>如果没有默认的构造器，就会抛出一个异常，返回Object类型。如果需要构造含含有参数的实例，则需要使用Constructor类中的newInstance方法。</p>
<p>newInstance方法对应C++中虚拟构造器的习惯用法，Class类与C++中的type_info类相似，getClass方法与C++中的typeid运算符等价。</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>定义格式如： public enum Size{SMALL, MEDIUM,LARGE };</p>
<p>在比较两个枚举的值时，不需要调用equals，直接使用==。</p>
<p>可以在枚举类型中添加一些构造器、方法和域，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/8f41977078b31cc060d354741f58c3b4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>枚举类型是Enum类的子类，继承的常用方法如：</p>
<ol>
<li>toString() Size.SMALL.toString()返回字符串SMALL</li>
<li>value() 如：Size[] values=Size.values(); 包含一个全部枚举值得数组。</li>
<li>static Enum valueOf(Class enumClass, String name) 如：Static<br>size=Enum.valueOf(Size.class, input);</li>
</ol>
<p>继承设计技巧</p>
<ol>
<li>将共有操作和域放置在超类中</li>
<li>不要使用受保护的域，因为：子类关系是无穷的，保护域对同一包中的其他类是可见的。</li>
<li>使用继承实现“is-a”关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法的石虎，不要改变预期的行为</li>
<li>使用多态，而非类型信息</li>
<li>不要过多地使用反射</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口的定义，如：</p>
<pre><code>public interface Comparable{
    int compareTo(Object other);
}
</code></pre><p>在Java5.0后，Comparable接口已经改进为泛型类型，如</p>
<pre><code>public interface Comparable\&lt;T\&gt;{
    int compareTo(T other);
}//小于返回负数，大于正数，=为0。
</code></pre><p>在实现Comparable\<employee\>接口时，必须提供下列方法int compareTo(Employee<br>other);<br>也可以使用没有类型参数的Comparable类型，但必须手工地将compareTo方法的参数转换成所希望的类型。</employee\></p>
<p>接口中的所有方法自动地属于public，因此，在接口中声明方法时，不必提供关键字public。(<strong>能否声明包可见接口，对于这种情况是否也是如此</strong>)</p>
<p>在接口中可以定义常量，接口中不能提供方法，不能含有实例域，也不能在接口中实现方法。在实现接口时，必须把方法声明为public，否则编译器将认为是访问属性为包可见，将给出试图提供更弱的访问权限的警告信息。如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/9dbfd41a06bcf9eeb35ddeb180b637d4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>在用sort方法实现Array的排序算法时，不能直接在排序对象中直接提供compareTo方法，而应该实现Comparable接口的<strong>原因</strong>是：Java是一种强类型语言，在调用方法是，编译器会检查这个方法是否存在。</p>
<p>如果在Array类的sort方法定义为接收一个Comparable[]数组，那么在使用元素类型没有实现Comparable接口的数组作为参数调用sort方法时，编译器也不会给出错误报告，此时，sort方法可以接受一个Object[]数组，并对其进行笨拙的类型转换，如:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/549ab38fe46c6611499683640e6cb5d6.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果a[i]不属于实现了Comparable接口的类，虚拟机就会跑出一个异常。</p>
<p>在实现compareTo方法时，与equsal方法一样，如果子类直接的比较含义不相同，每个compareTo方法就应该在开始时进行下列检测:</p>
<p>if(getClass()!=other.getClass()) throw new ClassCastException();</p>
<p><strong>接口的特性：</strong></p>
<p>不能使用new实例化一个接口，但可以构造接口对象，可以使用instanceof检查一个对象是否属于某个特定的接口。接口中的域被自动地设为public<br>static final。</p>
<p>类只能拥有一个超类，但却不能实现多个接口，如：</p>
<pre><code>class Employee implements Cloneable, Comparable{
}
</code></pre><p>接口为对象的多继承提供了解决办法，而如果仅用abstract实现不了多继承。</p>
<p><strong>对象克隆</strong></p>
<p>在Object中，clone方法被申明为protected，因此无法直接调用anObject.clone()。Clonable接口并没有指定clone方法，这个方式是从Object类继承而来的，接口在这里只是作为一个标记，表明类设计者知道要进行克隆处理。如果一个对象需要克隆，而没有实现Cloneable接口，就会产生一个以检查异常。</p>
<p>即使使用clone的默认实现(浅拷贝)能够满足需求，也需要实现Cloneable接口，将clone重定义为public，并调用super.clone(),这种接口称为标记接口，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/435491a9225880f55872460e27df6b7a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>JDK5.0之前，clone方法总是返回Object类型，而JDK5.0中，允许克隆方法制定返回类型。</p>
<p>只要Object类的clone中含有没有实现Cloneable接口的对象，Object类的clone方法就会抛出一个CloneNotSupportException异常，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/783aad0ee739ec515f95f120cc24966b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>接口与回调</strong></p>
<p>Timer类(java.swing.Timer)</p>
<p>定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了java.awt.event包的ActionListener接口，如：</p>
<pre><code>public interface ActionListener(){
    void actionPerformed(ActionEvent event);
}
</code></pre><p>当到达指定的时间间隔时，定时器就调用actionPerformed方法。</p>
<p>如下，实现10s打印一条信息，然后响一声的代码。其中，Timer第一个参数使发出通告的时间间隔，它的单位使毫秒，第二个参数是监听器对象，如Timer(int<br>interval, ActioinListner listener)。定时器启动代码，如void<br>start()，定时器中止void stop()。</p>
<p>其中，类javax.awt.Toolkit中的方法static Toolkit<br>getDefaultToolkit()获得默认的工具箱，工具箱包含有关GUI环境的信息。void<br>beep()发出一声响铃。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/8b8f3a36b26e30ddb326d2a551cfcfb6.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>内部类</strong></p>
<p>内部类的特点：</p>
<p>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据，可以对同一包中的其他类隐藏起来。</p>
<p>C++中的内部类的书写格式，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/55b82a02cfe3d23ee43b56f0dc21f2d1.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>只有内部类可以是私有类，而常规类只能具有包的可见性、或公有的可见性。</p>
<p>如果内部类没有构造器，则编译器为这个类生成一个构造器，代码如：</p>
<pre><code>public TimerPrinter(TalkingClock clock){
    outer=clock;
}
</code></pre><p>如果内部类有构造器，编译器将会对它进行修改，并添加一个外围类引用的参数。</p>
<p>在外部类的方法中创建内部类的对象时，编译器将会将this引用传递给这个构造器。</p>
<p>OutClass.this表示外围类，如：</p>
<pre><code>if(TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
</code></pre><p>可以采用下列语法格式更加明确地编写内部对象的构造器，如：</p>
<pre><code>OutObject.new InnerClass(…)，如ActionListener listener=this.new
TimePrinter();
</code></pre><p>对于公有内部类，可以这么构造内部类对象，如：</p>
<pre><code>TalkingClock jabberer=new TalkingClock(1000, true);
TalkingClock.TimePrinter listener=jabberer.new TimePrinter();
</code></pre><p>外部对象的this指针必须将外部类名作为其前缀，如:</p>
<pre><code>SwingUtilities.updateComponentTreeUI(PlafPanel.this);
</code></pre><p>内部类是一种编译器现象，与虚拟机无关，编译器会把内部类翻译成\$分隔外部类名与内部类名的常规类文件，虚拟机对此一无所知。如Talking类内部的TimePrinter类将被翻译成</p>
<pre><code>TalkingClock\$TimePrinter.class
</code></pre><p><strong>局部内部类</strong></p>
<p>可以在一个方法中定义局部类，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/50d1ea556afc99b53c8027315937d7b8.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>局部类不能用public或private访问说明符修饰，局部类不仅可以访问他们外围类的域，而且还可以访问局部变量，但是这些局部变量必须被声明为final，这样是为使得局部变量与局部类建立的拷贝保持一致。局部类能够能够访问局部变量的原因是，在创建对象时，[final局部变量]传给内部类的构造器，构造器将final局部变量以val&amp;beep的形式存储在域中。</p>
<p><strong>匿名内部类</strong>：只需要创建一个对象，而不需要为它命名的内部类，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/ea7f9cd9d7d32cac4cedb43d15b5a9db.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>对匿名内部类的理解是：创建一个实现ActioinLisntener接口类的对象，需要实现方法的actionPerformed定义在{}内。用于构造对象的任何参数都要被放在超类名后面的()内，如：</p>
<pre><code>new SuperType(construction parameters){
</code></pre><p>}其中，SuperType可以是ActionListener这样的接口，于是内部类就要实现这个接口；也可以是一个类，于是内部类就要扩展它。</p>
<p>因为构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能构造器。取而代之的是，将构造器参数传递给超类构造器。内部类机制将自动生成一个构造器，其中存储着所有永在内部类方法中的final局部变量。在实现内部类接口的时候，不能有任何构造参数，如：</p>
<pre><code>new InterfaceType(){methods and data};
</code></pre><p>如果构造器的()后跟一个{}，那么正在定义的就是匿名内部类，如：</p>
<pre><code>Person queen = new Person(“Mary”){…};
</code></pre><p>静态内部类：内部类不需要引用外围类对象。</p>
<p>定义格式如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/34ecf4c74895d93e6c0ee09ac44de10a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>声明在接口中的内部类自动成为static和public。如果内部类有public修饰，则可以这样定义内部类对象，如：ArrayList.Pair<br>p=ArrayList.minmax(d);</p>
<p>在静态方法中定义的内部类必须声明为static。</p>
<p>代理(proxy)：在运行时创建一个实现了一组给丁接口的新类，在编译时无法确定需要实现哪个接口时使用。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>所有的异常都是由Throwable继承而来，在下一层立即分解为两个分支Error和Exception。Exception下一层分为RuntimeException和IOException,</p>
<p>派生于RuntimeException的异常(不可预测)包括下面积中情况：</p>
<ol>
<li>错误的类型转化</li>
<li>数组访问越界</li>
<li>访问空指针。</li>
</ol>
<p>应该通过检查数组下标是否越界来避免ArrayIndexOutOfBoundsException，通过在使用变量之前检测是否为空来杜绝NullPointerException异常的发生。</p>
<p>派生于IOExcepton的异常(可预测)包括：</p>
<ol>
<li>视图在文件尾部后面读取数据</li>
<li>试图打开一个错误格式的URL</li>
<li>试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在</li>
</ol>
<p>派生于RuntimeException类或Error类(描述了Java运行时系统的内部错误和资源消耗错误)的所有异常称为“未检查异常”，其他异常称为“已检查异常”。编译器敬爱能够核查是否为所有已检查异常提供异常处理器。</p>
<p>出现异常的情况：</p>
<ol>
<li>调用一个已检查异常的方法，如FileInputStream构造器。</li>
<li>在程序运行过程中发现错误，并且利用throw语句抛出一个已检查异常</li>
<li>出现未检查异常</li>
</ol>
<p>如果在子类中覆盖了超类的一个方法，那么，子类方法中声明的已检查异常不能超过超类方法中声明的异常范围。如果超类方法没有抛出任何已检查异常，那么子类也不能抛出任何已检查异常。</p>
<p>在C++中，throw说明符在运行时执行，而不是在编译时执行。如果函数抛出的异常没有出现在throw列表中，就会调用unexpected函数，其默认的结果实终止程序的执行。C++中，没有throw说明的函数可以抛出任何异常，而在Java中，没有throw说明的函数不能抛出任何已检查异常。</p>
<p><strong>抛出异常</strong></p>
<p>作为可能被他人使用的Java方法，应该在方法的首部声明这个方法可能抛出的一场，如：</p>
<pre><code>public FileInputStream(String name) throws FileNotFoundException{…}
</code></pre><p>对于抛出多个异常的方法如：</p>
<pre><code>public Image loadImage(String s) throws EOFException, MalformedURLException{…}
</code></pre><p>不要声明Java的内部错误以及从RuntimeException继承而来的未检查异常。</p>
<p>抛出异常类的例子如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/eed27ac85e00dc6ca7cd99a03bfde359.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>也可以抛出带有一个字符串参数的构造器，如：</p>
<pre><code>String gride=”Content-length:”+len+”, Received:”+n;
throw new EOFException(gride);//或者先申明一个对象，然后将对象抛出。
</code></pre><ol>
<li><p>创建异常类：定义一个派生于Exception的类或者派生于Exception子类的类，习惯上，定义的类应该包含两个构造器，一个是默认的构造器，另一个是带有详细信息描述的构造器(超类Throwable的toString方法将会打印出这些详细信息)，如：</p>
<p><img src="../resources/images/java/7bc03dc4e48ee05f1a4a121b9215c4b3.png" alt=""></p>
</li>
<li><p>捕获异常：通常，应该捕获那些知道如何处理的异常，而将不知道如何处理的异常传递出去。</p>
<p><img src="../resources/images/java/8e9958d1d98851653d35a75bec19bd4e.png" alt=""></p>
<p>可以通过Exception类的getMessage()得到详细的错误信息或者使用getClass().getName()得到异常对象的实际类型。</p>
<p>在一个try语句块中捕获多个，如：</p>
<p><img src="../resources/images/java/8ff9830c531950d06c5f0dccc52b9b98.png" alt=""></p>
<p>在一个catch子句中，也可以抛出一个异常，并且将原始异常设置为新异常的“诱饵”，如：</p>
<p>在捕获异常时，可以使用下面的语句获得原始异常，Throwable e=se.getCarse();</p>
<p><img src="../resources/images/java/aea88778acf72552d7cfc0a74b71b3a5.png" alt=""></p>
<p>在捕获异常时，可以使用下面的语句获得原始异常，Throwable e=se.getCause();</p>
</li>
</ol>
<p><strong>finally 子句</strong></p>
<p>语法如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/b3f74bd402af48403d26772143f7b292.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果代码没有抛出异常，程序先执行try语句块中的全部代码，然后执行finally子句中的代码，随后执行try语句块之后的第一条语句。</p>
<p>如果代码抛出一个在catch子句中捕获的异常，则跳过try语句块中剩余的代码，去执行与该异常匹配子句中的代码，最后执行finally子句中的代码。如果catch子句没有抛出异常，则执行finally和try语句块后的语句。如果catch子句抛出了一个异常，那么程序将异常抛回这个方法的调用者处并执行finally语句。</p>
<p>如果代码抛出了一个不能由catch子句捕获的异常，程序将跳过try语句中的剩余代码，然后执行finally子句中的代码，并将异常抛给这个方法的调用者。</p>
<p>try语句可以只有finally子句，而没有catch子句。此书强烈建议使用try/catch和try/finally语句块，如下的这段代码有比较好的清晰度而且还可以报告finally子句中出现的错误。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/6553837b1f08b65b5f39469a58cab4f7.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果try子句和finally子句中都包含return语句，那么try子句中的返回值可能被finally子句块中的返回值覆盖，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/b5bfe560a21110ea04cbc0b24f6d648f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>当使用try/catch/finally语句块时，如果finally语句也抛出异常，可能将try子句中没有被捕获的异常覆盖。</p>
<p>浮点计算(如除0.0或计算-1的开平方)不会产生异常，而是得到一个“无穷大”和“非法数值”的特殊值。但是整数除0却会抛出一个ArithmetciException异常。检测一个数值是否是非数值时不能用语句if(x==Double.NaN)…因为所有“非数值”的值都被认为是不相同的，但是可以用函数Double.isNaN(double<br>x)方法，如if(Double.isNaN(x))…</p>
<p><strong>使用异常机制的建议</strong></p>
<p>异常处理不能代替简单的测试，因为异常机制相对比较慢。如退栈之前检查栈是否为空比捕获EmptyStackException异常要快。</p>
<p>不要过分细化异常，因为容易造成代码膨胀。</p>
<p>利用异常层次结构，不要之抛出RuntimeException，应该寻找更加适合的子类或创建自己的异常类。不要捕获Throwable异常，否则，会使程序代码更加难读、更难维护。将一种异常转换成另一种更加适合的异常时不要犹豫。如在解析一个文件中的一个整数时，捕获NumberFormatException异常，然后将它转换成IOException或MySubsystemException的子类。</p>
<p>不要羞于传递异常，其实，传递异常要比捕获这些异常更好。</p>
<h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><p>利用(java.util.logging.)Logger.global替代System.out输出信息，如：</p>
<pre><code>Logger.global.info(“FileOpen menu item selected”);//在输出结果中自动包含了时间、调用的类和方法名。如果再恰当的地方(如在main方法的开头)调用

Logger.global.setLevel(Level.OFF)将会取消所有的日志。
</code></pre><p>创建记录器对象，如：</p>
<pre><code>Logger myLogger=Logger.getLogger(“com.mycompony.myapp”);
</code></pre><p>日记记录器具有层次结构，日记记录器的父与子之间将共享某些属性，如子记录器将记录父记录器的日志级别。日记记录器有七个记录器级别(由低到高)，如：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p>
<p>设置日志级别如：logger.setLevel(Level.FINE);//或logger.log(Level.FINE,message)，此时可以记录FINE和更高的记录。</p>
<p>对于全部级别，有下列记录方法，如：</p>
<pre><code>logger.warning(message);
logger.fine(message);
</code></pre><p>默认的日志配置了INFO或更高级别的所有记录。如果将日记级别设置为INFO或更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于INFO级别的信息。</p>
<p>使用日志记录进行异常描述，如：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../resources/images/java/f1eb7a781c3356763aaec44f672e955e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>调用throwing可以记录一条FINER级别的记录和一条以THROW开始的消息。</p>
<h2 id="流与文件"><a href="#流与文件" class="headerlink" title="流与文件"></a>流与文件</h2><p>通则：存储在文件中的信息和从网络连接中接受的信息，从本质上来说，处理的方法是相同的。</p>
<p><code>InputStream/OutputStream</code> 为可以读取和写入字节序列的抽象类，而Reader和Writer为处理双字节的Unicode字符的抽象类。</p>
<p>InputStream的抽象方法abstract int<br>read()的含义为读取一个字节并将其返回，如果已经读到了输入源的末尾，将返回-1。如FileInputStream覆盖此方法是先从文件中读取一个字节，System.in是一个预定义的InputStream的子类的对象，使用它可以从键盘读取信息。</p>
<pre><code>abstract void wrote(int b);
</code></pre><p>同理。</p>
<p>不论是read方法还是write方法都能阻塞一个线程直到字节被真正地读取或者写入。如果流不能立即被读取或者写入，Java就会挂起这个调用的线程。</p>
<p>available方法能够监测目前可以读取得字节数，如：</p>
<pre><code>int bytesAvailable=in.available();
if(bytesAvailable\&gt;0){
    byte[] data=new byte[bytesAvailable];
    in.read(data);
}
</code></pre><p>当完成对一个流的读取或者写入后，就应该调用close方法将他们关闭，这样可以释放所占用的操作系统资源。对于输出来说，关闭流可以刷新缓冲区。</p>
<p>流还提供了一些其他的功能如ZipInputStream和ZipOutputStream能读写常见的ZIP压缩格式的文件。</p>
<p>reader与writer工作方式与InputStream和OutputStream工作方式类似。</p>
<p>建议使用\\作为文件的分隔符，在Windows系统下也可以用/作为文件的分隔符。对应的文件分隔符存放在常量字符串File.separator中。</p>
<p>字节流(以二进制的形式输入和输出，I/O速度快且效率高)<br><strong>(如何处理循环输入问题)</strong></p>
<p>创建FileInputStream的方法，如</p>
<pre><code>FileInputStream fin=new FileInputStream(“employee.dat”);
File f=new File(“employee.dat”);
FileInputStream fin=new FileInputStream(f);
</code></pre><p>FileOutputStream(string name,boolean<br>append);如果append为true，将数据追加到文件的结尾，存在的同名未见不会被删除，否则将删除同名文件。</p>
<p>只能从fin对象中读取字节和字节数组，如：byte b=(byte)fin.read();</p>
<p>可以用DataInputStream来读取数值类型，它实现了DataInput中的方法，如：</p>
<pre><code>DataInputStream din=...;
double s=din.readDouble();
</code></pre><p>但是DataInputStream没有从文件中读取数值的方法。</p>
<p>为了能够从文件中读取数值，可以先创建一个FileInputStream，然后将它传递给一个DataInputStream的构造器，即创建过滤流，如：</p>
<pre><code>FileInputStream fin=new FileInputStream(“employee.dat”);
DataInputStream din=new DataInputStream(fin);
double s=din.readDouble();
</code></pre><p>默认情况下，流不能进行缓冲处理，如果要对一个文件进行缓冲和数据输入操作，则可以如下构造过滤器：</p>
<pre><code>DataInputStream din=new DataInputStream(
new BufferedInputStream(
new FileInputStream(“employee.dat”) ))
</code></pre><p>为了查看下一个是否为想要的值，可以用PushbackInputStream，如：</p>
<pre><code>PushbackInputStream pbin=new PushbackInputStream(
new BufferedInputStream(
new FileInputStream(“employee.dat”)));
int b=pbin.read();如果b不是想要的，则可以将它扔回去，如：
if(b!=’\&lt;’) pbin.unread(b);
</code></pre><p>如果既想欲查看，又想读入数值，则需要使用一个pushback输入流和一个数据输入流，如：</p>
<pre><code>DataInputStream din=new DataInputStream(
new PushbackInputStream(
new BufferInputStream(new FileInputStream(“employee.dat”))));
</code></pre><p>从一个ZIP文件中读取数值，如：</p>
<pre><code>ZipInputStream zin=new ZipInputStream(new FileInputStream(“employee.zip”));
DataInputStream din=new DataInputStream(zin);
</code></pre><p>可以为BufferedInputStream和PushbackInputStream创建制定大小的流，如：</p>
<pre><code>BufferedInputStream(InputStream in, int size);
PushbackInputStream(InputStream in, int size)
</code></pre><h3 id="数据流-接口类"><a href="#数据流-接口类" class="headerlink" title="数据流(接口类)"></a>数据流(接口类)</h3><p>DataOutput提供写入数据的方法如：writeChars、writeByte、writeInt、WriteShort、WriteLong、writeShort、writeLong、writeFloat、writeDouble、writeChar、writeBoolean、writeUTF。</p>
<p>Java中，所有的值都采用高字节前存的方法存储，是它具有平台独立性。</p>
<p>除了UTF字符串意外，其他的都可以随机存取，主要的缺点是这些二进制文件不适合人们阅读。</p>
<h3 id="随即存取文件流"><a href="#随即存取文件流" class="headerlink" title="随即存取文件流"></a>随即存取文件流</h3><p>打开一个随即存取文件，要么进行只读操作，要么进行读写操作，可以通过构造器的第二个参数指定，如：</p>
<pre><code>RandomAccessFile in = new HandomAccessFile(“employee.dat”,”r”);
RandomAccessFile inOut=new RandomAccessFile(“employee.dat”,”rw”);
</code></pre><p>当打开一个现有文件作为RandomAccessFile时，原来的问及哪不会被删除。</p>
<p><code>seek(long
point)</code> 指针设定在文件内部的任意字节位置，getFilePoint()返回文件指针当前的位置。RandomAccessFile对象可以使用与DataInputStream对象相同的方法，如readInt, readChar,因为RandomAccessFile和DataInputStream都实现了DataInput接口。RandomAccessFile与DataOutputStream实现了DataOutput接口，所以可以使用writeInt和writeChar方法。可以通过long length()返回文件的长度(以字节计算)。</p>
<h3 id="文本流"><a href="#文本流" class="headerlink" title="文本流"></a>文本流</h3><p>Java使用的是Unicode字符，而操作系统都使用自己的编码，于是Java提供了一套流过滤器作为Unicode字符码和本地操作系统使用的字符码间的桥梁。所有这些类都从抽象类Reader和Writer类派生而来，如InputStreamReader可将那些字节采用的俄特殊字符编码方案的输入流转换成发布Unicode字符的reader，同理，OutputStreamWriter类能把Unicode字符流转换成采用字符编码方案的字节流，如InputStreamReader<br>in=new InputStream(System.in);能够接受从控制台输入，并将其转化成Unicode码。</p>
<p>可以指定读取器的编码方案，如InputStreamReader in=new InputStreamReader(new</p>
<pre><code>FileInputStream(“employee.dat”,“ISO8859_));
</code></pre><p>将读取器和写入器同文件联系在一起，如：</p>
<pre><code>FileWriter out=new FileWriter(“output.txt”);相当于
FileWriter out=new FielWriter(new FileOutputStream(“out.txt”));
</code></pre><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>获取Charset：</p>
<pre><code>Charset cset=Charset.forName(“ISO-8859);
</code></pre><p>迭代处理集合元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; aliases=cset.aliases();//返回字符集的别名的集合</div><div class="line">    for(String alias:aliases)&#123;</div><div class="line">    System.out.println(alias);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找出所有可用的集合类的名称：</p>
<pre><code>Set&lt;String, Charset&gt; charsets=Charset.availableCharsets();
    for(String name: charsets.keySet()){
    System.out.println(name);
}
</code></pre><p>对Unicode字符串进行编码：</p>
<pre><code>String str=…;
ByteBuffer buffer=cset.encode(str);//对给定的字符串编码为一个字节序列
byte[] bytes=buffer.array();//返回缓冲区维护的字符数组
</code></pre><p>对字节序列解码：</p>
<pre><code>byte[] bytes=…;
ByteBuffer bbuf=ByteBuffer.wrap(byte, offset, length);//把字节数组转化成字节缓冲区
CharBuffer cbuf=cset.decode(bbuf);//对所给的字符序列译码
String str=cbuf.toStrig();//返回由缓冲区维护的代码单元组成的字符串
</code></pre><h3 id="文本输出"><a href="#文本输出" class="headerlink" title="文本输出"></a>文本输出</h3><p>进行文本输出时，应该使用PrintWriter，可以与一个目标wirter相结合，如：</p>
<pre><code>PrintWriter out=new PrintWriter(new FileWriter(“employee.txt”));
</code></pre><p>也可以和一个目的输出流合并在一起，如：</p>
<pre><code>PrintWriter out=new PrintWriter(new FileOutputStream(“employee.txt”));
</code></pre><p>PrintWriter(OutputStream)构造器自动增加一个OutputStreamWriter来将Unicode字符转换为流内字节。</p>
<p>PrintWriter对象可以使用System.out中的print和println方法来打印数值、字符、布尔值，字符串和对象等，如</p>
<pre><code>doublesalary=2566;
out.println(salary);
</code></pre><p>将salary写入out中，随后字符将被转换为字节并且最终进入文件employee.txt中。</p>
<p>println()自动添加目标系统的正确行结束字符(在Windows中是“\r\n”，Unix上是“\n”)，调用System.getProperty(“line.separator”)可获得该字符。</p>
<p>通过PrintWriter(Writer,boolean) 的第二个参数来开启或关闭自动刷新，在这种模式下，在任何时候调用println，缓冲区内的所有字符都会被送到目的地，默认为不自动刷新模式如：</p>
<pre><code>PrintWriter out = new PrintWriter(new FileWriter(“employee.txt”),true);
</code></pre><p>PrintWriter总是缓冲的。</p>
<h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3><p>在使用BufferedReader处理文本输入时，需要同一个输入源结合起来，如：</p>
<pre><code>BufferedReader in=new BufferedReader(new FileReader(“employee.txt”));
</code></pre><p>如果没有输入数据，readLine()方法将返回null，如一个典型的输入循环：</p>
<pre><code>String line;
while((line=in.readLine())!=null){…}
</code></pre><p>FileReader类已经把字节转化为Unicode字符，对于其他的输入源，需要使用</p>
<pre><code>InputStreamReader，它没有自动弥补字节和Unicode字符之间差别的方法，如：
BufferedReader in2=new BufferedReader(new InputStreamReader(System.in));
BufferedReader in2=new BufferedReader(new InputStreamReader(url.openStream()));
</code></pre><p>要从文本输入读取数字，首先需要读取一个字符串并转换它，如：</p>
<p>String s=in.readLine();<br>double x=Double.parseDouble(s);</p>
<p>如果每行不止一个数值，则需要对输入的字符串使用StringTokenizer类进行分解。</p>
<p>ZIP文件流(于java.util.zip包中，是java.io.FilterInputStream和java.io.FilterOutputStream的子类)</p>
<p>顺序读取ZIP文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ZipInputStream zin=new ZipInputStream(new FileInputStream(zipname));</div><div class="line">//构造ZipInputStream的方法</div><div class="line">ZipEntry entry;</div><div class="line">while((entry=zip.getNextEntry())!=null)&#123;</div><div class="line">    //getNextEntry方法返回一个描述每个独立条目的ZipEntry类型的对象</div><div class="line">    ...</div><div class="line">    zin.closeEntry();</div><div class="line">    //必须调用closeEntry来读取下一条目</div><div class="line">&#125;</div><div class="line">zip.close();</div></pre></td></tr></table></figure>
<p>ZipInputStream的read方法进行了修改，当达到当前条目的末尾时，返回-1</p>
<p>读取Zop条目的内容(使用流过滤器的方法)：</p>
<pre><code>BufferedReader in=new BufferedReader(new InputStreamReader(zin));
String s;
while((s=in.readLine())!=null){
    ...
}
</code></pre><p>从键盘输入(java.util.Scanner)</p>
<pre><code>Scanner in=new Scanner(System.in);
int t=in.nextInt();
System.out.println(t);
</code></pre><p>向ZIP文件内写入，如：</p>
<pre><code>FileOutputStream fout=new FileOutputStream(“test.zip”);
ZipOutputStream zout=new ZipOutputStream(fout);
</code></pre><p>//对于一条希望置入ZIP文件的条目，都要创建一个ZipEntry对象，只要把文件名传给ZipEntry构造器，它将会自动设置其它参数，诸如文件日期和压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for all files&#123;</div><div class="line">    ZipEntry ze=new ZipEntry(filename);</div><div class="line">    zout.putNextEntry(ze);</div><div class="line">    ...</div><div class="line">    zout.closeEntry();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JAR文件时ZIP文件，它拥有另一个特殊的条目，被称为框架，可以用JarInputStream和JarOutputStream类来读写框架条目。</p>
<pre><code>java.util.zip.ZipEntry(java.util.zip.ZipEntry略)
</code></pre><p>获取条目为压缩时的大小：long<br>getSize();如果未经压缩时的大小未知，返回-1。通过方法bool<br>isDirectory()的返回布尔值表明是否是一个目录。获取条目的名称：String getName();</p>
<p>参考<a href="http://www.javaworld.com/javaworld/jw-10-1000/jw-1027-toolbox.html" target="_blank" rel="external">http://www.javaworld.com/javaworld/jw-10-1000/jw-1027-toolbox.html</a><br>修改一个ZIP文件</p>
<h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><p>java.io中的类都是将相对路径名解析为起始于用户的当前工作目录，获取当前目录的方法为System.getProperty(“user.dir”)来获取。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-08-19T02:44:58.274Z" itemprop="dateUpdated">2018-08-19 10:44:58</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/Java/2016-11-03-java-core.html" target="_blank" rel="external">http://blog.inching.org/Java/2016-11-03-java-core.html</a>
        
    </div>
    <footer>
        <a href="http://blog.inching.org">
            <img src="/img/avatar.png" alt="Cody Fei">
            Cody Fei
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.inching.org/Java/2016-11-03-java-core.html&title=《Java Core》 — Balance&pic=http://blog.inching.org/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.inching.org/Java/2016-11-03-java-core.html&title=《Java Core》 — Balance&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.inching.org/Java/2016-11-03-java-core.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java Core》 — Balance&url=http://blog.inching.org/Java/2016-11-03-java-core.html&via=http://blog.inching.org" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.inching.org/Java/2016-11-03-java-core.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/Data/2016-11-03-encoding-javascript-unicode.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">What every JavaScript developer should know about Unicode</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/Android/2016-10-26-android-util.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Android Utils</h4>
      </a>
    </div>
  
</nav>



    











</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.JPG" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.JPG" data-alipay="/img/alipay.JPG">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top" style="display:none">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>footer.license</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Cody Fei &copy; 2012 - 2018</span>
            <span style="display:none">
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.inching.org/Java/2016-11-03-java-core.html&title=《Java Core》 — Balance&pic=http://blog.inching.org/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.inching.org/Java/2016-11-03-java-core.html&title=《Java Core》 — Balance&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.inching.org/Java/2016-11-03-java-core.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java Core》 — Balance&url=http://blog.inching.org/Java/2016-11-03-java-core.html&via=http://blog.inching.org" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.inching.org/Java/2016-11-03-java-core.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACH0lEQVR42u3aS27DMAwFwNz/0um2QGr1UXQMSBqtgsSxOV4I/Oj1itf7Y/3+Prnmao3/e/PCwMBYlpE/pnrPZ14BBgbGOYwklM9b57+OX8T4buPrMTAwMK6uufqmHxAGBgZGh3HvVnv1KwYGBkaniE2K207oD9XiGBgYCzLm2mfPfP7KfAMDA2Mpxru4One4axjwx78wMDC2ZsyNMPO2WhJcUqxGpSwGBsamjPGWOle4Jold9Yn/3AEDA2NrRj6ATFr/eXD91h4GBsY5jHwAmW+C+dY5Hl7m7T8MDIy9GXOX9h9/VzsPAwPjBMY4mcvzyrwBlyeaecKKgYFxAiNpwXeOcOWlbCH0z8EABgbGMYy8TT93nKJTNl9Gi4GBsTWjethi7lBFnhTmJTQGBgZGNZmrtt5yQKFHiIGBcRjjLlKeAt4wzcDAwNiU0WnxlyeixVFoYePGwMDYmpEPMpMN+q4NPR+XYmBgnMboJ4t5KdsZJFwiMTAwDmDMDSyroc+9juiJGBgYhzGqbfp8y67CCiUuBgbG1oxOI6x6IKPTsJuceGBgYCzOeBdXFVxt2yXfl/t5GBgYizOq48Y+NU8ZvzJAxcDAWJbRGQNUQ8+baPmxDwwMjHMYnVDmGmdzaV/hsAUGBsbBjLnGfZ7wTVIxMDAwirOFnJQHjYGBgVFN8qpFab69PtRuw8DAWIqRl45zA4M8ucyfNTnUxMDAWI/xA7jVma+mxrqaAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.6.17"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.17" async></script>










</body>
</html>
