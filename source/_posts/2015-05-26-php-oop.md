layout: post
title: "PHP OOP"
description: ""
category: PHP
tags: [php, tutorial]
---

## Class

### Declaring a Class

```php
<?php
  $object = new User;
  print_r($object);

  class User
  {
    public $name, $password;

    function save_user()
    {
      echo "Save User code goes here";
    }
  }
?>
```

Here I have also used an invaluable function called `print_r`. It asks PHP to display information about a variable in human-readable form. The `_r` stands for _in human-readable format_. In the case of the new object `$object`, it prints the following:

```
User Object
(
  [name]     =>
  [password] =>
)
```

However, a browser compresses all the whitespace, so the output in a browser is slightly harder to read:

    User Object ( [name] => [password] => )

In any case, the output says that `$object` is a user-defined object that has the properties `name` and `password`.

### Constructors

When creating a new object, you can pass a list of arguments to the class being called. These are passed to a special method within the class, called the _constructor_, which initializes various properties.

```php
<?php
  class User
  {
    function User($param1, $param2)
    {
      // Constructor statements go here
      public $username = "Guest";
    }
  }
?>
```

However, PHP 5 provides a more logical approach to naming the constructor, which is to use the function name `__construct` (that is, `construct` preceded by two underscore characters):

```
<?php
  class User
  {
    function __construct($param1, $param2)
    {
      // Constructor statements go here
      public $username = "Guest";
    }
  }
?>
```

### PHP 5 Destructors

Also new in PHP 5 is the ability to create _destructor_ methods. This ability is useful when code has made the last reference to an object or when a script reaches the end.

```
<?php
  class User
  {
    function __destruct()
    {
      // Destructor code goes here
    }
  }
?>
```

### Writing Methods

declaring a method is similar to declaring a function, but there are a few differences. For example, method names beginning with a double underscore (`__`) are reserved, and you should not create any of this form.

You also have access to a special variable called `$this`, which can be used to access the current object’s properties.

```
<?php
  class User
  {
    public $name, $password;

    function get_password()
    {
      return $this->password;
    }
  }
?>
```

Note how the preceding `$` of the property `$password` is omitted when we use the `->` operator.

### Static Properties and Methods in PHP 5

If you are using PHP 5, you can also define a method as _static_, which means that it is called on a class, not on an object. A static method has no access to any object properties.

```php
<?php
  User::pwd_string();

  class User
  {
    static $static_property = "I'm static";

    static function pwd_string()
    {
      echo "Please enter your password";
    }

    function get_sp()
    {
       return self::$static_property;
    }
  }
?>
```

Note how we call the class itself, along with the static method, using a double colon (also known as the _scope resolution_ operator), not `->`.

Note how the method `get_sp` accesses `$static_property` using the keyword `self`. This is how a static property or constant can be directly accessed within a class.

### Declaring Properties

It is not necessary to explicitly declare properties within classes, as they can be implicitly defined when first used.

```
<?php
  $object1       = new User();
  $object1->name = "Alice";

  echo $object1->name;

  class User {}
?>
```

It is not necessary to explicitly declare properties within classes, as they can be implicitly defined when first used. 

```
<?php
  $object1       = new User();
  $object1->name = "Alice";

  echo $object1->name;

  class User {}
?>
```

But this kind of programming can lead to bugs that are infuriatingly difficult to discover, because `name` was declared from outside the class.

Also, when you declare a property within a class, you may assign a default value to it. The value you use must be a constant and not the result of a function or expression.

```
<?php
  class Test
  {
    public $name  = "Paul Smith"; // Valid
    public $age   = 42;           // Valid
    public $time  = time();       // Invalid - calls a function
    public $score = $level * 2;   // Invalid - uses an expression
  }
?>
```

### Declaring Constants

In the same way that you can create a global constant with the define function, you can define constants inside classes. The generally accepted practice is to use uppercase letters to make them stand out.

```
<?php
  Translate::lookup();

  class Translate
  {
    const ENGLISH = 0;
    const SPANISH = 1;
    const FRENCH  = 2;
    const GERMAN  = 3;
    // ...

    static function lookup()
    {
      echo self::SPANISH;
    }
  }
?>
```

You can reference constants directly, using the `self` keyword and double colon operator.

### Property and Method Scope in PHP 5

PHP 5 provides three keywords for controlling the scope of properties and methods:

- public

    These properties are the default when you are declaring a variable using the `var` or `public` keywords, or when a variable is implicitly declared the first time it is used. The keywords `var` and `public` are interchangeable because, although deprecated, `var` is retained for compatibility with previous versions of PHP. Methods are assumed to be `public` by default. 

- protected

    These properties and methods (_members_) can be referenced only by the object’s class methods and those of any subclasses.

- private

    These members can be referenced only by methods within the same class—not by subclasses.

Here’s how to decide which you need to use:

* Use `public` when outside code _should_ access this member and extending classes _should_ also inherit it.

* Use `protected` when outside code _should not_ access this member but extending classes _should_ inherit it.

* Use `private` when outside code _should not_ access this member and extending classes also _should not_ inherit it.

```
<?php
  class Example
  {
    var $name   = "Michael"; // Same as public but deprecated
    public $age = 23;        // Public property
    protected $usercount;    // Protected property

    private function admin() // Private method
    {
      // Admin code goes here
    }
  }
?>
```


## Object

### Creating an Object

To create an object with a specified class, use the `new` keyword, like this: `object = new Class`. Here are a couple of ways in which we could do this:

```php
<?php
    $object = new User;
    $temp   = new User('name', 'password');
?>
```

### Accessing Objects

```php
<?php
  $object = new User;
  print_r($object); echo "<br>";

  $object->name     = "Joe";
  $object->password = "mypass";
  print_r($object); 
?>
```

You should note that the example `property` and `method` do not have `$` signs in front of them. If you were to preface them with `$` signs, the code would not work, as it would try to reference the value inside a variable. For example, the expression `$object->$property` would attempt to look up the value assigned to a variable named `$property` (let’s say that value is the string `brown`) and then attempt to reference the property `$object->brown`. If `$property` is undefined, an attempt to reference `$object->NULL` would occur and cause an error.

You can place functions and class definitions anywhere in your code, before or after statements that use them. Generally, though, it is considered good practice to place them toward the end of a file.

### Cloning Objects

Once you have created an object, it is passed by reference when you pass it as a parameter. To avoid this confusion, you can use the clone operator, which creates a new instance of the class and copies the property values from the original instance to the new instance.

```php
<?php
  $object1       = new User();
  $object1->name = "Alice";
  $object2       = clone $object1;
  $object2->name = "Amy";

  echo "object1 name = " . $object1->name . "<br>";
  echo "object2 name = " . $object2->name;

  class User
  {
    public $name;
  }
?>
```

## Inheritance

```php
<?php
  $object           = new Subscriber;
  $object->name     = "Fred";
  $object->password = "pword";
  $object->phone    = "012 345 6789";
  $object->email    = "fred@bloggs.com";
  $object->display();

  class User
  {
    public $name, $password;

    function save_user()
    {
      echo "Save User code goes here";
    }
  }

  class Subscriber extends User
  {
    public $phone, $email;

    function display()
    {
      echo "Name:  " . $this->name     . "<br>";
      echo "Pass:  " . $this->password . "<br>";
      echo "Phone: " . $this->phone    . "<br>";
      echo "Email: " . $this->email;
    }
  }
?>
```

### The parent operator

If you write a method in a subclass with the same name as one in its parent class, its statements will override those of the parent class. Sometimes this is not the behavior you want, and you need to access the parent’s method. To do this, you can use the `parent` operator:

```php
<?php
  $object = new Son;
  $object->test();
  $object->test2();

  class Dad
  {
    function test()
    {
      echo "[Class Dad] I am your Father<br>";
    }
  }

  class Son extends Dad
  {
    function test()
    {
      echo "[Class Son] I am Luke<br>";
    }

    function test2()
    {
      parent::test();
    }
  }
?>
```

If you wish to ensure that your code calls a method from the current class, you can use the `self` keyword, like this:

    self::method();

### Subclass constructors

When you extend a class and declare your own constructor, you should be aware that PHP will not automatically call the constructor method of the parent class. If you want to be certain that all initialization code is executed, subclasses should always call the parent constructors.

```php
<?php
  $object = new Tiger();

  echo "Tigers have...<br>";
  echo "Fur: " . $object->fur . "<br>";
  echo "Stripes: " . $object->stripes;

  class Wildcat
  {
    public $fur; // Wildcats have fur

    function __construct()
    {
      $this->fur = "TRUE";
    }
  }

  class Tiger extends Wildcat
  {
    public $stripes; // Tigers have stripes

    function __construct()
    {
      parent::__construct(); // Call parent constructor first
      $this->stripes = "TRUE";
    }
  }
?>
```

### Final methods

When you wish to prevent a subclass from overriding a superclass method, you can use the `final` keyword.

```
<?php
  class User
  {
    final function copyright()
    {
      echo "This class was written by Joe Smith";
    }
  }
?>
```

## Interface

Interface definition:

```
interface Documentable
{
    public function getId();

    public function getContent();
}
```

This interface definition says that any object implementing the `Documentable` interface must provide a public `getId()` method and a public `getContent()` method.

This shows an implementation that can fetch HTML from a remote URL with curl:

```
class HtmlDocument implements Documentable
{
    protected $url;

    public function __construct($url)
    {
        $this->url = $url;
    }

    public function getId()
    {
        return $this->url;
    }

    public function getContent()
    {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $this->url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt($ch, CURLOPT_MAXREDIRS, 3);
        $html = curl_exec($ch);
        curl_close($ch);

        return $html;
    }
}
```

How we can use the DocumentStore class with our three document-collecting implementations:

```
<?php
$documentStore = new DocumentStore();

// Add HTML document
$htmlDoc = new HtmlDocument('https://php.net');
$documentStore->addDocument($htmlDoc);

// Add stream document
$streamDoc = new StreamDocument(fopen('stream.txt', 'rb'));
$documentStore->addDocument($streamDoc);

// Add terminal command document
$cmdDoc = new CommandOutputDocument('cat /etc/hosts');
$documentStore->addDocument($cmdDoc);

print_r($documentStore->getDocuments());
```

## Traits

The PHP language uses a classical inheritance model. This means you start with a single generalized root class that provides a base implementation. You extend the root class to create more specialized classes that inherit their immediate parent’s implementation. This is called an inheritance hierarchy, and it is a common pattern used by many programming languages.

The classical inheritance model works well most of the time. However, what do we do if two unrelated PHP classes need to exhibit similar behavior? For example, a PHP class `RetailStore` and another PHP class `Car` are very different classes and don’t share a common parent in their inheritance hierarchies. However, both classes should be geocodable into latitude and longitude coordinates for display on a map.

Traits were created for exactly this purpose. They enable modular implementations that can be injected into otherwise unrelated classes. Traits also encourage code reuse.

My first (bad) reaction is to create a common parent class `Geocodable` that both `RetailStore` and `Car` extend. This is a _bad_ solution because it forces two otherwise unrelated classes to share a common ancestor that does not naturally belong in either inheritance hierarchy.

My second (better) reaction is to create a `Geocodable` interface that defines which methods are required to implement the geocoding behavior. The `RetailStore` and `Car` classes can both implement the `Geocodable` interface. This is a good solution that allows each class to retain its natural inheritance hierarchy, but it requires us to duplicate the same geocoding behavior in both classes. This is not a DRY solution.

My third (best) reaction is to create a `Geocodable` trait that defines _and_ implements the geocodable methods. I can then mix the `Geocodable` trait into both the `RetailStore` and `Car` classes without polluting their natural inheritance hierarchies.

### Create a Trait

```
<?php
trait MyTrait {
    // Trait implementation goes here
}
```

Let’s return to our `Geocodable` example to better demonstrate traits in practice. We agree both `RetailStore` and `Car` classes need to provide geocodable behavior, and we’ve decided inheritance and interfaces are not the best solution. Instead, we create a `Geocodable` trait that returns latitude and longitude coordinates that we can plot on a map.

```
<?php
trait Geocodable {
    /** @var string */
    protected $address;

    /** @var \Geocoder\Geocoder */
    protected $geocoder;

    /** @var \Geocoder\Result\Geocoded */
    protected $geocoderResult;

    public function setGeocoder(\Geocoder\GeocoderInterface $geocoder)
    {
        $this->geocoder = $geocoder;
    }

    public function setAddress($address)
    {
        $this->address = $address;
    }

    public function getLatitude()
    {
        if (isset($this->geocoderResult) === false) {
            $this->geocodeAddress();
        }

        return $this->geocoderResult->getLatitude();
    }

    public function getLongitude()
    {
        if (isset($this->geocoderResult) === false) {
            $this->geocodeAddress();
        }

        return $this->geocoderResult->getLongitude();
    }

    protected function geocodeAddress()
    {
        $this->geocoderResult = $this->geocoder->geocode($this->address);

        return true;
    }
}
```

The `Geocodable` trait defines only the properties and methods necessary to implement the geocodable behavior. It does not do anything else.

Our `Geocodable` trait defines three class properties: an address (string), a geocoder object (an instance of `\Geocoder\Geocoder` from the excellent [`willdurand/geocoder`](http://geocoder-php.org) component by William Durand), and a geocoder result object (an instance of `\Geocoder\Result\Geocoded`).

### Use a Trait

Using a PHP trait is easy. Add the code `use MyTrait;` inside a PHP class definition. Here’s an example. Obviously, replace `MyTrait` with the appropriate PHP trait name:

```
<?php
class MyClass
{
    use MyTrait;

    // Class implementation goes here
}
```

Both namespaces and traits are imported with the `use` keyword. _Where_ they are imported is different. We import namespaces, classes, interfaces, functions, and constants _outside_ of a class definition. We import traits _inside_ a class definition. The difference is subtle but important.

The RetailStore class definition:

```
<?php
class RetailStore
{
    use Geocodable;

    // Class implementation goes here
}
```

That’s all we have to do. Now each `RetailStore` instance can use the properties and methods provided by the `Geocodable` trait:

```
<?php
$geocoderAdapter = new \Geocoder\HttpAdapter\CurlHttpAdapter();
$geocoderProvider = new \Geocoder\Provider\GoogleMapsProvider($geocoderAdapter);
$geocoder = new \Geocoder\Geocoder($geocoderProvider);

$store = new RetailStore();
$store->setAddress('420 9th Avenue, New York, NY 10001 USA');
$store->setGeocoder($geocoder);

$latitude = $store->getLatitude();
$longitude = $store->getLongitude();
echo $latitude, ':', $longitude;
```

## Generators

PHP generators are an underutilized yet remarkably helpful feature introduced in PHP 5.5.0. I think many PHP developers are unaware of generators because their purpose is not immediately obvious. _Generators are simple iterators_. That’s it.

Unlike your standard PHP iterator, PHP generators don’t require you to implement the `Iterator` interface in a heavyweight class. Instead, generators _compute and yield iteration values on-demand_. This has profound implications for application performance. Think about it. A standard PHP iterator often iterates in-memory, precomputed data sets. This is inefficient, especially with large and formulaic data sets that can be computed instead. This is why we use generators to compute and yield subsequent values on the fly without commandeering valuable memory.

PHP generators are not a panacea for your iteration needs. Because generators never know the _next_ iteration value until asked, it’s impossible to rewind or fast-forward a generator. You can iterate in only one direction—forward. Generators are also a once-and-done deal. You can’t iterate the same generator more than once. However, you are free to rebuild or clone a generator if necessary.

Generators are easy to create because they are just PHP functions that use the `yield` keyword one or more times. Unlike regular PHP functions, generators never return a value. They only _yield_ values.

```
<?php
function myGenerator() {
    yield 'value1';
    yield 'value2';
    yield 'value3';
}
```

When you invoke the generator function, PHP returns an object that belongs to the `Generator` class. This object can be iterated with the `foreach()` function. During each iteration, PHP asks the `Generator` instance to compute and provide the next iteration value. What’s neat is that the generator pauses its internal state whenever it yields a value. The generator resumes internal state when it is asked for the next value. The generator continues pausing and resuming until it reaches the end of its function definition or an empty `return;` statement.

```
<?php
foreach (myGenerator() as $yieldedValue) {
    echo $yieldedValue, PHP_EOL;
}
```

## Closures

_Closures_ and _anonymous functions_ were introduced in PHP 5.3.0, and they’re two of my favorite and most used PHP features. They sound scary (at least _I_ thought so when I first learned about them), but they’re actually pretty simple to understand. They’re extremely useful tools that every PHP developer should have in the toolbox.

A closure is a function that encapsulates its surrounding state at the time it is created. The encapsulated state exists inside the closure even when the closure lives after its original environment ceases to exist. This is a difficult concept to grasp, but once you do it’ll be a life-changing moment.

Closures and anonymous functions are, in theory, separate things. However, PHP considers them to be one and the same. So when I say closure, I also mean anonymous function. And vice versa.

PHP closures and anonymous functions use the same syntax as a function, but don’t let them fool you. They’re actually objects _disguised_ as PHP functions. If you  inspect a PHP closure or anonymous function, you’ll find they are instances of the `Closure` class. Closures are considered first-class value types, just like a string or integer.

### Create

So we know PHP closures look like functions.

```
<?php
$closure = function ($name) {
    return sprintf('Hello %s', $name);
};

echo $closure("Josh");
// Outputs --> "Hello Josh"
```

It looks like a standard PHP function: it uses the same syntax, it accepts arguments, and it returns a value. However, it does not have a name.

We can invoke the `$closure` variable because the variable’s value is a closure, and closure objects implement the `\__invoke()` magic method. PHP looks for and calls the `__invoke()` method whenever `()` follows a variable name.

I typically use PHP closure objects as function and method callbacks. Many PHP functions expect callback functions, like `array_map()` and `preg_replace_callback()`. This is a perfect opportunity to use PHP anonymous functions! Remember, closures can be passed into other PHP functions as arguments, just like any other value.

```
<?php
$numbersPlusOne = array_map(function ($number) {
    return $number + 1;
}, [1,2,3]);
print_r($numbersPlusOne);
// Outputs --> [2,3,4]
```

### Attach State

So far I’ve demonstrated nameless (or _anonymous_) functions used as callbacks. Let’s explore how to attach and enclose state with a PHP closure. JavaScript developers might be confused by PHP closures because they do not automatically enclose application state like true JavaScript closures. Instead, you must manually attach state to a PHP closure with the closure object’s `bindTo()` method or the `use` keyword.

It’s far more common to attach closure state with the `use` keyword. When you attach a variable to a closure via the `use` keyword, the attached variable
retains the value assigned to it _at the time it is attached to the closure_.

```
<?php
function enclosePerson($name) {
    return function ($doCommand) use ($name) {
        return sprintf('%s, %s', $name, $doCommand);
    };
}

// Enclose "Clay" string in closure
$clay = enclosePerson('Clay');

// Invoke closure with command
echo $clay('get me sweet tea!');
// Outputs --> "Clay, get me sweet tea!"
```

The `enclosePerson()` named function accepts a `$name` argument, and it returns a closure object that _encloses_ the `$name` argument. The returned closure object preserves the `$name` argument’s value even after the closure exits the `enclosePerson()` function’s scope. The `$name` variable still exists in the closure!

You can pass multiple arguments into a closure with the `use` keyword.
Separate multiple arguments with a comma, just as you do with
any PHP function or method arguments.

Don’t forget, PHP closures are objects. Each closure instance has its own internal state that is accessible with the `$this` keyword just like any other PHP object. A closure object’s default state is pretty boring; it has a magic `__invoke()` method and a `bindTo()` method. That’s it.

However, the `bindTo()` method opens the door to some interesting possibilities. This method lets us _bind_ a `Closure` object’s internal state to a _different object_. The `bindTo()` method accepts an important second argument that specifies the PHP class of the object to which the closure is bound. This lets the closure access protected and private member variables of the object to which it is bound.

You’ll find the `bindTo()` method is often used by PHP frameworks that map route URLs to anonymous callback functions. Frameworks accept an anonymous function and bind it to the application object. This lets you reference the primary application object inside the anonymous function with the `$this` keyword.

```
 <?php
class App
{
    protected $routes = array();
    protected $responseStatus = '200 OK';
    protected $responseContentType = 'text/html';
    protected $responseBody = 'Hello world';

    public function addRoute($routePath, $routeCallback)
    {
        $this->routes[$routePath] = $routeCallback->bindTo($this, __CLASS__);
    }

    public function dispatch($currentPath)
    {
        foreach ($this->routes as $routePath => $callback) {
            if ($routePath === $currentPath) {
                $callback();
            }
        }

        header('HTTP/1.1 ' . $this->responseStatus);
        header('Content-type: ' . $this->responseContentType);
        header('Content-length: ' . mb_strlen($this->responseBody));
        echo $this->responseBody;
    }
}
```

Pay close attention to the `addRoute()` method. It accepts a route path (e.g., `/users/josh`) and a route callback. The `dispatch()` method accepts the current HTTP request path and invokes the matching route callback. The magic happens on line 11 when we bind the route callback to the current `App` instance. This lets us create a callback function that can manipulate the `App` instance state:

```
<?php
$app = new App();
$app->addRoute('/users/josh', function () {
    $this->responseContentType = 'application/json;charset=utf8';
    $this->responseBody = '{"name": "Josh"}';
});
$app->dispatch('/users/josh');
```

## PSR-4: Autoloaders

The fourth PHP-FIG recommendation describes a standardized autoloader strategy. An autoloader is a strategy for finding a PHP class, interface, or trait and loading it into the PHP interpreter on-demand at runtime. PHP components and frameworks that support the PSR-4 autoloader standard can be located by and loaded into the PHP interpreter with only one autoloader. This is a big deal given the modern PHP ecosystem’s affinity for many interoperable components.

How often have you seen code like this at the top of your PHP files?

```
<?php
include 'path/to/file1.php';
include 'path/to/file2.php';
include 'path/to/file3.php';
```

All too often, right? You’re probably familiar with the `require()`, `require_once()`, `include()`, and `include_once()` functions. These functions load an external PHP file into the current script, and they work wonderfully if you have only a few PHP scripts. However, what if you need to include a hundred PHP scripts? What if you need to include a thousand PHP scripts? The `require()` and `include()` functions do not scale well, and this is why PHP autoloaders are important. An autoloader is a strategy for finding a PHP class, interface, or trait and loading it into the PHP interpreter on-demand at runtime, without explicitly including files as the example does.

Before the PHP-FIG introduced its PSR-4 recommendation, PHP component and framework authors used the `__autoload()` and `spl_autoload_register()` functions to register custom autoloader strategies. Unfortunately, each PHP component and framework used a unique autoloader, and every autoloader used different logic to locate and load PHP classes, interfaces, and traits. Developers using these components and frameworks were obliged to invoke each component’s autoloader when bootstrapping a PHP application. I use Sensio Labs’[Twig](http://twig.sensiolabs.org) template component all the time. It’s awesome. Without PSR-4, however, I have to read Twig’s documentation and figure out how to register its custom autoloader in my application’s bootstrap file, like this:

```
<?php
require_once '/path/to/lib/Twig/Autoloader.php';
Twig_Autoloader::register();
```

Imagine having to research and register unique autoloaders for every PHP component in your application. The PHP-FIG recognized this problem and proposed the PSR-4 autoloader recommendation to facilitate component interoperability. Thanks to PSR-4, we can autoload all of our application’s PHP components with only one autoloader. This is amazing. Most modern PHP components and frameworks are compatible with PSR-4. If you write and distribute your own components, make sure they are compatible with PSR-4, too! Participating components include Symfony, Doctrine, Monolog, Twig, Guzzle, SwiftMailer, PHPUnit, Carbon, and many others.

### The PSR-4 Autoloader Strategy

Like any PHP autoloader, PSR-4 describes a strategy to locate and load PHP classes, interfaces, and traits during runtime. The PSR-4 recommendation does not require you to change your code’s implementation. Instead, PSR-4 only suggests how your code is organized into filesystem directories and PHP namespaces. The PSR-4 autoloader strategy relies on PHP namespaces and filesystem directories to locate and load PHP classes, interfaces, and traits.

The essence of PSR-4 is mapping a top-level namespace prefix to a specific filesystem directory. For example, I can tell PHP that classes, interfaces, or traits beneath the `\Oreilly\ModernPHP` namespace live beneath the _src/_ physical filesystem directory. PHP now knows that any classes, interfaces, or traits that use the  `\Oreilly\ModernPHP` namespace prefix correspond to directories and files beneath the _src/_ directory. For example, the `\Oreilly\ModernPHP\Chapter1` namespace corresponds to the _src/Chapter1_ directory, and the `\Oreilly\ModernPHP\Chapter1\Example` class corresponds to the _src/Chapter1/Example.php_ file.

PSR-4 lets you map a namespace prefix to a filesystem directory. The namespace prefix can be one top-level namespace. The namespace prefix can also be a top-level namespace and any number of subnamespaces. It’s quite flexible.

### How to Write a PSR-4 Autoloader

We know that PSR-4 compatible code has a namespace prefix that maps to a base filesystem directory. We also know that subnamespaces beneath the namespace prefix map to subdirectories beneath the base filesystem directory. The following example shows an autoloader implementation, borrowed from the PHP-FIG website, that finds and loads classes, interfaces, and traits based on the PSR-4 autoloader strategy.

```
<?php
/**
 * An example of a project-specific implementation.
 *
 * After registering this autoload function with SPL, the following line
 * would cause the function to attempt to load the \Foo\Bar\Baz\Qux class
 * from /path/to/project/src/Baz/Qux.php:
 *
 *      new \Foo\Bar\Baz\Qux;
 *
 * @param string $class The fully qualified class name.
 * @return void
 */
spl_autoload_register(function ($class) {

    // project-specific namespace prefix
    $prefix = 'Foo\\Bar\\';

    // base directory for the namespace prefix
    $base_dir = __DIR__ . '/src/';

    // does the class use the namespace prefix?
    $len = strlen($prefix);
    if (strncmp($prefix, $class, $len) !== 0) {
        // no, move to the next registered autoloader
        return;
    }

    // get the relative class name
    $relative_class = substr($class, $len);

    // replace the namespace prefix with the base directory, replace namespace
    // separators with directory separators in the relative class name, append
    // with .php
    $file = $base_dir . str_replace('\\', '/', $relative_class) . '.php';

    // if the file exists, require it
    if (file_exists($file)) {
        require $file;
    }
});
```

Copy and paste this into your application, change the `$prefix` and `$base_dir` variables, and you have yourself a working PSR-4 autoloader. However, if you find yourself writing your own PSR-4 autoloader, stop and ask yourself if what you are doing is really necessary. Why? Because we can use PSR-4 autoloaders that are automagically generated by the Composer dependency manager.

## Namespaces

Let’s see how a real-world PHP component uses namespaces. The Symfony Framework’s own  [`symfony/httpfoundation`](https://github.com/symfony/HttpFoundation) is a popular PHP component that manages HTTP requests and responses. More important, the `symfony/httpfoundation` component uses common PHP class names like `Request`, `Response`, and `Cookie`.  I guarantee you there are many other PHP components that use these same class names.  How can we use the `symfony/httpfoundation` PHP component if other PHP code uses the same class names? We can safely use the `symfony/httpfoundation` component precisely because its code is sandboxed beneath the unique `Symfony` vendor namespace.

### Declaration

Every PHP class, interface, function, and constant lives beneath a namespace (or subnamespace). Namespaces are declared at the top of a PHP file on a new line immediately after the opening `<?php` tag. The namespace declaration begins with `namespace`, then a space character, then the namespace name, and then a closing semicolon `;` character.

Remember that namespaces are often used to establish a top-level vendor name.
This example namespace declaration establishes the `Oreilly` vendor name:

```
<?php
namespace Oreilly;
```

All PHP classes, interfaces, functions, or constants declared beneath this namespace declaration live in the `Oreilly` namespace and are, in some way, related to O’Reilly Media. What if we wanted to organize code related to this book? We use a subnamespace.

Subnamespaces are declared exactly the same as in the previous example. The only difference is that we separate namespace and subnamespace names with the `\` character. The following example declares a subnamespace named `ModernPHP` that lives beneath the topmost `Oreilly` vendor namespace:

```
<?php
namespace Oreilly\ModernPHP;
```

All classes in the same namespace or subnamespace don’t have to be declared in the same PHP file. You can specify a namespace or subnamespace at the top of any PHP file, and that file’s code becomes a part of that namespace or subnamespace. This makes it possible to write multiple classes in separate files that belong to a common namespace.

Unlike your operating system’s physical filesystem, PHP namespaces are a virtual concept and do not necessarily map 1:1 with filesystem directories. That being said, most PHP components do, in fact, map subnamespaces to filesystem directories for compatibility with the popular PSR-4 autoloader standard.

### Import and Alias

```
<?php
use Symfony\Component\HttpFoundation\Response;

$response = new Response('Oops', 400);
$response->send();
```

We tell PHP we intend to use the `Symfony\Component\HttpFoundation\Response` class with the `use` keyword. We type the long, fully qualified class name once. Then we can instantiate the `Response` class without using its fully namespaced class name.

```
use Symfony\Component\HttpFoundation\Response as Res;

$r = new Res('Oops', 400);
$r->send();
```

In this example, I changed the import line to import the `Response` class. I also appended `as Res` to the end of the import line; this tells PHP to consider `Res` an alias for the `Response` class. If we don’t append the `as Res` alias to the import line, PHP assumes a default alias that is the same as the imported class name.

As of PHP 5.6, it’s possible to import functions and constants. This requires a tweak to the use keyword syntax. To import a function, change use to use func:

```
<?php
use func Namespace\functionName;

functionName();
```

To import a constant, change `use` to `use constant`:

```
<?php
use constant Namespace\CONST_NAME;

echo CONST_NAME;
```

Function and constant aliases work the same as classes

### Multiple imports

If you import multiple classes, interfaces, functions, or constants into a single PHP file, you’ll end up with multiple `use` statements at the top of your PHP file. PHP accepts a shorthand import syntax that combines multiple `use` statements on a single line like this:

```
<?php
use Symfony\Component\HttpFoundation\Request,
    Symfony\Component\HttpFoundation\Response,
    Symfony\Component\HttpFoundation\Cookie;
```

Don’t do this. It’s confusing and easy to mess up. I recommend you keep each use statement on its own line like this:

```
<?php
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Cookie;
```

You’ll type a few extra characters, but your code is easier to read and troubleshoot.

### Multiple namespaces in one file

PHP lets you define multiple namespaces in a single PHP file like this:

```
<?php
namespace Foo {
    // Declare classes, interfaces, functions, and constants here
}

namespace Bar {
    // Declare classes, interfaces, functions, and constants here
}
```

This is confusing and violates the recommended one class per file good practice. Use only one namespace per file to make your code simpler and easier to troubleshoot

### Global namespace

If you reference a class, interface, function, or constant _without a namespace_, PHP assumes the class, interface, function, or constant lives in the current namespace. If this assumption is wrong, PHP attempts to resolve the class, interface, function, or constant. If you need to reference a namespaced class, interface, function, or constant _inside another namespace_, you must use the fully qualified PHP class name (namespace + class name).

Some code might not have a namespace and, therefore, lives in the _global namespace_. The native `Exception` class is a good example. You can reference globally namespaced code inside another namespace by prepending a `\` character to the class, interface, function, or constant name.

```
<?php
namespace My\App;

class Foo
{
    public function doSomething()
    {
        $exception = new Exception();
    }
}
```

Add a `\` prefix to the `Exception` class name. This tells PHP to look for the `Exception` class in the global namespace instead of the current namespace.