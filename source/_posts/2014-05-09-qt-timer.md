layout: post
title: "QT 定时器QTimer"
description: ""
category: Qt
tags: [qt, timer]
---

> 原文： [QT定时器QTimer - bingcaihuang - 博客园](http://www.cnblogs.com/bingcaihuang/archive/2010/12/07/1898660.html)

在Qt中使用定时器有两种方法，一种是使用QObiect类的定时器；一种是使用QTimer类。定时器的精确性依赖于操作系统和硬件，大多数平台支持20ms的精确度。

## QObject类的定时器

QObject是所有Qt对象的基类，它提供了一个基本的定时器。通过QObject::startTimer()，可以把一个一毫秒为单位的时间间隔作为参数来开始定时器，这个函数返回一个唯一的整数定时器的标识符。这个定时器开始就会在每一个时间间隔"触发"，直到明确的使用这个定时器的标识符来调用QObject::killTimer()结束。

当定时器触发时，应用程序会发送一个QTimerEvent。在事件循环中，处理器按照事件队列的顺序来处理定时器事件。当处理器正忙于其它事件处理时，定时器就不能立即处理。

<!-- more -->

QObject类还提供定时期的功能。与定时器相关的成员函数有：startTimer()、timeEvent()、killTimer()。QObject基类中的startTimer()和timerEvent()原型及说明如下：

	int QObject::startTimer(int interval);

开始一个定时器并返回定时器ID，如果不能开始一个定时器，将返回0。定时器开始后，每隔interval毫秒间隔将触发一次超时事件，直到killTimer()被调用来删除定时器。如果interval为0，那么定时器事件每次发生时没有窗口系统事件处理。

	virtual void QObject::timerEvent(QTimerEvent *event);

虚函数timerEvent()被重载来实现用户的超时事件处理函数。如果有多个定时器在运行，QTimerEvent::timerId()被用来查找指定定时器，对其进行操作。

当定时器事件发生时，虚函数timerEvent()随着QTimerEvent事件参数类一起被调用，重载这个函数可以获得定时器事件。

定时器的用法如下：

//头文件

	class QNewObject : public QObject
	{
	Q_OBJECT

	public:
		QNewObject( QObject * parent = 0 );
		virtual ~QNewObject();
	protected:
		void timerEvent( QTimerEvent *event );
		int m_nTimerId;
	};

//源文件

	QNewObject::QNewObject(QObject * parent ) :QNewObject( parent )
	{
		m_nTimerId = startTimer(1000);
	}

	QNewObject::~QNewObject()
	{
		if ( m_nTimerId != 0 )
		killTimer(m_nTimerId);
	}

	voidQNewObject::timerEvent( QTimerEvent *event )
	{
		qDebug( "timer event, id %d",event->timerId() );
	}

## 定时器类QTimer

定时器类QTimer提供当定时器触发的时候发射一个信号的定时器，他提供只触发一次的超时事件，通常的使用方法如下：

	//创建定时器
	QTimer *testTimer = newQTimer(this);

	//将定时器超时信号与槽(功能函数)联系起来
	connect( testTimer,SIGNAL(timeout()), this, SLOT(testFunction()) );

	//开始运行定时器，定时时间间隔为1000ms
	testTimer->start(1000);

	// ...

	//停止运行定时器
	if (testTimer->isActive() )
		testTimer->stop();

QTimer还提供了一个简单的只有一次定时的函数singleShot()。 一个定时器在100ms后触发处理函数animateTimeout()并且只触发一次。代码如下：

	QTimer::singleShot( 100,this, SLOT(animateTimeout()) );

QTimer类提供了定时器信号和单触发定时器。

它在内部使用定时器事件来提供更通用的定时器。QTimer很容易使用：创建一个QTimer，使用start()来开始并且把它的timeout()连接到适当的槽。当这段时间过去了，它将会发射timeout()信号。

注意当QTimer的父对象被销毁时，它也会被自动销毁。

实例：

	QTimer *timer = new QTimer( myObject );
	connect( timer, SIGNAL(timeout()),myObject, SLOT(timerDone()) );
	timer->start( 2000, TRUE ); // 2秒单触发定时器

你也可以使用静态的singleShot()函数来创建单触发定时器。

作为一个特殊情况，一旦窗口系统事件队列中的所有事件都已经被处理完，一个定时为0的QTimer就会到时间了。

这也可以用来当提供迅速的用户界面时来做比较繁重的工作。

	QTimer *t = new QTimer( myObject );
	connect( t, SIGNAL(timeout()), SLOT(processOneThing()));
	t->start( 0, FALSE );

myObject->processOneThing()将会被重复调用并且应该很快返回（通常在处理一个数据项之后），这样Qt可以把事件传送给窗口部件并且一旦它完成这个工作就停止这个定时器。这是在图形用户界面应用程序中实现繁重的工作的一个典型方法，现在多线程可以在越来越多的平台上使用，并且我们希望无效事件最终被线程替代。

注意QTimer的精确度依赖于底下的操作系统和硬件。绝大多数平台支持20毫秒的精确度，一些平台可以提供更高的。如果Qt不能传送定时器触发所要求的数量，它将会默默地抛弃一些。

另一个使用QTimer的方法是为你的对象调用QObject::startTimer()和在你的类中（当然必须继承QObject）重新实现QObject::timerEvent()事件处理器。缺点是timerEvent()不支持像单触发定时器或信号那样的高级水平。

一些操作系统限制可能用到的定时器的数量，Qt会尽力在限制范围内工作。
