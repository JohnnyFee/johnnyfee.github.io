layout: post
title: "PHP IO"
description: ""
category: PHP
tags: [php, tutorial]
---

See [《Modern PHP》](http://www.salttiger.com/modern-php/) and [《Learning PHP, MySQL & JavaScript, 4th Edition》](http://www.salttiger.com/learning-php-mysql-javascript-4th-edition/).

## File

### Checking Whether a File Exists

To determine whether a file already exists, you can use the `file_exists` function, which returns either `TRUE` or `FALSE`, and is used like this:

    if (file_exists("testfile.txt")) echo "File exists";

<!-- more -->

### Creating a File

```php
<?php // testfile.php
  $fh = fopen("testfile.txt", 'w') or die("Failed to create file");

  $text = <<<_END
Line 1
Line 2
Line 3
_END;

  fwrite($fh, $text) or die("Could not write to file");
  fclose($fh);
  echo "File 'testfile.txt' written successfully";
?>
```

Upon failure, `FALSE` will be returned by `fopen`. The previous example shows a simple way to capture and respond to the failure: it calls the `die` function to end the program and give the user an error message. A web application would never abort in this crude way (you would create a web page with an error message instead), but this is fine for our testing purposes.

__The supported fopen modes:__

Mode  |  Action|  Description
------|------|------
'r' | Read from file start |    Open for reading only; place the file pointer at the beginning of the file. Return FALSE if the file doesn’t already exist.
'r+'|     Read from file start and allow writing | Open for reading and writing; place the file pointer at the beginning of the file. Return FALSE if the file doesn’t already exist.
'w'|  Write from file start and truncate file | Open for writing only; place the file pointer at the beginning of the file and truncate the file to zero length. If the file doesn’t exist, attempt to create it.
'w+' |    Write from file start, truncate file, and allow reading | Open for reading and writing; place the file pointer at the beginning of the file and truncate the file to zero length. If the file doesn’t exist, attempt to create it.
'a' | Append to file end  | Open for writing only; place the file pointer at the end of the file. If the file doesn’t exist, attempt to create it.
'a+' |    Append to file end and allow reading    | Open for reading and writing; place the file pointer at the end of the file. If the file doesn’t exist, attempt to create it.

### Reading from Files

```php
<?php
  $fh = fopen("testfile.txt", 'r') or
    die("File does not exist or you lack permission to open it");

  $text = fread($fh, 3);
  fclose($fh);
  echo $text;
?>
```

### Copying Files

```php
<?php // copyfile.php
  copy('testfile.txt', 'testfile2.txt') or die("Could not copy file");
  echo "File successfully copied to 'testfile2.txt'";
?>
```

### Moving a File

```
<?php // movefile.php
  if (!rename('testfile2.txt', 'testfile2.new'))
    echo "Could not rename file";
  else echo "File successfully renamed to 'testfile2.new'";
?>
```

You can use the `rename` function on directories, too. To avoid any warning messages, if the original file doesn’t exist, you can call the `file_exists` function first to check.

### Deleting a File

Deleting a file is just a matter of using the `unlink` function to remove it from the file system.

```
<?php // deletefile.php
  if (!unlink('testfile2.new')) echo "Could not delete file";
  else echo "File 'testfile2.new' successfully deleted";
?>
```

As with moving a file, a warning message will be displayed if the file doesn’t exist, which you can avoid by using `file_exists` to first check for its existence before calling `unlink`.

### Updating Files

```
<?php // update.php
  $fh   = fopen("testfile.txt", 'r+') or die("Failed to open file");
  $text = fgets($fh);

  fseek($fh, 0, SEEK_END);
  fwrite($fh, "$text") or die("Could not write to file");
  fclose($fh);

  echo "File 'testfile.txt' successfully updated";
?>
```

As used here, in addition to the `$fh` file handle, the `fseek` function was passed two other parameters, `0` and `SEEK_END`. `SEEK_END` tells the function to move the file pointer to the end of the file, and `0` tells it how many positions it should then be moved backward from that point. In the case of Example 7-11, a value of `0` is used, because the pointer is required to remain at the file’s end.

There are two other seek options available to the `fseek` function: `SEEK_SET` and `SEEK_CUR`. The `SEEK_SET` option tells the function to set the file pointer to the exact position given by the preceding parameter. Thus, the following example moves the file pointer to position 18:

    fseek($fh, 18, SEEK_SET);

`SEEK_CUR` sets the file pointer to the current position _plus_ the value of the given offset. Therefore, if the file pointer is currently at position 18, the following call will move it to position 23:

    fseek($fh, 5, SEEK_CUR);

Although this is not recommended unless you have very specific reasons for it, it is even possible to use text files such as this (but with fixed line lengths) as simple flat file databases. Your program can then use `fseek` to move back and forth within such a file to retrieve, update, and add new records. You can also delete records by overwriting them with zero characters, and so on.

### Locking Files for Multiple Accesses

Web programs are often called by many users at the same time. If more than one person tries to write to a file simultaneously, it can become corrupted. And if one person writes to it while another is reading from it, the file is all right, but the person reading it can get odd results. To handle simultaneous users, you must use the file-locking `flock` function. This function queues up all other requests to access a file until your program releases the lock.

```php
<?php
  $fh   = fopen("testfile.txt", 'r+') or die("Failed to open file");
  $text = fgets($fh);

  if (flock($fh, LOCK_EX))
  {
    fseek($fh, 0, SEEK_END);
    fwrite($fh, "$text") or die("Could not write to file");
    flock($fh, LOCK_UN);
  }

  fclose($fh);
  echo "File 'testfile.txt' successfully updated";
?>
```

There is a trick to file locking to preserve the best possible response time for your website visitors: perform it directly before a change you make to a file, and then unlock it immediately afterward. Having a file locked for any longer than this will slow down your application unnecessarily. This is why the calls to `flock` are directly before and after the `fwrite` call:

The first call to `flock` sets an exclusive file lock on the file referred to by `$fh` using the `LOCK_EX` parameter:

    flock($fh, LOCK_EX);

From this point onward, no other processes can write to (or even read from) the file until you release the lock by using the `LOCK_UN` parameter, like this:

    flock($fh, LOCK_UN);

As soon as the lock is released, other processes are again allowed access to the file. This is one reason why you should re-seek to the point you wish to access in a file each time you need to read or write data, because another process could have changed the file since the last access.

`flock` is not supported on all systems. `flock` will not work on NFS and many other networked file systems.

### Reading an Entire File

A handy function for reading in an entire file without having to use file handles is `file_get_contents`. 

```
<?php
  echo "<pre>";  // Enables display of line feeds
  echo file_get_contents("testfile.txt");
  echo "</pre>"; // Terminates pre tag
?>
```

But the function is actually a lot more useful than that, because you can also use it to fetch a file from a server across the Internet.

```
<?php
  echo file_get_contents("http://oreilly.com");
?>
```

#### Uploading Files

```php
<?php // upload.php
  echo <<<_END
    <html><head><title>PHP Form Upload</title></head><body>
    <form method='post' action='upload.php' enctype='multipart/form-data'>
    Select File: <input type='file' name='filename' size='10'>
    <input type='submit' value='Upload'>
    </form>
_END;

  if ($_FILES)
  {
    $name = $_FILES['filename']['name'];
    move_uploaded_file($_FILES['filename']['tmp_name'], $name);
    echo "Uploaded image '$name'<br><img src='$name'>";
  }

  echo "</body></html>";
?>
```

The PHP code to receive the uploaded data is fairly simple, because all uploaded files are placed into the associative system array `$_FILES`. Therefore, a quick check to see whether `$_FILES` contains anything is sufficient to determine whether the user has uploaded a file. This is done with the statement `if ($_FILES)`.

Once the program realizes that a file was uploaded, the actual name, as read from the uploading computer, is retrieved and placed into the variable `$name`. Now all that’s necessary is to move the file from the temporary location in which PHP stored the uploaded file to a more permanent one. We do this using the `move_uploaded_file` function, passing it the original name of the file, with which it is saved to the current directory.

Five things are stored in the $_FILES array when a file is uploaded:

Array element |  Contents
-------|-------
$_FILES['file']['name']     | The name of the uploaded file (e.g., smiley.jpg)
$_FILES['file']['type']     | The content type of the file (e.g., image/jpeg)
$_FILES['file']['size']     | The file’s size in bytes
$_FILES['file']['tmp_name'] | The name of the temporary file stored on the server
$_FILES['file']['error']    | The error code resulting from the file upload

In addition to maliciously formed input data, some of the things you also have to check are whether a file was actually received and, if so, whether the right type of data was sent.

```php
<?php // upload2.php
  echo <<<_END
    <html><head><title>PHP Form Upload</title></head><body>
    <form method='post' action='upload2.php' enctype='multipart/form-data'>
    Select a JPG, GIF, PNG or TIF File:
    <input type='file' name='filename' size='10'>
    <input type='submit' value='Upload'></form>
_END;

  if ($_FILES)
  {
    $name = $_FILES['filename']['name'];

    switch($_FILES['filename']['type'])
    {
      case 'image/jpeg': $ext = 'jpg'; break;
      case 'image/gif':  $ext = 'gif'; break;
      case 'image/png':  $ext = 'png'; break;
      case 'image/tiff': $ext = 'tif'; break;
      default:           $ext = '';    break;
    }
    if ($ext)
    {
      $n = "image.$ext";
      move_uploaded_file($_FILES['filename']['tmp_name'], $n);
      echo "Uploaded image '$name' as '$n':<br>";
      echo "<img src='$n'>";
    }
    else echo "'$name' is not an accepted image file";
  }
  else echo "No image has been uploaded";

  echo "</body></html>";
?>
```

#### System Calls

Sometimes PHP will not have the function you need to perform a certain action, but the operating system it is running on may. In such cases, you can use the `exec` system call to do the job.

```php
<?php // exec.php
  $cmd = "dir";   // Windows
  // $cmd = "ls"; // Linux, Unix & Mac

  exec(escapeshellcmd($cmd), $output, $status);

  if ($status) echo "Exec command failed";
  else
  {
    echo "<pre>";
    foreach($output as $line) echo htmlspecialchars("$line\n");
    echo "</pre>";
?>
```

The `htmlspecialchars` function is called to turn any special characters returned by the system into ones that HTML can understand and properly display, neatening the output.

`exec` takes three arguments:* The command itself (in the previous case, `$cmd`)

* An array in which the system will put the output from the command (in the previous case, `$output`)

* A variable to contain the returned status of the call (which, in the previous case, is `$status`)

## Streams

If you’ve read from `php://stdin` or written to `php://stdout`, you’ve used streams. Streams provide the underlying implementation for many of PHP’s IO functions like `file_get_contents()`, `fopen()`, `fgets()`, and `fwrite()`. PHP’s stream functions help us manipulate different stream resources (origins and destinations) with a single interface.

### Stream Wrappers

There are different types of streamable data that require unique _protocols_ for reading and writing data. We call these protocols [stream wrappers](http://php.net/manual/wrappers.php). For example, we can read and write data to the filesystem. We can talk with remote web servers via HTTP, HTTPS, or SSH (secure shell). We can open, read, and write ZIP, RAR, or PHAR archives. All of these communication methods imply the same generic process:

1.  Open communication.
2.  Read data.
3.  Write data.
4.  Close communication.

Every stream has a _scheme_ and a _target_. We specify the scheme and target in the stream’s _identifier_ using this familiar format:

    <scheme>://<target>

The `<scheme>` identifies the stream’s wrapper. The `<target>` identifies the stream data source. Example 5-28 creates a PHP stream to/from the Flickr API. It uses the HTTP stream wrapper.

```
<?php
$json = file_get_contents(
    'http://api.flickr.com/services/feeds/photos_public.gne?format=json'
);
```

Don’t be fooled by what appears to be a traditional website URL. The `file_get_contents()` function’s string argument is actually a stream identifier. The `http` scheme prompts PHP to use the HTTP stream wrapper. The argument’s remainder is the stream target. The stream target looks like a traditional website URL only because that’s what the HTTP stream wrapper expects. This may not be true for other stream wrappers.

We use the `file_get_contents()`, `fopen()`, `fwrite()`, and `fclose()` methods to read from and write to the filesystem. We rarely consider these functions as using PHP streams, because the default PHP stream wrapper is `file://`. We’re using PHP streams and we don’t even realize it! Example 5-29 creates a stream to/from the _/etc/hosts_ file using the `file://` stream wrapper.

```
<?php
$handle = fopen('/etc/hosts', 'rb');
while (feof($handle) !== true) {
    echo fgets($handle);
}
fclose($handle);
```

HP developers who write command-line scripts will appreciate the `php://` stream wrapper. This stream wrapper communicates with the PHP script’s standard input, standard output, and standard error file descriptors. You can open, read from, and write to these four streams with PHP’s filesystem functions:

- php://stdin

    This read-only PHP stream exposes data provided via standard input. For example, a PHP script can use this stream to receive information piped into the script on the command line. 

- php://stdout

    This PHP stream lets you write data to the current output buffer. This stream is write-only and cannot be read or seeked.

- php://memory

    This PHP stream lets you read and write data to system memory. The downside to this PHP stream is that available memory is finite. It’s safer to use the php://temp stream instead.

- php://temp

    This PHP stream acts just like php://memory, except that when available memory is gone, PHP instead writes to a temporary file.

### Stream Context

Some PHP streams accept an optional set of parameters, or a _stream context_, to customize the stream’s behavior. Different stream wrappers expect different context parameters. You create a stream context with the `stream_context_create()` function. The returned context object can be passed into and used by most PHP filesystem and stream functions.

```
<?php
$requestBody = '{"username":"josh"}';
$context = stream_context_create(array(
    'http' => array(
        'method' => 'POST',
        'header' => "Content-Type: application/json;charset=utf-8;\r\n" .
                    "Content-Length: " . mb_strlen($requestBody),
        'content' => $requestBody
    )
));
$response = file_get_contents('https://my-api.com/users', false, $context);
```

The stream context is an associative array whose topmost array key is the stream wrapper name. The stream context’s array values are specific to each stream wrapper. Consult the appropriate PHP stream wrapper’s documentation for a list of valid settings.

### Stream Filters

PHP provides several built-in stream filters, including `string.rot13`, `string.toupper`, `string.tolower`, and `string.strip_tags`. These are not useful. Use custom stream filters, instead.

You attach a filter to an existing stream with the `stream_filter_append()` function.

```
<?php
$handle = fopen('data.txt', 'rb');
stream_filter_append($handle, 'string.toupper');
while(feof($handle) !== true) {
    echo fgets($handle); // <-- Outputs all uppercase characters
}
fclose($handle);
```