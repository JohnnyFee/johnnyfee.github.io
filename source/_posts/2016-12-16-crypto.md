---
layout: "post"
title: "Crypto"
date: "2016-12-16 22:08"
categories:
---

## 密钥

根据密钥的使用方法，可以将密钥分为对称密钥和非对称密钥。

- **对称密钥** （symmetric scypotography） 指的是加密和解密时使用同一密钥的方式。又称为公共密钥密码 (common-key crypotography)、传统密码（conventional cryptography）、私钥密钥（secret cryptography）、共享密钥密码（shared-key cryptography）。
- **公钥密钥** （public-key scypotography） 是指加密和解密时使用不同密钥的方式。又称为非对称密钥 (asymmetric cryptography)。

历史上有几种比较著名的密码：

- 凯撒密码。通过将明文中所用到的字母表按照一定的字数 “平移” 来进行加密。在日语（平假名）或者汉语（汉语拼音）也可以用同样的思路来实现凯撒密码。
- 简单密码替换。蒋明文中使用的字母表替换为另一套字母表的密码。凯撒密码也可以说是简单替换密码的一种。
- Enigma。二次大战中俄国使用的一种密码机。是一种由键盘、齿轮、电池和灯泡所组成的机器。

对应的破译方法为：

- 暴力攻击
- 频率分析

## 对称密钥

主要包括：

- 一次性密码本，也称为维纳密码（Vernam Cipher）。将明文和遗传随机的比特序列进行 XOR 运算，是绝对不会被破译的密码。这里说的无法破译，即便能够解出明文，也无法判断它是否是正确的明文。在一次性密码中是绝对不能重用过去用过的随机比特序列的。
- DES。1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。DES 已经能够被暴力破解。由于 DES 的密文可以在短时间内被破译，因此除了用它来破解以前的密文之外，不应该再使用 DES 了。
- 三重 DES
- AES

### DES

DES/3DES 是以 64 比特（8 字节）的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为**分组**。一个分组的比特数称为**分组长度**
。

当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行**填充**（padding）。

DES/3DES 的密钥长度是 64 比特，但由于每隔 7 比特会设置一个用于错误检查的比特，因此实际上其密钥长度是 56 比特。

一般来说，以分组为单位进行处理的密码算法称为**分组密码**（block cipher）。DES 和 3DES 均属于分组密码。

**流密码**（stream cipher）是对数据流进行连续处理的一类密码算法。流密码中一般以 1 比特、8 比特或者 32 比特等为单位进行加密和解密。

分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度，相对的，流密码是对遗传数据流进行连续处理，因此需要保持内部状态。

DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为**模式** （mode）。

DES 的基本结构是由 Horst Feistel 设计的，称为 Feistel 网络（Feistal network）。具体参考 《图解密码技术》 Ch3.5。DES 是一种 16 轮循环的 Feistel 网格。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥，这些子密钥由主要生成。

### 三重 DES

三重 DES(triple-des) 是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法，缩写为 3DES。

3DES 算法并不是进行 3 次 DES 加密（加密->加密->加密），而是加密->解密->加密，目的是让 3DES 能够兼容普通的 DES。当 3DES 中多有的密钥都相同时，3 DES 也就等同于普通的 DES 了，这是因为前两部加密->解密之后，得到的就是最初的明文。

如果秘钥 1 和秘钥 3 使用相同的秘钥，而秘钥 2 使用不同的秘钥，这种 3DES 称为 DES-EDE2，EDE表示的是加密->解密->加密（Encryption->Decryption->Encryption）。

具体加解密过程 具体参考 《图解密码技术》 Ch3.6。

尽管 3DES 目前还被银行等机构使用，但其处理速度不高，二球在安全性方面也逐渐显现出一些问题。

### AES

AES(Advance Encryption Standard)是取代其前任标准（DES）而称为新标准的一种对称密码算法。全世界企业和密码学家提交了多个对称秘钥算法微微 AES 候选，最终在 2000 年中这些候选算法中选出了一种名为 Rijndaeal 对对称密码算法，并将其确认为 AES。

Rjindael 的分组长度为 128 比特，16 字节，秘钥长度可以以 32 比特（4 字节）为单位，在 128 比特（16 字节）到 256 比特（32 字节）的范围内选择。不过，在 AES 的规格中，密码程度只有 16 字节、24 字节、32 字节三种。

Rjindael 算法也是有多个轮所构成，使用的是 SPN 结构。

今后大家都应该使用的算法是 AES，因为它安全、快速，而且能够在各种平台上工作。

### 密码分组模式

分组密码的主要模式有以下 5 中：

- ECB 模式： Electronic Codebook mode(电子密码本模式)。将明文分组加密之后的结果将直接成为密文分组。

    ECB 模式是所有模式中最简单的一种。明文分组和密文分组是一一对应的关系。因此，ECB 模式存在一定的风险。

    攻击者无须破译密码就能够操纵电文，只需要知道哪个分组记录了什么样的数据（即电文格式）就可以了。

- CBC 模式：Cipher Block Chaining mode(密码分组链接模式)。

    密文分组 = (明文分组 XOR 前一个密文分组) 加密。

    第一个密文分组为 **初始化向量**（initialization vector），通常缩写为 IV。一般来说，每次加密时都会随机产生一个不同的布特序列作为初始化向量。

    在 CBC 模式中，无法单独对一个中间的明文进行加密。

    对 CBC 的攻击为对初始化向量的比特反转。

- CFB 模式：Cipher Feedback mode（密文反馈模式）。

    明文分组和前一个密文分组加密后的结果做 XOR 运算得到密文分组。也就是说前一个密文分组会被送回到密码算法的输入端。

    密文分组 = 明文分组 XOR （前一个密文分组 加密）

    第一个密文分组为初始化向量。明文分组并没有通过密码算法来直接加密，而只有一个 XOR 运算。

    对 CFB 的攻击为重放攻击。

- OFB 模式：Output FeedBack mode（输出反馈模式）。

    密文分组 = 明文分组 XOR (前一个密文 加密)

    第一个密文的 IV，第二个密文为 IV 的加密...

    OFB 模式也为流密码。

- CTR 模式：CounTex mode（计算器模式）。通过将逐次累加的计数器进行加密来生成密钥流的流密码。

    密文分组N = 明文分组N XOR 计数器N  加密 


模式  | 优点  | 缺点  |  备注
--|---|---|--
ECB  | <li>简单<li>快速<li>支持并行计算  | <li>不能抵御重放攻击  | 不应使用
CBC  | <li>支持并行计算<li>能够解密任意密文分组  | <li>不支持并行计算  |推荐使用
CFB  |<li>不需要填充<li>支持并行计算（仅解密）<li>能够解密任意密文分组   | <li>加密不支持并行计算<li>不能抵御重放攻击  | 现在已不适用，推荐用 CTR 模式替代。
OFB  |<li>不需要填充  | <li>不支持并行计算<li>反转攻击  | 推荐用 CTR 代替
CTR  |<li>不需要填充<li>支持并行计算  |  | 推荐使用

### 填充模式 Padding

如电子密码本（ECB）和密文块链接（CBC）。 为对称密钥加密设计的块密码工作模式要求输入明文长度必须是块长度的整数倍，因此信息必须填充至满足要求。

#### 位填充 Bit padding/ISO/IEC 9797-1 Padding Method 2

位填充可用于任意大小的信息。

于信息后添加一个“设定”位（“1”），再添加“重设”位（“0”）至要求大小。“重设”位（“0”）的数量取决于信息末尾到块边缘的距离。以比特表示为“1000 ... 0000”。

这个方法可用于填充任何位长度的信息，而不限于整字节长度的信息。比如，一段 23 位的信息可填充 9 位以填满一个 32 位的块：

<code>
... | 1011 1001 1101 0100 0010 011**1 0000 0000** |
</code>

This padding is the first step of a two-step padding scheme used in many hash functions including MD5 and SHA. In this context, it is specified by RFC1321 step 3.1.

This padding scheme is defined by ISO/IEC 9797-1 as Padding Method 2.

#### 字节填充

字节填充可用于可编码为整数字节大小的信息。

#### ANSI X.923

In ANSI X.923 bytes filled with zeros are padded and the last byte defines the padding boundaries or the number of padded bytes.

Example: In the following example the block size is 8 bytes, and padding is required for 4 bytes (in hexadecimal format)

<pre>
... | DD DD DD DD DD DD DD DD | DD DD DD DD **00 00 00 04** |
</pre>

#### ISO 10126

ISO 10126 (withdrawn, 2007[2][3]) specifies that the padding should be done at the end of that last block with random bytes, and the padding boundary should be specified by the last byte.

Example: In the following example the block size is 8 bytes and padding is required for 4 bytes

<pre>
... | DD DD DD DD DD DD DD DD | DD DD DD DD **81 A6 23 04** |
</pre>

#### PKCS7/PKCS5

[PKCS#7](https://en.wikipedia.org/wiki/PKCS "PKCS") is described in [RFC 5652](http://tools.ietf.org/html/rfc5652#section-6.3).

Padding is in whole bytes. The value of each added byte is the number of bytes that are added, i.e. N bytes, each of value N are added. The number of bytes added will depend on the block boundary to which the message needs to be extended.

The padding will be one of:

<pre>
01
02 02
03 03 03
04 04 04 04
05 05 05 05 05
etc.
</pre>

This padding method (as well as the previous two) is well-defined if and only if 
<var style="padding-right: 1px;">N</var> is less than 256.

Example: In the following example the block size is 8 bytes and padding is required for 4 bytes

<pre>
... | DD DD DD DD DD DD DD DD | DD DD DD DD **04 04 04 04** |
</pre>

If the original data is an integer multiple of N bytes, then an extra block of bytes with value N is added. This is necessary so the deciphering algorithm can determine with certainty whether the last byte of the last block is a pad byte indicating the number of padding bytes added or part of the plaintext message. Consider a plaintext message that is an integer multiple of N bytes with the last byte of plaintext being 01. With no additional information, the deciphering algorithm will not be able to determine whether the last byte is a plaintext byte or a pad byte. However, by adding N bytes each of value N after the 01 plaintext byte, the deciphering algorithm can always treat the last byte as a pad byte and strip the appropriate number of pad bytes off the end of the ciphertext; said number of bytes to be stripped based on the value of the last byte.

PKCS#5 padding is identical to PKCS#7 padding, except that it has only been defined for block ciphers that use a 64-bit (8 byte) block size. In practice the two can be used interchangeably.

#### Zero padding

All the bytes that are required to be padded are padded with zero. The zero padding scheme has not been standardized for encryption,[citation needed] although it is specified for hashes and MACs as Padding Method 1 in ISO/IEC 10118-1[5] and ISO/IEC 9797-1.

Example: In the following example the block size is 8 bytes and padding is required for 4 bytes

<pre>
... | DD DD DD DD DD DD DD DD | DD DD DD DD **00 00 00 00** |
</pre>

Zero padding may not be reversible if the original file ends with one or more zero bytes, making it impossible to distinguish between plaintext data bytes and padding bytes. It may be used when the length of the message can be derived out-of-band. It is often applied to binary encoded strings as the null character can usually be stripped off as whitespace.

Zero padding is sometimes also referred to as "null padding" or "zero byte padding". Some implementations may add an additional block of zero bytes if the plaintext is already divisible by the block size.

#### ISO/IEC 7816-4

ISO/IEC 7816-4:2005[4] is identical to the bit padding scheme, applied to a plain text of N bytes. This means in practice that the first byte is a mandatory byte valued '80' (Hexadecimal) followed, if needed, by 0 to N-1 bytes set to '00', until the end of the block is reached. ISO/IEC 7816-4 itself is a communication standard for smart cards containing a file system, and in itself does not contain any cryptographic specifications.

Example: In the following example the block size is 8 bytes and padding is required for 4 bytes

<pre>
... | DD DD DD DD DD DD DD DD | DD DD DD DD **80 00 00 00** |
</pre>

The next example shows a padding of just one byte

<pre>
... | DD DD DD DD DD DD DD DD | DD DD DD DD DD DD DD **80** |
</pre>

## 公钥密码

公钥密码（pubic-key cryptography）中，密钥分为加密秘钥和解密秘钥。发送者用加密秘钥对消息进行加密，接收者用解密秘钥对密文进行解密。

公钥密码也成为非对称密码（asymmetric cryptography）。私钥也成为个人秘钥、私有迷药，非公开秘钥等。

加密秘钥中，加密秘钥一般是公开的，因此成为（public key）；解密秘钥是绝对不能公开的，因此成为私钥(private key)。

公钥私钥是一一对应的，一堆公钥和私钥统称为秘钥对（key pair）。

对称秘钥的秘钥配送问题，可以通过使用公钥秘钥来解决。公钥密码的处理速度只有对称秘钥的几百分之一；需要判断所得到的公钥是否正确合法，即共要认证问题。

### RSA

RSA 是一种共要密码算法，它的名字有三维开发者，即 Ron Riwest、Adi Shamir、Leonard Adleman 的姓氏的首字母组成。

RSA 可以被用于公钥密码和数字签名。

#### RSA 加密

<code>
密文 = 明文<sup>E</sup> mod N
</code>

RSA 的密文为明文的数字的 E 次方求 mod N 的结果。E 和 N 称为 RSA
 加密的秘钥，也就是说，E 和 N 的组合就是公钥，一般写成 公钥（E, N）或者 公钥 {E, N}。E 是加密（Encryption）的首字母，N 是数字（Number）的首字母。

#### RSA 解密

<code>
明文 = 密文<sup>D</sup> mod N
</code>

对表示密文的数字的 D 次方求 mod N 就得到明文。这里使用的数字 N 和加密时使用的数字 N 是相同的。D 和 N 的组合称为私钥。由于 N 是公钥的一部分，是公开的，因此单独的 D 称为私钥也是可以的。

#### 生成秘钥的方法

1. 求 N

    准备好两个很大的指数，如 512 比特大小。

        N = p x q

2. 求 L。L 尽在生成秘钥对的工程中使用的数。在加密和解密的过程中不出现，只出现在秘钥对的生成过程中。

        L = lcm(p-1, q-1) // L 是 p-1 和 q-1 的最小公倍数。

3. 求 E

        1 < E < L
        gcd(F, L)=1 // E 和 L 的最大公约数为 1（E 和 L 互质）。保证一定存在解密时需要使用的数 D。

4. 求 D

        1 < D < L
        E x D mod L = 1/ 


#### RSA 攻击

通过暴力破解和数学运算都很难破解 RSA 密码。对于 RSA 常用的攻击方法为中间人攻击(man-in-the-middle attack)，这种方法虽不能破译 RSA，但 却是一种针对机密性的有效攻击。

所谓中间人攻击，就是主攻攻击者（Mallory）混入发送者和接收者中间，对发送者伪装成接收者，对接收者伪装成发送者的攻击方式。在这个过程中，公钥密码并没有被破译，所有的密码算法也都整成的工作。

主攻攻击者 Mallory 窃听消息发送者 Alice 的内容，获取公钥，通过公钥加密伪造内容，发送给接收者 Bob。Bob 收到消息后，通过私钥解密，得到的是伪造后的内容。同理，攻击者也可以伪造 Bob 的发送内容。

这种攻击不仅针对 RSA，而是可以针对任何公钥密码。在这种情况下，我们可以使用公钥的 __证书__。

### 其他公钥密码

除了 RSA 之外，还有其他的共要密码，如 EIGamal 方式、Rabin 方式、椭圆曲线密码，都可以被用于一般的加密和数字签名。

### 密码强度

对称密码的秘钥长度 | 公钥密码的密钥程度
----------------|----------------- 
128 bit | 2304 bit
112 bit | 1792 bit
80 bit | 768 bit
64 bit | 512 bit
50 bit | 384 bit

1024 比特的公钥密码与 128 比特的对称秘钥相比，反而 128 比特的对称密码抵御暴力破解的能力更强。

## 混合密码系统

用对称密码提供速度，用公钥密码保护会话秘钥。

- 会话秘钥 = 通过伪随机数生成器生成的对称秘钥
- 密文消息 = 对称密码 加密 消息。
- 会话秘钥密文 = 公钥密码 加密 会话秘钥。会话密钥是对称密码的密钥，同时也是公钥密码的明文。将对称密码和公钥密码两种密码方式相互联系起来的正式会话秘钥。
- 混合密码系统的密文 = 将公钥密码加密的会话密钥 + 用对称密码加密的消息

混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了密钥的配送问题。著名的密码软件 PGP、以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统。


## Books

- [crypto101/book: Crypto 101, the introductory book on cryptography.](https://github.com/crypto101/book)
- 《图解密码技术》 [日]结城浩 著 周自恒 译

## Tools

- [DES Encryption – Easily encrypt or decrypt strings or files](http://des.online-domain-tools.com/)
- [DES Calculator](http://www.emvlab.org/descalc/?key=0123456789ABCDEF&iv=0000000000000000&input=0123456789ABCDEF&mode=ecb&action=Encrypt&output=56CC09E7CFDC4CEF)