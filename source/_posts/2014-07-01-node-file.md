layout: post
title: "Node File"
category: Node
tags: [node, file]
---

fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其他模块不同的是，fs 模块中所有的操作都提供了异步的和同步的两个版本， 例如读取文件内容的函数有异步的 fs.readFile() 和同步的fs.readFileSync()。

## Common APIs

可以使用封装性更高的文件模块，[aconbere/node-file-utils](https://github.com/aconbere/node-file-utils).

<!-- more -->

### open

fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数，path 为文件的路径，flags 可以是以下值。

- r ：以读取模式打开文件。  
- r+ ：以读写模式打开文件。  
- w ：以写入模式打开文件，如果文件不存在则创建，如果存在，内容被清空。
- w+ ：以读写模式打开文件，如果文件不存在则创建。  
- a ：以追加模式打开文件，如果文件不存在则创建。  
- a+ ：以读取追加模式打开文件，如果文件不存在则创建。  

mode 参数用于创建文件时给文件指定权限，默认是 0666回调函数将会传递一个文件描述符 fd②。

    fs.open("test.txt", "w");

### read

    fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead,buffer)]) 

`fs.read` 是 POSIX read 函数的封装，相比fs.readFile 提供了更底层的接口。`fs.read`的功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。offset 是buffer 的写入偏移量。length 是要从文件中读取的字节数。position 是文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。回调函数传递bytesRead 和 buffer，分别表示读取的字节数和缓冲区对象。
实例:

Opening, seeking to a position, reading from a file and closing it (in parts):

```js
 fs.open('./data/index.html', 'r', function(err, fd) {
    if(err) throw err;
    var str = new Buffer(3);
    fs.read(fd, buf, 0, buf.length, null, function(err, bytesRead, buffer) {
      if(err) throw err;
      console.log(err, bytesRead, buffer);
      fs.close(fd, function() {
        console.log('Done');
      });
    });
  });
```

    fs.readFile(filename,[encoding],[callback(err,data)])

`fs.readFile` 是最简单的读取文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding是可选的，表示文件的字符编码。callback 是回调函数，用于接收文件的内容。如果不指定 encoding，则 callback 就是第二个参数。回调函数提供两个参数 err 和 data，err 表示有没有错误发生，data 是文件内容。如果指定了 encoding，data 是一个解析后的字符串，否则 data 将会是以 Buffer 形式表示的二进制数据。
不指定编码方式就默认使用二进制的方式进行读取数据。

```js
var fs = require('fs');
fs.readFile('content.txt', function(err, data) {
    if (err) {
        console.error(err);
    } else {
        console.log(data);
    }
});
```

### readdir

Reading a directory returns the names of the items (files, directories and others) in it.

```js
var path = './data/';
fs.readdir(path, function (err, files) {
  if(err) throw err;
  files.forEach(function(file) {
    console.log(path+file);
    fs.stat(path+file, function(err, stats) {
      console.log(stats);
    });
  });
});
```

### mkdir

```js 
// fs.js
var fs = require('fs');
fs.mkdirSync('a', 0755);
fs.mkdirSync('a/b', 0755);
fs.mkdirSync('a/b/c', 0755);
```

那么它会在fs.js所在目录中创建一个a目录，a目录下再创建b目录，b目录下创建c目录。mkdirSync是一个同步方法，拥有三个参数，第一个是路径，第二个是[目录权限](http://hi.baidu.com/zhang_js521/blog/item/6976d10e2ca7d5fa36d122d6.html)，第三个是回调

但这样做有点不妥，如果指定目录已存在，就报错。如果要建立多级目录，一层层判定此目录是否存在，立即会陷入“回调地狱”的境地。虽然node.js对于IO操作的方法都提供了两个版本，一个是同步的，一个是异步的。想了想，搞出我自己的mkdirSync函数，实现比[mkdirp](https://github.com/substack/node-mkdirp/blob/master/index.js)的作者好很多。

```js    
var fs = require('fs');

function mkdirSync(url,mode,cb){
    var path = require("path"), arr = url.split("/");
    mode = mode || 0755;
    cb = cb || function(){};
    if(arr[0]==="."){//处理 ./aaa
        arr.shift();
    }
    if(arr[0] == ".."){//处理 ../ddd/d
        arr.splice(0,2,arr[0]+"/"+arr[1])
    }
    function inner(cur){
        if(!path.existsSync(cur)){//不存在就创建一个
            fs.mkdirSync(cur, mode)
        }
        if(arr.length){
            inner(cur + "/"+arr.shift());
        }else{
            cb();
        }
    }
    arr.length && inner(arr.shift());
}
//测试代码
mkdirSync("aaa/ddd/dd",0,function(e){
    if(e){
        console.log('出错了');
    }else{
        console.log("创建成功")
    }
});
```
    
有关目录的创建的讨论，详见[这里](http://stackoverflow.com/questions/5308514/prescriptive-nodejs)

### write

    fs.write(fd, buffer, offset, length, position, callback)

Opening, writing to a file and closing it (in parts):

```js
fs.open('./data/index.html', 'w', function(err, fd) {
  if(err) throw err;
  var buf = new Buffer('bbbbb\n');
  fs.write(fd, buf, 0, buf.length, null, function(err, written, buffer) {
    if(err) throw err;
    console.log(err, written, buffer);
    fs.close(fd, function() {
      console.log('Done');
    });
  });
});
```

The read() and write() functions operate on Buffers, so in the example above we create a new Buffer() from a string. Note that built-in readable streams (e.g. HTTP, Net) generally return Buffers.

    fs.writeFile(filename, data, [options], callback)

Write some content to a file:
    
```js
var fs = require('fs');

fs.writeFile("test.txt","third fs!",function(e){
    //会先清空原先的内容
    if(e) throw e;
});
```

Or using stream:

```js
var file = fs.createWriteStream('./data/results.txt', {flags: 'a'} );
file.write('HELLO!\n');
file.end(function() {
  test.done();
});
```

### delete

```js
var fs = require('fs');
fs.rmdir("aaa",function(e){
    if(e){
        console.log(e)
    }
})
/**
{ stack: [Getter/Setter],
  arguments: undefined,
  type: undefined,
  message: 'ENOTEMPTY, Directory not empty \'aaa\'',
  errno: 39,
  code: 'ENOTEMPTY',
  path: 'aaa' }
*/
```
    

报错，缘由是之前我们还为aaa创建了子目录，必须逐个删除，实在不人性化，于是又造了一个轮子。

```js
var fs = require('fs');
var getAllFolersAndFiles = (function(){
    function iterator(url, folders, files){
        var stat = fs.statSync(url);
        if(stat.isDirectory()){
            folders.unshift(url);//收集目录
            inner(url,folders, files);
        }else if(stat.isFile()){
            files.unshift(url);//收集文件
        }
    }
    function inner(path,folders,files){
        var arr = fs.readdirSync(path);
        for(var i = 0, el ; el = arr[i++];){
            iterator(path+"/"+el,folders,files);
        }
    }
    return function(dir){
        var folders = [], files = [];
        try{
            iterator(dir,folders,files);
        }catch(e){
        }finally{
            return {
                folders : folders,
                files   : files
            }
        }
    }
})()
```
    
如果我们只想取得指定目下的所有文件，还可以更精简些！

```js
function getAllFiles(root) {
  var result = [], files = fs.readdirSync(root)
  files.forEach(function(file) {
    var pathname = root+ "/" + file
      , stat = fs.lstatSync(pathname)
    if (stat === undefined) return

    // 不是文件夹就是文件
    if (!stat.isDirectory()) {
      result.push(pathname)
    // 递归自身
    } else {
      result = result.concat(getAllFiles(pathname))
    }
  });
  return result
}
```

另外可以参考：[sindresorhus/trash](https://github.com/sindresorhus/trash) Cross-platform command-line app for moving files and directories to the trash - A safer alternative to `rm`.

### state

You want to get certain attributes of a given file such as whether or not it is a file or a directory, and you want to be able to set certain attributes such as the file’s name or the file’s permissions.

```js
var fs = require('fs');
fs.stat('data.txt', function(err, stats) {
    if (err) throw err;
    if (stats.isFile()) {
        console.log('It\'s a file!');
    }
    if (stats.isDirectory()) {
        console.log('It\'s a directory!');
    }
    for (var i in stats) {
        if ('function' !== typeof stats[i]) console.log(i + '\t= ' + stats[i]);
    }
});
```

s.stat() gives us more information about each item. The object returned from fs.stat looks like this:

```json
{
    dev: 2114,
    ino: 48064969,
    mode: 33188,
    nlink: 1,
    uid: 85,
    gid: 100,
    rdev: 0,
    size: 527,
    blksize: 4096,
    blocks: 8,
    atime: Mon,
    10 Oct 2011 23: 24: 11 GMT,
    mtime: Mon,
    10 Oct 2011 23: 24: 11 GMT,
    ctime: Mon,
    10 Oct 2011 23: 24: 11 GMT
}
```

atime, mtime and ctime are Date instances. The stat object also has the following functions:

* stats.isFile()
* stats.isDirectory()
* stats.isBlockDevice()
* stats.isCharacterDevice()
* stats.isSymbolicLink() (only valid with fs.lstat())
* stats.isFIFO()
* stats.isSocket()


### watch

就是使用watchFile及其同步版本。

```js
var fs = require("fs"),
sys = require("util");
fs.open("aaa.js","w",0644,function(e,fd){
    fs.writeSync(fd,"console.log(1111);");
    fs.closeSync(fd);
})

fs.watchFile("aaa.js", function(curr, prev) {
  sys.puts("\n\ttest_file.txt has been edited");
  sys.puts("\tThe current mtime is: " + curr.mtime);
  sys.puts("\tThe previous mtime was: " + prev.mtime + "\n");
});

fs.open("aaa.js","a",0644,function(e,fd){
    fs.writeSync(fd,"console.log(2222)");
    fs.closeSync(fd);
});
```

- [paulmillr/chokidar](https://github.com/paulmillr/chokidar) A neat wrapper around node.js fs.watch / fs.watchFile. <http://paulmillr.com>

### rename and chmod

```js
fs.rename('data2.txt', 'data2_new.txt', function(err) {
    if (err) throw err;
    console.log('Renamed!');
});
fs.chmod('data3.txt', '0777', function(err) {
    if (err) throw err;
    console.log('File permissions changed!');
});
```

## Operation

### Reading a file and writing to another file

```js
var file = fs.createReadStream('./data/results.txt', {
    flags: 'r'
});
var out = fs.createWriteStream('./data/results2.txt', {
    flags: 'w'
});
file.on('data', function(data) {
    console.log('data', data);
    out.write(data);
});
file.on('end', function() {
    console.log('end');
    out.end(function() {
        console.log('Finished writing to file');
        test.done();
    });
});
```

You can also use pipe():

```js
var file = fs.createReadStream('./data/results.txt', {flags: 'r'} );
var out = fs.createWriteStream('./data/results2.txt', {flags: 'w'});
file.pipe(out);
```

### Traversing the file system

__Problem:__

You want to recursively read through a list of all of the files in a given directory location and display each file’s name or recursively traverse the file if it is a directory.

__Solution:__

```js
var fs = require('fs');
var traverseFileSystem = function(currentPath) {
    console.log(currentPath);
    var files = fs.readdirSync(currentPath);
    for (var i in files) {
        var currentFile = currentPath + '/' + files[i];
        var stats = fs.statSync(currentFile);
        if (stats.isFile()) {
            console.log(currentFile);
        } else if (stats.isDirectory()) {
            traverseFileSystem(currentFile);
        }
    }
};
traverseFileSystem('..');
```

### Watching a file for changes

__Problem:__

You want to be notified of any changes that occur within a given directory either to the directory’s contents or directory itself.

__Solution:__

This solution requires a special module called “inotify.” Assuming you have the node package manager installed, you can install inotify using: npm install inotify The code below must then reference the install path:

```js
var fs = require('fs');
var Inotify = require('inotify').Inotify;
var inotify = new Inotify();
var watcher = {
    path: '.',
    watch_for: Inotify.IN_OPEN | Inotify.IN_CLOSE,
    callback: function(event) {
        var file = event.name ? event.name : '';
        var mask = event.mask;
        if (file != '' && file.indexOf('.') !== 0) {
            if (mask & Inotify.IN_OPEN) {
                console.log(file + ' was opened ');
            } else if (mask & Inotify.IN_CLOSE) {
                console.log(file + ' was closed ');
            }
        }
    }
};
inotify.addWatch(watcher);
```

也可以使用 [mikeal/watch](https://github.com/mikeal/watch) 来监听文件.

### 下载文件

下载文件中关键的一步是将 Response 返回的数据流 pile 到本地文件的流：

```js
var request = requestProtocol.get(fileUrl, function (response) {
   if (response.statusCode !== 200) {
       request.abort();
       return;
   }

   var file = fs.createWriteStream(filePath);
   response.pipe(file);
});
```

## Reference

- [node.js 文件操作](http://www.cnblogs.com/rubylouvre/archive/2011/11/28/2264717.html)
- [Node.js学习(10) 文件系统fs](http://blog.csdn.net/gxhacx/article/details/12430969)
- [Network & IT Systems Monitoring](http://blog.monitis.com/2011/07/09/6-node-js-recipes-working-with-the-file-system/)

## Library

- [isaacs/node-glob](https://github.com/isaacs/node-glob) glob functionality for node.js.
- [substack/node-mkdirp](https://github.com/substack/node-mkdirp) Recursively mkdir, like `mkdir -p`, but in node.js.
- [dominictarr/through](https://github.com/dominictarr/through) simple way to create a ReadableWritable stream that works.

## Tutorial

- [11. File system - Mixu's Node book](http://book.mixu.net/node/ch11.html)
- [How to create a Web based File Browser using NodeJS, Express and JQuery Datatables](http://chawlasumit.wordpress.com/2014/08/04/how-to-create-a-web-based-file-browser-using-nodejs-express-and-jquery-datatables)
