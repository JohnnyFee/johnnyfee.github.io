layout: post
title: "ReactiveX"
description: ""
category: Android
tags: [rx, reactivex]
---

## [ReactiveX](http://reactivex.io/)

An API for asynchronous programming with observable streams./用观察流来实现异步编程的 API。

- 基于函数是编程。通过观察流避免回调地狱，避免错综复杂的状态维护。
- Less is more. 让复杂的代码缩减为几句代码。
- 异步错误处理。弥补 `try/catch` 在异步接口的错误处理中的不足。
- 让并发控制更简单。

目前实现的预研有：

1.  [RxJava](https://github.com/ReactiveX/RxJava)
2.  [RxJS](https://github.com/Reactive-Extensions/RxJS)
3.  [Rx.NET](https://github.com/Reactive-Extensions/Rx.NET)
4.  [RxScala](http://reactivex.io/rxscala)
5.  [RxClojure](https://github.com/ReactiveX/RxClojure)
6.  [RxSwift](https://github.com/ReactiveX/RxSwift)
7.  [Others](http://reactivex.io/languages.html)

## 什么是函数响应式编程

利用订阅模式，将异步操作从回调方式（回调地狱）转变成平行模式。From [什么是函数响应式编程](https://asce1885.gitbooks.io/android-rd-senior-advanced/content/#) by [What is Functional Reactive Programming?](https://www.bignerdranch.com/blog/what-is-functional-reactive-programming/)

Rx 处理步骤为构建 Observable 管道，变换数据流，使用 Scheduler 管理现成，处理数据。

## Docs

- [Introduction · ReactiveX文档中文翻译](https://mcxiaoke.gitbooks.io/rxdocs/content/) <sup>中文翻译</sup>


## RxBus

简化 Activity、Fragment、Service 等组件之间的交互，很大程度上降低了它们之间的耦合。

- [RxBus](http://wuxiaolong.me/2016/04/07/rxbus/)
- [RxBus—通过RxJava来替换EventBus](http://hanhailong.com/2015/10/09/RxBus%E2%80%94%E9%80%9A%E8%BF%87RxJava%E6%9D%A5%E6%9B%BF%E6%8D%A2EventBus/)
- [用RxJava实现事件总线(Event Bus)](http://www.jianshu.com/p/ca090f6e2fe2/)
- [用RxJava实现事件总线RxBus并实现同类型事件的区分](http://www.loongwind.com/archives/264.html)
- [Android事件驱动编程（二）](https://asce1885.gitbooks.io/android-rd-senior-advanced/content/androidshi_jian_qu_dong_bian_cheng_ff08_er_ff09.html)
- [事件总线 —— otto的bus和eventbus对比分析](http://frodoking.github.io/2015/03/30/android-eventbus-otto-analysis/)

## Mortar

[square/mortar: A simple library that makes it easy to pair thin views with dedicated controllers, isolated from most of the vagaries of the Activity life cycle.](https://github.com/square/mortar)

[Mortar](https://github.com/square/mortar)工作于Dagger之上，它具有两大优点：

* 它为被注入组件提供简单的生命周期回调。这使你可以编写在屏幕旋转时不会被销毁的presenters单例，而且可以保存状态到bundle中从而在进程死亡中存活下来。

* 它为你管理Dagger子图，并帮你把它绑定到activity的生命周期中。这让你有效的实现范围的概念：一个views生成的时候，它的presenter和依赖会作为子图创建；当views销毁的时候，你可以很容易的销毁这个范围，并让垃圾回收起作用。

See [我为什么主张反对使用Android Fragment](https://asce1885.gitbooks.io/android-rd-senior-advanced/content/wo_wei_shi_yao_zhu_zhang_fan_dui_shi_yong_android_fragment.html)

## RxAndroid

[ReactiveX/RxAndroid: RxJava bindings for Android](https://github.com/ReactiveX/RxAndroid)

## Library

* [rx-preferences](https://github.com/f2prateek/rx-preferences) -使SharedPreferences支持RxJava

* [RxAndroid](https://github.com/ReactiveX/RxAndroid) -RxJava的Android拓展

* [RxLifecycle](https://github.com/trello/RxLifecycle) -帮助使用了RxJava的安卓应用控制生命周期

* [RxBinding](https://github.com/JakeWharton/RxBinding) -安卓UI控件的RxJava绑定API

* [storio](https://github.com/pushtorefresh/storio) -支持RxJava的数据库

* [retrofit](https://github.com/square/retrofit) -支持RxJava的网络请求库

* [sqlbrite](https://github.com/square/sqlbrite) -支持RxJava的sqlite数据库

* [RxPermissions](https://github.com/tbruyelle/RxPermissions) -RxJava实现的Android运行时权限控制

* [reark](https://github.com/reark/reark) -RxJava architecture library for Android

* [frodo](https://github.com/android10/frodo) -Android Library for Logging RxJava Observables and Subscribers.
