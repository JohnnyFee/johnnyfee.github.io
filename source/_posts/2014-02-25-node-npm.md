layout: post
title: "Node NPM"
description: ""
category: Node
tags: [node]
--- 

npm 是 Node.js 的模块依赖管理工具。

## 大陆镜像

- <http://r.cnpmjs.org/>
- <http://registry.npm.taobao.org>
- <http://npm.cbyun.com>

官方默认镜像为： <http://registry.npmjs.org/>. 

<!--more-->

On Windows, npm can usually be found at `C:\Users\username\AppData\Roaming\npm `and on Unix at `/usr/local/share/npm`.

镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）: 

1.通过config命令 

    npm config set registry http://registry.cnpmjs.org 
    
    # 如果上面配置正确这个命令会有字符串response
    npm info underscore

2.命令行指定 

    npm --registry http://registry.cnpmjs.org info underscore 

3.编辑 ~/.npmrc 加入下面内容 

    registry = http://registry.cnpmjs.org

其中，第 1 个和第 3 个方法等效，都会永久修改，第 2 个为临时修改。

搜索镜像: [http://cnpmjs.org](http://cnpmjs.org/)

建立或使用镜像,参考: [https://github.com/fenmgk2/cnpmjs.org](https://github.com/fenmgk2/cnpmjs.org)

## package.json

npm命令运行时会读取当前目录的 package.json 文件和解释这个文件，这个文件基于 [Packages/1.1](http://wiki.commonjs.org/wiki/Packages/1.1) 规范。在这个文件里你可以定义：

- 应用名称( name )
- 应用描述( description )
- 关键字( keywords )
- 版本号( version )
- 应用的配置项( config )
- 主页( homepage )
- 作者( author )
- 资源仓库地址( repository )
- bug的提交地址( bugs )，授权方式( licenses )
- 目录( directories )
- 应用入口文件( main )
- 命令行文件( bin )
- 应用依赖模块( dependencies )
- 开发环境依赖模块( devDependencies )
- 运行引擎( engines )和脚本( scripts )等。

对于开发者而言，开发和发布模块都依赖于他对这个文件 package.json 所包含的意义的正确理解。我们下面用一个本文共用的例子来说明：

```json
{
    "name": "test",
    "version": "0.1.0",
    "description": "A testing package",
    "author": "A messed author <[messed@example.com](mailto:messed@example.com)>",
    "dependencies": {
        "express": "1.x.x",
        "ejs": "0.4.2",
        "redis": ">= 0.6.7"
    },
    "devDependencies": {
        "vows": "0.5.x"
    },
    "main": "index",
    "bin": {
        "test": "./bin/test.js"
    },
    "scripts": {
        "start": "node server.js",
        "test": "vows test/*.js",
        "preinstall": "./configure",
        "install": "make && make install"
    },
    "engines": {
        "node": "0.4.x"
    }
}
```

这个例子里我们定义了应用的入口文件( main )为 index ，当其他应用引用了我们的模块 require('test') 时，这个 main 的值 index.js 文件被调用。

脚本( scripts )使用 hash 表定义了几个不同的命令：

- script.start 里的定义的 node server.js 会在 `npm start `时被调用
- `npm test` 调用时对应的 scripts.test 里定义的命令被调用。

npm 使用于[语义化的版本识别](http://semver.org/)来进行版本管理。我们来看一下版本定义的字段：

0.4.2

* 主版本( 0 )
* 副版本( 4 )
* 补丁版本( 2 )

一个 `package.json` 的模板：[package.json: an interactive guide - browsenpm.org](http://browsenpm.org/package.json)

## npm install

安装模块只需要 `npm install express connect` 命令给我们带来了很大的方便。安装模块的路径分两种：

* 全局路径，也就是带上参数 `-g` 的安装模式。这个命令会把模块安装在 `$PREFIX/lib/node_modules` 下，可通过命令 `npm root -g` 查看全局模块的安装目录。 `package.json` 里定义的 bin 会安装到 `$PREFIX/bin` 目录下，如果模块带有 man page 会安装到 `$PREFIX/share/man` 目录下。
* 本地路径，不带 `-g` 参数的。从当前目录一直查找到根目录/下有没有 node_modules 目录，有模块安装到这个目录下的 node_modules 目录里，如果没有找到则把模块安装到当前目录 node_modules 目录下。package.json 定义的 bin 会安装到 `node_modules/.bin` 目录下，man page 则不会安装。

我们需要选择什么样的安装方式呢？全局模式可以让你不用担心找不到模块，如果不需要还是尽量避免全局模式。

* 如果我们只是 require('pkg') 一个模块，我们不需要使用全局模式。
* 如果我们需要在命令行中调用，我们需要使用全局模式。因为这个安装把 package.json里 bin 下的定义安装到 $PATH 目录下。

有些模块我们既需要在命令行中调用又想 require('pkg') ，比如 [Coffee-script](http://coffeescript.org/) 。那么我们可以使用全局模式安装，然后使用下一段要讲的命令 `npm link` 把它链接到本地的 node_modules 目录下。

不要担心 package.json 里 script 中定义的命令会不会因为不是全局安装而不能运行。比如在例子里定义的 devDependencies 的 vows 。在调用 npm test 时 npm 会把 node_modules/.bin 目录放到环境变量 $PATH 的最前面。

使用 `--save` 修改 package.json 中的 `dependencies`，表示生产环境的依赖；使用 `--save-dev` 修改 package.json 中的 `devDependencies`，表示开发环境的依赖。

在有些 native 模块需要编译的话，我们可以定义预编译和编译的命令。本例中还定义了应用依赖模块( dependencies )和开发环境依赖模块( devDependencies )。应用依赖模块会在安装时安装到当前模块的 node_modules 目录下。开发环境依赖模块主要时在开发环境中用到的依赖模块，用命令 npm 的命令 `install` 或 `link` 加上参数 --dev 安装到当前模块的 node_modules 目录下。

## npm update

使用 `npm update <package_name>` 更新目录模块，`npm update <package_name> -g` 更新全局模块。

如果要更新 npm 本身，在 windows 上，使用 `npm update npm -g` 可能不起作用。你可以使用手动下载 [Releases · npm/npm](https://github.com/npm/npm/releases)，然后覆盖 `nodejs 安装目录/node_modules/npm` 内容。

## npm init

`npm init` 命令，可以引导你完成创建 package.json 文件的过程。它可以聪明地为你设置默认值，比如通过上层目录的名称推断模块名，从 `~/.npmrc` 中读取创作者的信息，以及用你的 git 设置确定代码库。

    mkdir my-node-app
    cd my-node-app
    npm init

## npm scripts

See [task automation with npm run](http://substack.net/task_automation_with_npm_run)

### sequential sub-tasks

If you have 2 tasks you want to run in series, you can just npm run each task separated by a &&: 

    "build": "npm run build-js && npm run build-css"

### parallel sub-tasks

If you want to run some tasks in parallel, just use & as the separator!

    "watch": "npm run watch-js & npm run watch-css"

### when things get really complicated...

If you find yourself stuffing a lot of commands into a single scripts field entry, consider factoring some of those commands out into someplace like bin/.

You can write those scripts in bash or node or perl or whatever. Just put the proper #! line at the top of the file, chmod +x, and you're good to go:

```bash
#!/bin/bash
(cd site/main; browserify browser/main.js | uglifyjs -mc > static/bundle.js)
(cd site/xyz; browserify browser.js > static/bundle.js)

"build-js": "bin/build.sh"
```

## bin

注：以下操作均在 Windows 下进行。

npm 通过 package.json 中的 bin 字段来配置程序的可执行文件，如：

    "bin": {
        "browserify": "bin/cmd.js"
    }

如果生成的可执行文件的名称和 package name 相同，则可以简写为：

    "bin": "bin/cmd.js"

其中， _cmd.js_ 文件的第一行为：

```
    #!/usr/bin/env node
```

以上代表表示在环境变量下的 `node` 命令运行之后的代码。 

- 如果以全局的方式安装该模块，在 _`C:\Users\<username>\AppData\Roaming\npm\`_ 会生成 _browserify_ 和 _browserify.cmd_ 文件。该目录在安装 Node 时已被添加到了环境变量中。所以，在 CMD 下可直接使用 browserify 命令。`*nix` 系统下使用的是 _browserify_ 文件，Windows 下使用的是 _browserify.cmd_ 文件。

- 如果以正常方式安装该模块，_browserify_ 和 _browserify.cmd_ 生成在`./node_modules/.bin/`。

### shebang

[openshift - What does "#!/bin/env" mean (at the top of a node.js script)? - Stack Overflow](http://stackoverflow.com/questions/15061001/what-does-bin-env-mean-at-the-top-of-a-node-js-script)

The full line from your example is:

```
    #!/usr/bin/env node
```

This simply means that the script should be executed with the first executable named 'node' that's found in your current PATH.

The shebang (#!) at the start means execute the script with what follows. `/bin/env` is a standard unix program that looks at your current environment. Any argument to it not in a 'name=value' format is a command to execute. See your env manpage for further details.

## npm outdated 追踪过期的依赖项


`npm outdated` 能够找出程序的那些依赖项已经过期了：

    cd my-node-app
    npm outdated
    
    Package            Current  Wanted     Latest  Location
    -------            -------  ------     ------  --------
    express              3.4.8   3.4.8  4.0.0-rc2  express
    jade                 1.1.5   1.1.5      1.3.0  jade
    cors                 2.1.1   2.1.1      2.2.0  cors
    jade                0.26.3  0.26.3      1.3.0  mocha > jade
    diff                 1.0.7   1.0.7      1.0.8  mocha > diff
    glob                 3.2.3   3.2.3      3.2.9  mocha > glob
    commander            2.0.0   2.0.0      2.1.0  mocha > commander
    

如果你做的是开源的node程序或模块，可以看看[david-dm](https://david-dm.org/)，[NodeICO](https://nodei.co/)和[shields.io](http://shields.io/)，你可以用这三个优秀服务所提供的图片徽章在项目的README或网站上显示生动的依赖信息。

## es6

ES6，也就是被大众称为JavaScript的ECMAScript语言规范的下一版，其工作名称为Harmony。 Harmony给JavaScript带来了很多振奋人心的新特性，其中很多已经出现在较新版本的node中了。

Harmony实现了[很多新特性](https://github.com/lukehoban/es6features)，比如[块作用域](https://github.com/JustinDrake/node-es6-examples#block-scoping)、[生成器](https://github.com/JustinDrake/node-es6-examples#generators)、[代理](https://github.com/JustinDrake/node-es6-examples#proxies)、[弱映射](https://github.com/JustinDrake/node-es6-examples#weak-maps)等等。

要在你的node程序中启用harmony的特性，需要指定一个比较新的node引擎，比如0.11.x，并在启动脚本中设置--harmony选项：

    {
      "scripts": {
        "start": "node --harmony index.js"
      },
      "engines": {
        "node": "0.11.x"
      }
    }

## npm link

对开发者而言，这算是最有价值的命令。假设我们开发了一个模块叫 test ，然后我们在 test-example 里引用这个模块 ，每次 test 模块的变动我们都需要反映到 test-example 模块里。不要担心，有了 npm link 命令一切变的非常容易。

首先我们需要把 test 链接到全局模式下：

```sh
# 进入test模块目录
cd ~/work/node/test 

# 创建链接到$PREFIX/lib/node_modules
npm link 
```

那么 test 的模块将被链接到 `$PREFIX/lib/node_modules`。执行脚本 `bin/test.js` 被链接到 `/usr/local/bin/test` 上。

接下来我们需要把 test 引用到 test-example 项目中来：

```sh
# 进入test-example模块目录
cd ~/work/node/test-example 

# 把全局模式的模块链接到本地
npm link test 
```

`npm link test` 命令会去 `$PREFIX/lib/node_modules` 目录下查找名叫 `test` 的模块，找到这个模块后把 `$PREFIX/lib/node_modules/test` 的目录链接到 `~/work/node/test-example/node_modules/test` 这个目录上来。

现在任何 test 模块上的改动都会直接映射到 test-example 上来。再比如假设我们开发很多应用，每个应用都用到 Coffee-script ：

```sh
npm install coffee-script -g # 全局模式下安装coffee-script
cd ~/work/node/test # 进入开发目录
npm link coffee-script # 把全局模式的coffee-script模块链接到本地的node_modules下
cd ../test-example # 进入另外的一个开发目录
npm link coffee-script # 把全局模式的coffee-script模块链接到本地
npm update coffee-script -g # 更新全局模式的coffee-script，所有link过去的项目同时更新了。
```

就像你看到，`npm link` 对于开发时一个模块被多个模块引用时非常有用。windows 的用户会想，我这儿没有 UNIX 下的 link 工具怎么办？别担心只要你的 Node.js 支持 `fs.symlink` 就可用到这个特性。

## 其它 npm 命令

npm 命令里还有很多有用的命令。

```sh
- npm cache clean #清除 npm 缓存。
- npm explore . -- git pull origin master # 更新当前的 git 资源库。
- npm edit . # 编辑当前模块的所有依赖模块。
- npm docs coffee-script # 打开 coffee-script 模块的文档。
- npm repo express
- npm outdated coffee-script # 查看 coffee-script 是否有新版本。
- npm submodule . #你可以要求你的依赖模块是从 git 资源库安装的，而不是从 registry 安装。因为作者的 git 资源库总是最新的版本，registry 上的是模块作者发布上去的稳定版本。
```

## Publish

- [Publishing a simple package to npm › Evan Hahn (dot com)](http://evanhahn.com/make-an-npm-baby/)

## Tools

- [npm-check-updates](https://www.npmjs.org/package/npm-check-updates)
- [mirek/node-unused-deps](https://github.com/mirek/node-unused-deps)
 Report unused npm packages in nodejs project.
 
## FAQ

- [javascript - How do I update each dependency in package.json to the latest version? - Stack Overflow](http://stackoverflow.com/questions/16073603/how-do-i-update-each-dependency-in-package-json-to-the-latest-version)

## Reference

- [package.json](https://www.npmjs.org/doc/package.json.html)
- [如何使用NPM来管理你的Node.js依赖](http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence)
- [快乐Node码农的十个习惯](http://www.infoq.com/cn/articles/node.js-habits)
