---
layout: post
title: "Node NPM"
description: ""
category: Node
tags: [node]
--- 

npm 是 Node.js 的模块依赖管理工具。作为开发者使用的工具，主要解决开发 Node.js 时会遇到的问题。如同 RubyGems 对于 Ruby 开发者和 Maven 对于 Java 开发者的重要性，npm 对与 Node.js 的开发者和社区的重要性不言而喻。本文包括五点：package.json 、npm 的配置、npm install 命令、npm link 命令和其它 npm 命令。

## 大陆镜像

- http://r.cnpmjs.org/
- http://registry.npm.taobao.org
- http://npm.cbyun.com

<!--more-->

On Windows, npm can usually be found at `C:\Users\username\AppData\Roaming\npm `and on Unix at `/usr/local/share/npm`.

镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）: 

1.通过config命令 

    npm config set registry http://registry.cnpmjs.org 
    
    # 如果上面配置正确这个命令会有字符串response
    npm info underscore

2.命令行指定 

    npm --registry http://registry.cnpmjs.org info underscore 

3.编辑 ~/.npmrc 加入下面内容 

    registry = http://registry.cnpmjs.org

其中，第 1 个和第 3 个方法等效，都会永久修改，第 2 个为临时修改。

搜索镜像: [http://cnpmjs.org](http://cnpmjs.org/)

建立或使用镜像,参考: [https://github.com/fenmgk2/cnpmjs.org](https://github.com/fenmgk2/cnpmjs.org)

## package.json

npm命令运行时会读取当前目录的 package.json 文件和解释这个文件，这个文件基于 [Packages/1.1](http://wiki.commonjs.org/wiki/Packages/1.1) 规范。在这个文件里你可以定义你的应用名称( name )、应用描述( description )、关键字( keywords )、版本号( version )、应用的配置项( config )、主页( homepage )、作者( author )、资源仓库地址( repository )、bug的提交地址( bugs )，授权方式( licenses )、目录( directories )、应用入口文件( main )、命令行文件( bin )、应用依赖模块( dependencies )、开发环境依赖模块( devDependencies )、运行引擎( engines )和脚本( scripts )等。

对于开发者而言，开发和发布模块都依赖于他对这个文件 package.json 所包含的意义的正确理解。我们下面用一个本文共用的例子来说明：

    {
        "name": "test",
        "version": "0.1.0",
        "description": "A testing package",
        "author": "A messed author <[messed@example.com](mailto:messed@example.com)>",
        "dependencies": {
            "express": "1.x.x",
            "ejs": "0.4.2",
            "redis": ">= 0.6.7"
        },
        "devDependencies": {
            "vows": "0.5.x"
        },
        "main": "index",
        "bin": {
            "test": "./bin/test.js"
        },
        "scripts": {
            "start": "node server.js",
            "test": "vows test/*.js",
            "preinstall": "./configure",
            "install": "make && make install"
        },
        "engines": {
            "node": "0.4.x"
        }
    }

这个例子里我们定义了应用的入口文件( main )为 index ，当其他应用引用了我们的模块 require('test') 时，这个 main 的值 index.js 文件被调用。脚本( scripts )使用hash 表定义了几个不同的命令。script.start 里的定义的 node server.js 会在 npm start 时被调用，同样的 npm test 调用时对应的 scripts.test 里定义的命令被调用。在有些 native 模块需要编译的话，我们可以定义预编译和编译的命令。本例中还定义了应用依赖模块( dependencies )和开发环境依赖模块( devDependencies )。应用依赖模块会在安装时安装到当前模块的 node_modules 目录下。开发环境依赖模块主要时在开发环境中用到的依赖模块，用命令 npm 的命令 install 或 link 加上参数 —dev 安装到当前模块的 node_modules 目录下。

大家也注意到 package.json 里的版本号有些是 >= 0.6.7 有些是 1.x.x，这有什么区别？npm 使用于[语义化的版本识别](http://semver.org/)来进行版本管理。并不是所有的模块都会提供向后兼容性，有时候某些模块因为某些原因导致不向后兼容。所以我们需要定义一些规则来保证模块能够在某些特定的版本中可用，并且保证能用最新的版本，因为那些版本总是修改了一些 bug 或提升了性能等。我们来看一下版本定义的字段：

相关厂商内容

0.4.2

* 主版本( 0 )
* 副版本( 4 )
* 补丁版本( 2 )

在上面 package.json 的定义里我们确信模块在所有的 Nodejs 0.4及以上和0.5以下版本里都能运行。依赖模块 redis 在所有大于或等于0.6.7的版本上都能运行，依赖模块 ejs 只能确保运行在0.4.2版本里，依赖模块 express 确保能够兼容大于或等于1.0.0并且小于2.0.0。

## npm install命令

安装模块只需要 npm install express connect 命令给我们带来了很大的方便。安装模块的路径分两种：

* 全局路径，也就是带上参数 `-g` 的安装模式。这个命令会把模块安装在 $PREFIX/lib/node_modules 下，可通过命令 `npm root -g` 查看全局模块的安装目录。 package.json 里定义的bin会安装到 $PREFIX/bin 目录下，如果模块带有 man page 会安装到 $PREFIX/share/man 目录下。
* 本地路径，不带 -g 参数的。从当前目录一直查找到根目录/下有没有 node_modules 目录，有模块安装到这个目录下的 node_modules 目录里，如果没有找到则把模块安装到当前目录 node_modules 目录下。package.josn 定义的 bin 会安装到 node_modules/.bin 目录下，man page 则不会安装。

我们需要选择什么样的安装方式呢？全局模式可以让你不用担心找不到模块，如果不需要还是尽量避免全局模式。

* 如果我们只是 require('pkg') 一个模块，我们不需要使用全局模式。
* 如果我们需要在命令行中调用，我们需要使用全局模式。因为这个安装把 package.josn里 bin 下的定义安装到 $PATH 目录下。

有些模块我们既需要在命令行中调用又想 require('pkg') ，比如 [Coffee-script](http://coffeescript.org/) 。那么我们可以使用全局模式安装，然后使用下一段要讲的命令 npm link 把它链接到本地的 node_modules 目录下。

不要担心 package.josn 里 script 中定义的命令会不会因为不是全局安装而不能运行。比如在例子里定义的 devDependencies 的 vows 。在调用 npm test 时 npm 会把 node_modules/.bin 目录放到环境变量 $PATH 的最前面。

## 用npm init开始新项目

npm有个init命令，可以引导你完成创建package.json文件的过程。即便你非常熟悉package.json和它的属性，也可以把npm init当作将你的新程序或模块导入正轨的简便办法。 它可以聪明地为你设置默认值，比如通过上层目录的名称推断模块名，从~/.npmrc中读取创作者的信息，以及用你的git设置确定代码库。

    mkdir my-node-app
    cd my-node-app
    npm init
    

## 声明所有依赖项

在将模块安装到项目本地时坚持使用--save (或 --save-dev)是个好习惯。这些选项会将指定的模块添加到package.json的dependencies（或devDependencies）清单中，并使用合理的默认[semver范围](https://github.com/isaacs/node-semver#ranges)。

    npm install domready --save
    

注意，现在npm使用[插入符风格的semver范围](http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/)：


## scripts

参考： [task automation with npm run](http://substack.net/task_automation_with_npm_run)

### 指定启动脚本

在package.json中设定scripts.start，你就可以在命令行中用npm start启动程序了。这个非常方便，因为克隆了你的程序的其他node开发人员不用猜就能轻松运行它。

额外奖励：如果在package.json中定义了scripts.start，你就**不需要Procfile了**(Heroku平台用Procfile来声明在你程序的dynos上运行什么命令)。使用npm start会自动创建一个作为[web进程](https://github.com/heroku/heroku-buildpack-nodejs/blob/97a5856d3d4407e9fde82bac31cb308430e459f7/bin/compile#L122-L135)的Procfile。

这里有个启动脚本示例：

    "scripts": {
      "start": "node index.js"
    }
    

### 指定测试脚本

就像团队中的所有人都应该可以运行程序一样，他们也应该可以测试它。package.json中的scripts.test就是用来指定运行测试套件的脚本的。如果你用mocha之类的东西运行测试，一定要确保把它包含在package.json里的devDependencies中，并且指向安装在你项目本地的文件，而不是全局安装的mocha：

    "scripts": {
      "test": "mocha"
    }

### building javascript

I write my browser code with node-style commonjs module.exports and require() to organize my code and to use packages published to npm. [browserify](http://browserify.org/) can resolve all the require() calls statically as a build step to create a single concatenated bundle file you can load with a single script tag. To use browserify I can just have a scripts['build-js'] entry in package.json that looks like:

    "build-js": "browserify browser/main.js > static/bundle.js"

If I want my javascript build step for production to also do minification, I can just add uglify-js as a devDependency and insert it straight into the pipeline:

    "build-js": "browserify browser/main.js | uglifyjs -mc > static/bundle.js"

### watching javascript

To recompile my browser javascript automatically whenever I change a file, I can just substitude the browserify command for [watchify](https://npmjs.org/package/watchify) and add -d and -v for debugging and more verbose output:

    "watch-js": "watchify browser/main.js -o static/bundle.js -dv"

### building css

I find that cat is usually adequate so I just have a script that looks something like:

    "build-css": "cat static/pages/*.css tabs/*/*.css > static/bundle.css"

### watching css

Similarly to my watchify build, I can recompile css as it changes by substituting cat with [catw](https://npmjs.org/package/catw):

    "watch-css": "catw static/pages/*.css tabs/*/*.css -o static/bundle.css -v"

### sequential sub-tasks

If you have 2 tasks you want to run in series, you can just npm run each task separated by a &&: 

    "build": "npm run build-js && npm run build-css"

### parallel sub-tasks

If you want to run some tasks in parallel, just use & as the separator!

    "watch": "npm run watch-js & npm run watch-css"

### the complete package.json

Altogether, the package.json I've just described might look like:

    {
      "name": "my-silly-app",
      "version": "1.2.3",
      "private": true,
      "dependencies": {
        "browserify": "~2.35.2",
        "uglifyjs": "~2.3.6"
      },
      "devDependencies": {
        "watchify": "~0.1.0",
        "catw": "~0.0.1",
        "tap": "~0.4.4"
      },
      "scripts": {
        "build-js": "browserify browser/main.js | uglifyjs -mc > static/bundle.js",
        "build-css": "cat static/pages/*.css tabs/*/*.css",
        "build": "npm run build-js && npm run build-css",
        "watch-js": "watchify browser/main.js -o static/bundle.js -dv",
        "watch-css": "catw static/pages/*.css tabs/*/*.css -o static/bundle.css -v",
        "watch": "npm run watch-js & npm run watch-css",
        "start": "node server.js",
        "test": "tap test/*.js"
      }
    }

If I want to build for production I can just do npm run build and for local development I can just do npm run watch!

You can extend this basic approach however you like! For instance you might want to run the build step before running start, so you could just do:

    "start": "npm run build && node server.js"

or perhaps you want an npm run start-dev command that also starts the watchers:

    "start-dev": "npm run watch & npm start"

You can reorganize the pieces however you want!

### when things get really complicated...

If you find yourself stuffing a lot of commands into a single scripts field entry, consider factoring some of those commands out into someplace like bin/.

You can write those scripts in bash or node or perl or whatever. Just put the proper #! line at the top of the file, chmod +x, and you're good to go:

    #!/bin/bash
    (cd site/main; browserify browser/main.js | uglifyjs -mc > static/bundle.js)
    (cd site/xyz; browserify browser.js > static/bundle.js)

    "build-js": "bin/build.sh"


## bin

注：以下操作均在 Windows 下进行。

npm 通过 package.json 中的 bin 字段来配置程序的可执行文件，如：

    "bin": {
        "browserify": "bin/cmd.js"
    }

如果生成的可执行文件的名称和 package name 相同，则可以简写为：

    "bin": "bin/cmd.js"

其中， _cmd.js_ 文件的第一行为：

```
    #!/usr/bin/env node
```

以上代表表示在环境变量下的 `node` 命令运行之后的代码。 

- 如果以全局的方式安装该模块，在 _`C:\Users\<username>\AppData\Roaming\npm\`_ 会生成 _browserify_ 和 _browserify.cmd_ 文件。该目录在安装 Node 时已被添加到了环境变量中。所以，在 CMD 下可直接使用 browserify 命令。`*nix` 系统下使用的是 _browserify_ 文件，Windows 下使用的是 _browserify.cmd_ 文件。

- 如果以正常方式安装该模块，_browserify_ 和 _browserify.cmd_ 生成在`./node_modules/.bin/`。

### shebang

[openshift - What does "#!/bin/env" mean (at the top of a node.js script)? - Stack Overflow](http://stackoverflow.com/questions/15061001/what-does-bin-env-mean-at-the-top-of-a-node-js-script)

The full line from your example is:

```
    #!/usr/bin/env node
```

This simply means that the script should be executed with the first executable named 'node' that's found in your current PATH.

The shebang (#!) at the start means execute the script with what follows. `/bin/env` is a standard unix program that looks at your current environment. Any argument to it not in a 'name=value' format is a command to execute. See your env manpage for further details.

## 用环境变量配置npm

以下内容摘自[npm配置](https://npmjs.org/doc/misc/npm-config.html)：

> 所有以npm_config_开头的环境变量都会被解释为配置参数。比如说环境中有npm_config_foo=bar时，会将配置参数foo设置为bar。任何没有给出值的环境配置的值都会设置为true。配置值对大小写不敏感，所以NPM_CONFIG_FOO=bar也一样。

最近在所有的Heroku构建中都有程序的环境。这一变化让Heroku上的node用户无需修改程序代码就可以控制他们的npm配置。习惯#7是这一方式的完美例证。

## 追踪过期的依赖项

如果你编程的时间足够长，可能已经领教过[相依性地狱](http://zh.wikipedia.org/wiki/%E7%9B%B8%E4%BE%9D%E6%80%A7%E5%9C%B0%E7%8B%B1)的厉害了。好在Node.js和npm接纳了semver，即 [语义化版本管理规范](http://semver.org/) ，设置了一个健全的依赖项管理先例。在这个方案下，版本号和它们的变化方式传达的含义涉及到了底层代码，以及从一个版本到下一版本修改了什么。

npm有一个很少有人知道的命令，outdated。它可以跟npm update结合使用，能够找出程序的那些依赖项已经过期了，需要更新：

    cd my-node-app
    npm outdated
    
    Package            Current  Wanted     Latest  Location
    -------            -------  ------     ------  --------
    express              3.4.8   3.4.8  4.0.0-rc2  express
    jade                 1.1.5   1.1.5      1.3.0  jade
    cors                 2.1.1   2.1.1      2.2.0  cors
    jade                0.26.3  0.26.3      1.3.0  mocha > jade
    diff                 1.0.7   1.0.7      1.0.8  mocha > diff
    glob                 3.2.3   3.2.3      3.2.9  mocha > glob
    commander            2.0.0   2.0.0      2.1.0  mocha > commander
    

如果你做的是开源的node程序或模块，可以看看[david-dm](https://david-dm.org/)，[NodeICO](https://nodei.co/)和[shields.io](http://shields.io/)，你可以用这三个优秀服务所提供的图片徽章在项目的README或网站上显示生动的依赖信息。

## es6

ES6，也就是被大众称为JavaScript的ECMAScript语言规范的下一版，其工作名称为Harmony。 Harmony给JavaScript带来了很多振奋人心的新特性，其中很多已经出现在较新版本的node中了。

Harmony实现了[很多新特性](https://github.com/lukehoban/es6features)，比如[块作用域](https://github.com/JustinDrake/node-es6-examples#block-scoping)、[生成器](https://github.com/JustinDrake/node-es6-examples#generators)、[代理](https://github.com/JustinDrake/node-es6-examples#proxies)、[弱映射](https://github.com/JustinDrake/node-es6-examples#weak-maps)等等。

要在你的node程序中启用harmony的特性，需要指定一个比较新的node引擎，比如0.11.x，并在启动脚本中设置--harmony选项：

    {
      "scripts": {
        "start": "node --harmony index.js"
      },
      "engines": {
        "node": "0.11.x"
      }
    }

## npm link命令

对开发者而言，这算是最有价值的命令。假设我们开发了一个模块叫 test ，然后我们在 test-example 里引用这个模块 ，每次 test 模块的变动我们都需要反映到 test-example 模块里。不要担心，有了 npm link 命令一切变的非常容易。

首先我们需要把 test 链接到全局模式下：

    cd ~/work/node/test # 进入test模块目录
    npm link # 创建链接到$PREFIX/lib/node_modules

那么 test 的模块将被链接到 $PREFIX/lib/node_modules 下，就像我的机器上 $PREFIX 指到 /usr/local ，那么 /usr/local/lib/node_modules/test 将会链接到 ~/work/node/test 下。执行脚本 bin/test.js 被链接到 /usr/local/bin/test 上。

接下来我们需要把 test 引用到 test-example 项目中来：

    cd ~/work/node/test-example # 进入test-example模块目录
    npm link test # 把全局模式的模块链接到本地

npm link test 命令会去 $PREFIX/lib/node_modules 目录下查找名叫 test 的模块，找到这个模块后把 $PREFIX/lib/node_modules/test 的目录链接到 ~/work/node/test-example/node_modules/test 这个目录上来。

现在任何 test 模块上的改动都会直接映射到 test-example 上来。再比如假设我们开发很多应用，每个应用都用到 Coffee-script ：

    npm install coffee-script -g # 全局模式下安装coffee-script
    cd ~/work/node/test # 进入开发目录
    npm link coffee-script # 把全局模式的coffee-script模块链接到本地的node_modules下
    cd ../test-example # 进入另外的一个开发目录
    npm link coffee-script # 把全局模式的coffee-script模块链接到本地
    npm update coffee-script -g # 更新全局模式的coffee-script，所有link过去的项目同时更新了。

就像你看到，npm link 对于开发时一个模块被多个模块引用时非常有用。windows 的用户会想，我这儿没有 UNIX 下的 link 工具怎么办？别担心只要你的 Node.js 支持 fs.symlink 就可用到这个特性。

## 其它 npm 命令

npm 命令里还有很多有用的命令。npm explore . -- git pull origin master ，更新当前的 git 资源库。npm edit . ，编辑当前模块的所有依赖模块。npm docs coffee-script ，打开 coffee-script 模块的文档。npm outdated coffee-script ，查看 coffee-script 是否有新版本。npm submodule . ，你可以要求你的依赖模块是从 git 资源库安装的，而不是从 registry 安装。因为作者的 git 资源库总是最新的版本，registry 上的是模块作者发布上去的稳定版本。甚至你可以用 npm 来编程。

    var npm = require('npm');
    npm.load({}, function (err) {
        if (err) return commandFailed(err);
        npm.on("log", function (message) {
            if (arg) console.log(message)
        })
        var requirements = JSON.parse(fs.readFileSync('config/requirements.json'));
        npm.commands.install(requirements, function (err, data) {
            if (err) return commandFailed(err);
        });
    });

做为 Node.js 的开发者工具，npm 已经为我们想到很多的应用场景。这也是 Node.js 社区一致推荐它为开发者模块依赖管理工具。

## Publish

- [Publishing a simple package to npm › Evan Hahn (dot com)](http://evanhahn.com/make-an-npm-baby/)

## Tools

- [mehdishojaei/grunt-amdcheck](https://github.com/mehdishojaei/grunt-amdcheck) Finds and removes unused dependencies in AMD modules. <https://npmjs.org/package/grunt-amdcheck>

## Tutorial

- [Introduction to npm](http://flippinawesome.org/2014/03/31/introduction-to-npm/)
- [The Tapir's Tale: Running Scripts with npm](http://anders.janmyr.com/2014/03/running-scripts-with-npm.html)
- [Introduction to npm](http://smalljs.org/package-managers/npm/)
- [Publishing a simple package to npm › Evan Hahn (dot com)](http://evanhahn.com/make-an-npm-baby/)

## Reference

- [package.json](https://www.npmjs.org/doc/package.json.html)
- [如何使用NPM来管理你的Node.js依赖](http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence)
- [快乐Node码农的十个习惯](http://www.infoq.com/cn/articles/node.js-habits)
