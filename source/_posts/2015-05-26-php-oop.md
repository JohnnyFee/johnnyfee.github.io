layout: post
title: "PHP OOP"
description: ""
category: PHP
tags: [php, tutorial]
---

## Including and Requiring Files

As you progress in your use of PHP programming, you are likely to start building a library of functions that you think you will need again. You’ll also probably start using libraries created by other programmers.There’s no need to copy and paste these functions into your code. You can save them in separate files and use commands to pull them in. There are two types of command to perform this action: `include` and `require`.

Using `include`, you can tell PHP to fetch a particular file and load all its contents. 

```php
<?php
  include "library.php";

  // Your code goes here
?>
```

Each time you issue the `include` directive, it includes the requested file again, even if you’ve already inserted it. For instance, suppose that _library.php_ contains a lot of useful functions, so you include it in your file, but also include another library that includes _library.php_. Through nesting, you’ve inadvertently included _library.php_ twice. This will produce error messages, because you’re trying to define the same constant or function multiple times. So you should use `include_once` instead. 

```php
<?php
  include_once "library.php";

  // Your code goes here
?>
```

Then, whenever another `include` or `include_once` is encountered, if it has already been executed, it will be completely ignored. To determine whether the file has already been executed, the absolute file path is matched after all relative paths are resolved and the file is found in your `include` path.

In general, it’s probably best to stick with `include_once` and ignore the basic `include` statement. That way, you will never have the problem of files being included multiple times.

A potential problem with `include` and `include_once` is that PHP will only _attempt_ to include the requested file. Program execution continues even if the file is not found.

When it is absolutely essential to include a file, `require` it. For the same reasons I gave for using `include_once`, I recommend that you generally stick with `require_once` whenever you need to `require` a file:

```php
<?php
  require_once "library.php";

  // Your code goes here
?>
```

## PHP Version Compatibility

PHP is in an ongoing process of development, and there are multiple versions. If you need to check whether a particular function is available to your code, you can use the `function_exists` function, which checks all predefined and user-created functions.

```php
<?php
  if (function_exists("array_combine"))
  {
    echo "Function exists";
  }
  else
  {
    echo "Function does not exist - better write our own";
  }
?>
```

Using code such as this, you can take advantage of features in newer versions of PHP and yet still have your code run on earlier versions, as long as you replicate any features that are missing. Your functions may be slower than the built-in ones, but at least your code will be much more portable.

You can also use the `phpversion` function to determine which version of PHP your code is running on. The returned result will be similar to the following, depending on the version:

    **5.5.11**

## Declaring a Class

```php
<?php
  $object = new User;
  print_r($object);

  class User
  {
    public $name, $password;

    function save_user()
    {
      echo "Save User code goes here";
    }
  }
?>
```

Here I have also used an invaluable function called `print_r`. It asks PHP to display information about a variable in human-readable form. The `_r` stands for _in human-readable format_. In the case of the new object `$object`, it prints the following:

```
User Object
(
  [name]     =>
  [password] =>
)
```

However, a browser compresses all the whitespace, so the output in a browser is slightly harder to read:

    User Object ( [name] => [password] => )

In any case, the output says that `$object` is a user-defined object that has the properties `name` and `password`.

## Creating an Object

To create an object with a specified class, use the `new` keyword, like this: `object = new Class`. Here are a couple of ways in which we could do this:

```php
<?php
    $object = new User;
    $temp   = new User('name', 'password');
?>
```

## Accessing Objects

```php
<?php
  $object = new User;
  print_r($object); echo "<br>";

  $object->name     = "Joe";
  $object->password = "mypass";
  print_r($object); 
?>
```

You should note that the example `property` and `method` do not have `$` signs in front of them. If you were to preface them with `$` signs, the code would not work, as it would try to reference the value inside a variable. For example, the expression `$object->$property` would attempt to look up the value assigned to a variable named `$property` (let’s say that value is the string `brown`) and then attempt to reference the property `$object->brown`. If `$property` is undefined, an attempt to reference `$object->NULL` would occur and cause an error.

You can place functions and class definitions anywhere in your code, before or after statements that use them. Generally, though, it is considered good practice to place them toward the end of a file.

## Cloning Objects

Once you have created an object, it is passed by reference when you pass it as a parameter. To avoid this confusion, you can use the clone operator, which creates a new instance of the class and copies the property values from the original instance to the new instance.

```php
<?php
  $object1       = new User();
  $object1->name = "Alice";
  $object2       = clone $object1;
  $object2->name = "Amy";

  echo "object1 name = " . $object1->name . "<br>";
  echo "object2 name = " . $object2->name;

  class User
  {
    public $name;
  }
?>
```

## Constructors

When creating a new object, you can pass a list of arguments to the class being called. These are passed to a special method within the class, called the _constructor_, which initializes various properties.

```php
<?php
  class User
  {
    function User($param1, $param2)
    {
      // Constructor statements go here
      public $username = "Guest";
    }
  }
?>
```

However, PHP 5 provides a more logical approach to naming the constructor, which is to use the function name `__construct` (that is, `construct` preceded by two underscore characters):

```
<?php
  class User
  {
    function __construct($param1, $param2)
    {
      // Constructor statements go here
      public $username = "Guest";
    }
  }
?>
```

## PHP 5 Destructors

Also new in PHP 5 is the ability to create _destructor_ methods. This ability is useful when code has made the last reference to an object or when a script reaches the end.

```
<?php
  class User
  {
    function __destruct()
    {
      // Destructor code goes here
    }
  }
?>
```

## Writing Methods

declaring a method is similar to declaring a function, but there are a few differences. For example, method names beginning with a double underscore (`__`) are reserved, and you should not create any of this form.

You also have access to a special variable called `$this`, which can be used to access the current object’s properties.

```
<?php
  class User
  {
    public $name, $password;

    function get_password()
    {
      return $this->password;
    }
  }
?>
```

Note how the preceding `$` of the property `$password` is omitted when we use the `->` operator.

## Static Properties and Methods in PHP 5

If you are using PHP 5, you can also define a method as _static_, which means that it is called on a class, not on an object. A static method has no access to any object properties.

```php
<?php
  User::pwd_string();

  class User
  {
    static $static_property = "I'm static";

    static function pwd_string()
    {
      echo "Please enter your password";
    }

    function get_sp()
    {
       return self::$static_property;
    }
  }
?>
```

Note how we call the class itself, along with the static method, using a double colon (also known as the _scope resolution_ operator), not `->`.

Note how the method `get_sp` accesses `$static_property` using the keyword `self`. This is how a static property or constant can be directly accessed within a class.

## Declaring Properties

It is not necessary to explicitly declare properties within classes, as they can be implicitly defined when first used.

```
<?php
  $object1       = new User();
  $object1->name = "Alice";

  echo $object1->name;

  class User {}
?>
```

It is not necessary to explicitly declare properties within classes, as they can be implicitly defined when first used. 

```
<?php
  $object1       = new User();
  $object1->name = "Alice";

  echo $object1->name;

  class User {}
?>
```

But this kind of programming can lead to bugs that are infuriatingly difficult to discover, because `name` was declared from outside the class.

Also, when you declare a property within a class, you may assign a default value to it. The value you use must be a constant and not the result of a function or expression.

```
<?php
  class Test
  {
    public $name  = "Paul Smith"; // Valid
    public $age   = 42;           // Valid
    public $time  = time();       // Invalid - calls a function
    public $score = $level * 2;   // Invalid - uses an expression
  }
?>
```

## Declaring Constants

In the same way that you can create a global constant with the define function, you can define constants inside classes. The generally accepted practice is to use uppercase letters to make them stand out.

```
<?php
  Translate::lookup();

  class Translate
  {
    const ENGLISH = 0;
    const SPANISH = 1;
    const FRENCH  = 2;
    const GERMAN  = 3;
    // ...

    static function lookup()
    {
      echo self::SPANISH;
    }
  }
?>
```

You can reference constants directly, using the `self` keyword and double colon operator.

## Property and Method Scope in PHP 5

PHP 5 provides three keywords for controlling the scope of properties and methods:

- public

    These properties are the default when you are declaring a variable using the `var` or `public` keywords, or when a variable is implicitly declared the first time it is used. The keywords `var` and `public` are interchangeable because, although deprecated, `var` is retained for compatibility with previous versions of PHP. Methods are assumed to be `public` by default. 

- protected

    These properties and methods (_members_) can be referenced only by the object’s class methods and those of any subclasses.

- private

    These members can be referenced only by methods within the same class—not by subclasses.

Here’s how to decide which you need to use:

* Use `public` when outside code _should_ access this member and extending classes _should_ also inherit it.

* Use `protected` when outside code _should not_ access this member but extending classes _should_ inherit it.

* Use `private` when outside code _should not_ access this member and extending classes also _should not_ inherit it.

```
<?php
  class Example
  {
    var $name   = "Michael"; // Same as public but deprecated
    public $age = 23;        // Public property
    protected $usercount;    // Protected property

    private function admin() // Private method
    {
      // Admin code goes here
    }
  }
?>
```

## Inheritance

```php
<?php
  $object           = new Subscriber;
  $object->name     = "Fred";
  $object->password = "pword";
  $object->phone    = "012 345 6789";
  $object->email    = "fred@bloggs.com";
  $object->display();

  class User
  {
    public $name, $password;

    function save_user()
    {
      echo "Save User code goes here";
    }
  }

  class Subscriber extends User
  {
    public $phone, $email;

    function display()
    {
      echo "Name:  " . $this->name     . "<br>";
      echo "Pass:  " . $this->password . "<br>";
      echo "Phone: " . $this->phone    . "<br>";
      echo "Email: " . $this->email;
    }
  }
?>
```

### The parent operator

If you write a method in a subclass with the same name as one in its parent class, its statements will override those of the parent class. Sometimes this is not the behavior you want, and you need to access the parent’s method. To do this, you can use the `parent` operator:

```php
<?php
  $object = new Son;
  $object->test();
  $object->test2();

  class Dad
  {
    function test()
    {
      echo "[Class Dad] I am your Father<br>";
    }
  }

  class Son extends Dad
  {
    function test()
    {
      echo "[Class Son] I am Luke<br>";
    }

    function test2()
    {
      parent::test();
    }
  }
?>
```

If you wish to ensure that your code calls a method from the current class, you can use the `self` keyword, like this:

    self::method();

### Subclass constructors

When you extend a class and declare your own constructor, you should be aware that PHP will not automatically call the constructor method of the parent class. If you want to be certain that all initialization code is executed, subclasses should always call the parent constructors.

```php
<?php
  $object = new Tiger();

  echo "Tigers have...<br>";
  echo "Fur: " . $object->fur . "<br>";
  echo "Stripes: " . $object->stripes;

  class Wildcat
  {
    public $fur; // Wildcats have fur

    function __construct()
    {
      $this->fur = "TRUE";
    }
  }

  class Tiger extends Wildcat
  {
    public $stripes; // Tigers have stripes

    function __construct()
    {
      parent::__construct(); // Call parent constructor first
      $this->stripes = "TRUE";
    }
  }
?>
```

### Final methods

When you wish to prevent a subclass from overriding a superclass method, you can use the `final` keyword.

```
<?php
  class User
  {
    final function copyright()
    {
      echo "This class was written by Joe Smith";
    }
  }
?>
```

