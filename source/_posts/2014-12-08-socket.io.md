---
layout: post
title: "Socket.io Tutorial"
category: Node
tags: [node, socket.io]
---

[Automattic/socket.io](https://github.com/Automattic/socket.io/) 是一个用于构建实时应用的框架。See also [Socket.IO](http://socket.io/)。

## Quick Start

See [Socket.IO — Docs](http://socket.io/docs/)

```shell
# Installing
npm install socket.io
```

有四种方法建立 socket.io 服务器：

```js
// Server (app.js)

// 1. Using with Node http server
var app = require('http').createServer(handler)
var io = require('socket.io')(app);
var fs = require('fs');
app.listen(80);

// 2. Using with Express 3/4
var app = require('express')();
var server = require('http').Server(app);
var io = require('socket.io')(server);
server.listen(80);

// 3. Using with the Express framework
var app = require('express').createServer();
var io = require('socket.io')(app);
app.listen(80);

// 4. 单独使用
var io = require('socket.io')();
io.listen(80);

// 5. In conjunction with Koa
var app = require('koa')();
var server = require('http').createServer(app.callback());
var io = require('socket.io')(server);
io.on('connection', function(){ /* … */ });
server.listen(80);

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

io.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});
```

可以使用以下两种方法在客户端连接浏览器：

```html
<script src="/socket.io/socket.io.js"></script>
<script>
  // 1. 使用 io 函数
  var socket = io('http://localhost');

  // 2. 使用 io.connect 函数
  var socket = io.connect('http://localhost');
  
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
</script>
```

See: [Socket.IO Chat Example](http://chat.socket.io/) The source code is [socket.io/examples/chat at master · Automattic/socket.io](https://github.com/Automattic/socket.io/tree/master/examples/chat).

## 连接/断开事件

```js
io.sockets.on('connection', function (socket) {
  io.sockets.emit('this', { will: 'be received by everyone'});
  
  socket.on('private message', function (from, msg) {
    console.log('I received a private message by ', from, ' saying ', msg);
  });

  socket.on('disconnect', function () {
    io.sockets.emit('user disconnected');
  });
});
```

回调函数的socket参数为一个`client`与服务器的连接标识，不同的`client`会有不同的连接标识。

## 发送消息

除了 socket.io 提供的默认事件（如：`connect`, `message`, `disconnect`）外，我们还可以发送以及接收自定义事件。

至少有以下 6 种发送消息的方法：

```js
// 1. 发送到当前请求的 socket 客户端
socket.emit('message', "this is a test");

// 2. 发动到除了发送者外的所有客户端
socket.broadcast.emit('message', "this is a test");

// 3. 发动到 'game' 房间（频道）除了发送者外的所有客户端
socket.broadcast.to('game').emit('message', 'nice game');

// 4. 发送到所有客户端，包括发送者。
// 此方法可以简写为 io.emit('eventname', 'eventdata');
// Neat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, 
// but not clients in other namespaces.
io.sockets.emit('message', "this is a test");

// 5. 发动到 'game' 房间（频道）所有客户端，包括发送者。
io.sockets.in('game').emit('message', 'cool game');

// 6. 发动到特定的 socketid。
io.sockets.socket(socketid).emit('message', 'for your eyes only');
```

Sometimes, you might want to get a callback when the client confirmed the message reception.

To do this, simply pass a function as the last parameter of `.send` or `.emit`. What’s more, when you use `.emit`, the acknowledgement is done by you, which means you can also pass data along:

```js
// Server

var io = require('socket.io').listen(80);
io.sockets.on('connection', function (socket) {
  socket.on('ferret', function (name, fn) {
    fn('woot');
  });
});
```

```html
<!-- Client -->

<script>
  // TIP: io() with no args does auto-discovery
  var socket = io(); 
  socket.on('connect', function () { 
  // TIP: you can avoid listening on `connect` and listen on events directly too!
    socket.emit('ferret', 'tobi', function (data) {
      console.log(data); // data will be 'woot'
    });
  });
</script>
```

To broadcast, simply add a `broadcast` flag to `emit` and `send` method calls. Broadcasting means sending a message to everyone else except for the socket that starts it:

```js
// Server

var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.broadcast.emit('user connected');
});
```

If you just want the WebSocket semantics, you can do that too. Simply leverage `send` and listen on the `message` event:

```js
// Server (app.js)

var io = require('socket.io').listen(80);

io.sockets.on('connection', function (socket) {
  socket.on('message', function () { });
  socket.on('disconnect', function () { });
});
```

```html
<!-- Client (index.html) -->
<script>
  var socket = io('http://localhost/');
  socket.on('connect', function () {
    socket.send('hi');

    socket.on('message', function (msg) {
      // my msg
    });
  });
</script>
```

## 存储数据

在一个会话周期中，我们大部分情况下都需要存储当前会话者的一些数据，来识别或者特定情形下获取这些数据。

```js
var io = require('socket.io').listen(80);
io.sockets.on('connection', function (socket) {
  socket.on('set nickname', function (name) {
    // 将数据关联并存储到当前连接的 socket 上
    socket.set('nickname', name, function () {
      socket.emit('ready');
    });
  });
  socket.on('msg', function () {
    socket.get('nickname', function (err, name) {
      console.log('Chat message by ', name);
    });
  });
});
```

## 命名空间

See [Socket.IO — Rooms and Namespaces](http://socket.io/docs/rooms-and-namespaces/)

Socket.IO allows you to “namespace” your sockets, which essentially means assigning different endpoints or paths.

This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels.

```js
// Server

var io = require('socket.io').listen(80);
var chat = io
  .of('/chat')
  .on('connection', function (socket) {
    socket.emit('a message', {
        that: 'only'
      , '/chat': 'will get'
    });
    chat.emit('a message', {
        everyone: 'in'
      , '/chat': 'will get'
    });
  });

var news = io
  .of('/news')
  .on('connection', function (socket) {
    socket.emit('item', { news: 'item' });
  });
```

当客户端连接 /chat 时，由 chat 来处理，连接 /news 由 news 来处理。

```html
<script>
  var chat = io.connect('http://localhost/chat')
    , news = io.connect('http://localhost/news');
  chat.on('connect', function () {
    chat.emit('hi!');
  });
  news.on('news', function () {
    news.emit('woot');
  });
</script>
```

We call the default namespace `/` and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.

This namespace is identified by `io.sockets` or simply `io`:

```js
// the following two will emit to all the sockets connected to `/`
io.sockets.emit('hi', 'everyone');
io.emit('hi', 'everyone'); // short form
```

Each namespace emits a `connection` event that receives each `Socket` instance as a parameter

```
io.on('connection', function(socket){
  socket.on('disconnect', function(){ });
});
```

To set up a custom namespace, you can call the `of` function on the server-side:

```
var nsp = io.of('/my-namespace');
nsp.on('connection', function(socket){
  console.log('someone connected'):
});
nsp.emit('hi', 'everyone!');
```

On the client side, you tell Socket.IO client to connect to that namespace:

```
var socket = io('/my-namespace');
```

**Important note:** The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to `/socket.io/…`.

## Rooms

See [Socket.IO — Rooms and Namespaces](http://socket.io/docs/rooms-and-namespaces/#rooms)

Within each namespace, you can also define arbitrary channels that sockets can `join` and `leave`.

### Joining and leaving

You can call `join` to subscribe the socket to a given channel:

```
io.on('connection', function(socket){
  socket.join('some room');
});
```

And then simply use `to` or `in` (they are the same) when broadcasting or emitting:

```
io.to('some room').emit('some event'):
```

To leave a channel you call `leave` in the same fashion as `join`.

### Default room

Each `Socket` in Socket.IO is identified by a random, unguessable, unique identifier `Socket#id`. For your convenience, each socket automatically joins a room identified by this id.

This makes it easy to broadcast messages to other sockets:

```
io.on('connection', function(socket){
  socket.on('say to someone', function(id, msg){
    socket.broadcast.to(id).emit('my message', msg);
  });
});
```

### Disconnection

Upon disconnection, sockets `leave` all the channels they were part of automatically, and no specially teardown is needed on your part.

### Sending messages from the outside-world

In some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.

There’s several ways to tackle this problem, like implementing your own channel to send messages into the process.

To facilitate this use case, we created two modules:

* [socket.io-redis](http://github.com/automattic/socket.io-redis)
* [socket.io-emitter](http://github.com/automattic/socket.io-emitter)

By implementing the Redis `Adapter`:

```
var io = require('socket.io')(3000);
var redis = require('socket.io-redis');
io.adapter(redis({ host: 'localhost', port: 6379 }));
```

you can then `emit` messages from any other process to any channel

```
var io = require('socket.io-emitter')();
setInterval(function(){
  io.emit('time', new Date);
}, 5000);
```

## 发送易变（volatile）的数据

Sometimes certain messages can be dropped. Let’s say you have an app that shows realtime tweets for the keyword `bieber`.

If a certain client is not ready to receive messages (because of network slowness or other issues, or because he’s connected through long polling and is in the middle of a request-response cycle), if he doesn’t receive ALL the tweets related to bieber your application won’t suffer.

In that case, you might want to send those messages as volatile messages.

volatile 意思大概是说，当服务器发送数据时，客户端因为各种原因不能正常接收，比如网络问题、或者正处于长连接的建立连接阶段。此时会让我们的应用变得suffer，那就需要考虑发送 volatile 数据。即使客户端没连线，一样可以这样发送，服务器会自动丢弃发送失败的数据。

```js
var io = require('socket.io').listen(80);
io.sockets.on('connection', function (socket) {
  var tweets = setInterval(function () {
    getBieberTweet(function (tweet) {
      socket.volatile.emit('bieber tweet', tweet);
    });
  }, 100);
  socket.on('disconnect', function () {
    clearInterval(tweets);
  });
});
```

## 配置

Options like log-level are gone. `io.set('transports')`, `io.set('heartbeat interval')`, `io.set('heartbeat timeout'`, and `io.set('resource')` are still supported for backwards compatibility.

```js
var socket = require('socket.io')({
  // options go here
});
```

```js
var socket = io.connect('localhost:3000', {
  'path': '/path/to/socket.io';
});
```

## 认证与握手

我们可以设置认证。这样客户端在连接 socket.io 服务器时可以做一些安全或者特殊处理。

socket.io 采用 TJ 风格的设置语法，如：

```js
io.use(function(socket, next) {
  var handshakeData = socket.request;
  // make sure the handshake data looks good as before
  // if error do this:
    // next(new Error('not authorized');
  // else just call next
  next();
});
```

Namespace authorization?

```
io.of('/namespace').use(function(socket, next) {
  var handshakeData = socket.request;
  next();
});
```

上面的 authorrization 设置项即设置服务端的认证，后面回调函数的第一个参数 handshakeData 就附带了客户端传递过来的数据，比如头数据以及IP地址、请求的 URL 和 参数等，基于这些数据进行验证，如果验证符合你的业务逻辑，则调用`callback(null, true)` ，否则将错误放在callback的第一个参数，如`callback('need login')`;

注，验证失败之后，socket 所注册的各种事件就不会被执行。

```js
io.sockets.on('connection', function (socket) {
    // ...
});
```

## Logging

Logging is now based on [debug](https://www.npmjs.org/package/debug)

To print all debug logging, set the environment variable DEBUG to *. ie: `DEBUG=* node index.js`

To print only socket.io related logging: `DEBUG=socket.io:* node index.js`.

To print logging only from the socket object: `DEBUG=socket.io:socket node index.js`.

This pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.

Debug also works in the browser; logs are persisted to localstorage.  
To use: open the developer console and type `localStorage.debug = 'socket.io:*'` (or any debug level) and then refresh the page. Everything is logged until you run `localStorage.debug = ''`

## Library

- [13. Comet and Socket.io - Mixu's Node book](http://book.mixu.net/node/ch13.html)
- [Real-Time Chat With Node.js' Readline & Socket.io - Tuts+ Code Tutorial](http://code.tutsplus.com/tutorials/real-time-chat-with-nodejs-readline-socketio--cms-20953)
- [topcloud/socketcluster](https://github.com/topcloud/socketcluster) Highly scalable realtime WebSockets based on Engine.io.

## Reference

- [socket.io学习笔记 - 作业部落 Cmd Markdown 编辑阅读器](https://www.zybuluo.com/bornkiller/note/6163)
- [NodeJS 和 Socket.io 中文入门教程](http://uwebs.tk/code/nodejs-and-socketio-tutorial.html)

## Tutorial

- [Socket.io 学习笔记三 - 作业部落 Cmd Markdown 编辑阅读器](https://www.zybuluo.com/bornkiller/note/7167)
- [socket.io学习笔记二 - 作业部落 Cmd Markdown 编辑阅读器](https://www.zybuluo.com/bornkiller/note/5273)
- [javascript - Sending a message to a client via its socket.id - Stack Overflow](http://stackoverflow.com/questions/8467784/sending-a-message-to-a-client-via-its-socket-id/8468296#8468296&sref=https://delicious.com/victorwoo/socket.io)
- [island205/technode-tutorial](https://github.com/island205/technode-tutorial#toc0)
- [Getting Chatty with Angular, Socket.IO, Node/Express and Bootstrap - Chariot Solutions](http://chariotsolutions.com/blog/post/getting-chatty-angular-socket-io-nodeexpress-bootstrap/)
- [Improve this AngularJS factory to use with socket.io - Stack Overflow](http://stackoverflow.com/questions/14389049/improve-this-angularjs-factory-to-use-with-socket-io)