layout: post
title: "C/C++ 指针"
category: C++
tags: [c++, syntax]
--- 

> 原文：http://blog.jobbole.com/25409

## 指针、引用和取值

什么是指针？什么是内存地址？什么叫做指针的取值？指针是一个存储计算机内存地址的变量。在这份教程里“引用”表示计算机内存地址。从指针指向的内存读取数据称作指针的取值。指针可以指向某些具体类型的变量地址，例如int、long和double。指针也可以是void类型、NULL指针和未初始化指针。本文会对上述所有指针类型进行探讨。

根据出现的位置不同，操作符 * 既可以用来声明一个指针变量，也可以用作指针的取值。当用在声明一个变量时，*表示这里声明了一个指针。其它情况用到*表示指针的取值。

&是地址操作符，用来引用一个内存地址。通过在变量名字前使用&操作符，我们可以得到该变量的内存地址。

    // 声明一个int指针
    int *ptr;
    // 声明一个int值
    int val = 1;
    // 为指针分配一个int值的引用
    ptr = &val;
    // 对指针进行取值，打印存储在指针地址中的内容
    int deref = *ptr;
    printf("%d\n", deref);

<!--more-->

第2行，我们通过*操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。

第6行的&val是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符&我们可以直接引用变量的内存地址。

第8行，我们再一次使用*操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。

这里可以把指针、引用和值的关系类比为信封、邮箱地址和房子。一个指针就好像是一个信封，我们可以在上面填写邮寄地址。一个引用（地址）就像是一个邮件地址，它是实际的地址。取值就像是地址对应的房子。我们可以把信封上的地址擦掉，写上另外一个我们想要的地址，但这个行为对房子没有任何影响。

void指针、NULL指针和未初始化指针
一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。

    int *uninit; // int指针未初始化
    int *nullptr = NULL; // 初始化为NULL
    void *vptr; // void指针未初始化
    int val = 1;
    int *iptr;
    int *castptr;
     
    // void类型可以存储任意类型的指针或引用
    iptr = &val;
    vptr = iptr;
    printf("iptr=%p, vptr=%p\n", iptr, vptr);
     
    // 通过显示转换，我们可以把一个void指针转成
    // int指针并进行取值
    castptr = (int *)vptr;
    printf("*castptr=%d\n", *castptr);
     
    // 打印null和未初始化指针
    printf("uninit=%p, nullptr=%p\n", uninit, nullptr);
    // 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？
    // printf("*nullptr=%d\n", nullptr);
    // 这里会产生一个段错误
    // printf("*nullptr=%d\n", nullptr);

执行上面的代码，你会得到类似下面对应不同内存地址的输出。

    iptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c
    *castptr=1
    uninit=0x7fff94b89d50, nullptr=(nil)

第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。

第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。

第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。

第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。

NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。

## 指针和数组

C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。

一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。

    int myarray[4] = {1,2,3,0};
    int *ptr = myarray;
    printf("*ptr=%d\n", *ptr);
 
    // 数组变量是常量，不能做下面的赋值
    // myarray = ptr
    // myarray = myarray2
    // myarray = &myarray2[0]

第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。

 

## 指针与结构体

就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。

    struct person {
      int age;
      char *name;
    };
    struct person first;
    struct person *ptr;
     
    first.age = 21;
    char *fullname = "full name";
    first.name = fullname;
    ptr = &first;
 
printf("age=%d, name=%s\n", first.age, ptr->name);
第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。

第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘->’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘->’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。

## 引用

参考：[6.4.2　以"引用传递"方式向函数传递参数](http://book.51cto.com/art/200906/128293.htm)

    void changeVar(int &myVar, int newValue);

这个函数的第一个输入参数myVar不是一个指针，它是那个将被传递给这个函数的原始变量的一个别名。在changeVar()函数里对这个参数变量进行的任何操作都将反映在changeVar()函数外的那个原始变量身上。

    
    void changeVar (int &myVar, int newValue) {
        myVar = newValue;
    }

<!--more-->

这使得这个函数更容易被调用--只需提供一个变量名：

    int main() {
    int myNum = 20;
    changeVar(myNum, 90);
    // Rest of main().

正如你看到的那样，这个函数的功能可以用来改变某个变量的值。

如果在定义某个函数的时候让它以"引用传递"方式获得输入参数，就不能再把具体的参数值本身直接传递给它。如下所示的函数调用无法工作：

    changeVar(20, 90);

无论何时何地，都可以创建一个引用变量，其并不仅限于充当某个函数的输入参数。比如：

    int n1 = 10;  
    int &n2 = n1; 

现在，n1和n2指向同一个内存块，利用它们当中任何一个进行的修改都会影响到另一个。

在定义函数时，还可以让它以"引用传递"方式而不是以"值传递"方式返回：

    int &myFunction(); 

除了可以改变有关变量的值，"引用传递"方式的另一个好处是它的开销相对要小一些：因为不需要在函数里创建临时变量来容纳那些值，程序的内存占用量当然会小一些。

如果想获得"引用传递"方式带来的性能改善，但不想改变某个变量的值，可以把相应的输入参数定义为一个常量：

    void myFunc (const int &myNum); 

通过这样定义的函数，可以把具体的参数值直接传递给它：

    myFunc(7); 

## Tutorial

- [C++的未来和指针 - 博客 - 伯乐在线](http://blog.jobbole.com/56312/)
- [C++中的动态内存与智能指针 - 博客 - 伯乐在线](http://blog.jobbole.com/56316/)
