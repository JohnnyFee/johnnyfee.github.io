layout: post
title: "PHP Test"
description: ""
category: PHP
tags: [php, tutorial]
---

Let’s talk about how to install, write, and run PHPUnit tests. It takes a bit of work to get the infrastructure in place, but it’s dead simple to write and run your PHPUnit tests afterward. Before we dig too deep into PHPUnit, let’s quickly review some vocabulary. Your PHPUnit tests are grouped into _test cases_, and your test cases are grouped into _test suites_. PHPUnit runs your test suites with a _test runner_.

A test case is a single PHP class that extends the `PHPUnit_Framework_TestCase` class. Each test case contains public methods whose names begin with `test`; these methods are individual tests that assert specific scenarios to be true. Each assertion can pass or fail. You want all assertions to pass.

A test case class name must end with `Test`, and its filename must end with _Test.php_. A hypothetical test case class name is `FooTest`, and that class lives in a file named _FooTest.php_.

A test suite is a collection of related test cases. If you are working on a single PHP component, oftentimes you’ll only ever have a single test suite. If you are testing a larger PHP application with many different subsystems or components, you may find it best to organize tests into multiple test suites. 

A test runner is exactly what it sounds like. It is a way for PHPUnit to run your test suites and output the result. The default PHPUnit test runner is the _command-line runner_ that is invoked with the `phpunit` command in your terminal application.

## Directory Structure

Here’s how I prefer to organize my PHP projects. The topmost project directory has a _src/_ directory where I keep my source code. It also has a _tests/_ directory where I keep my tests. Here’s an example directory structure:

```
src/
tests/
    bootstrap.php
composer.json
phpunit.xml
.travis.yml
```

- src/

    This directory contains my PHP project’s source code (i.e., PHP classes).

- tests/

    This directory contains my PHP project’s PHPUnit tests. This directory contains a bootstrap.php file that is included by PHPUnit before the unit tests are run.

- composer.json
    
    This file lists my PHP project’s dependencies managed by Composer, including the PHPUnit test framework.

- phpunit.xml

    This file provides configuration details for the PHPUnit test runner.

- .travis.yml

    This file provides configuration details for the Travis CI continuous testing web service.

## Install PHPUnit

First we need to install PHPUnit and the Xdebug profiler. PHPUnit runs our tests. The Xdebug profiler generates helpful code coverage information. Composer is the easiest way to install the PHPUnit test framework. Open your terminal application, navigate to your project’s topmost directory, and run this command:

```
composer require --dev phpunit/phpunit
```

This command downloads the PHPUnit test framework into your project’s _vendor/_ directory, and it updates your project’s _composer.json_ file so that the `phpunit/phpunit` package is listed as a project dependency. The `phpunit` binary is installed in your project’s _vendor/bin/_ directory. You can add this directory to your environment path, or you can reference `vendor/bin/phpunit` whenever you invoke the PHPUnit command line test runner. The PHPUnit framework classes are autoloaded into your PHP application with your project’s other Composer-managed dependencies.

## Install Xdebug

The Xdebug PHP extension is a bit trickier to install. If you installed PHP with your package manager, you can install Xdebug the same way.

```
# Ubuntu
sudo apt-get install php5-xdebug

# CentOS
sudo yum -y --enablerepo=epel,remi,remi-php56 install php-xdebug
```

If you installed PHP from source, you’ll need to install the Xdebug extension with the `pecl` command:

    pecl install xdebug

Next, update your _php.ini_ configuration file with the path to the compiled Xdebug extension.

You can find your PHP extensions directory with the `php-config --extension-dir` or `php -i | grep extension_dir` commands.

Append this line to your _php.ini_ file using your own PHP extension path:

    zend_extension="/PATH/TO/xdebug.so"

## Configure PHPUnit

Now let’s configure PHPUnit in our project’s _phpunit.xml_ file.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit bootstrap="tests/bootstrap.php">
    <testsuites>
        <testsuite name="whovian">
            <directory suffix="Test.php">tests</directory>
        </testsuite>
    </testsuites>

    <filter>
        <whitelist>
            <directory>src</directory>
        </whitelist>
    </filter>
</phpunit>
```

PHPUnit test runner settings are attributes on the `<phpunit>` XML root element. The most important setting, in my opinion, is the `bootstrap` setting; it specifies the path (relative to the _phpunit.xml_ file) to a PHP file that is included before the PHPUnit test runner executes our tests. We’ll autoload our application’s Composer dependencies in the _bootstrap.php_ file so they are available to our PHPUnit tests. The _bootstrap.php_ file also specifies the path to our test suite (i.e., a directory that contains related test cases); PHPUnit runs all PHP files in this directory whose file names end with _Test.php_. Finally, this configuration file lists the directories included in our code coverage analysis with the `<filter>` element. In the previous example XML, the `<whitelist>` element tells PHPUnit to generate code coverage only for code in the _src/_ directory. 

The gist of this configuration file is to specify our PHPUnit settings in one location. This makes our lives easier locally because we don’t have to specify these settings each time we use the `phpunit` command-line runner. This configuration file also lets us apply the same PHPUnit settings on remote continuous testing servers like Travis CI. After you update the _phpunit.xml_ configuration file, update the _tests/bootstrap.php_ file with this code:

```
<?php
// Enable Composer autoloader
require dirname(__DIR__) . '/vendor/autoload.php';
```

## The Whovian Class

Before we write unit tests, we need something to test. Here’s a hypothetical PHP class named `Whovian` that has a pretty strong opinion about a particular BBC television show. Place this class definition into the _src/Whovian.php_ file:

```
<?php
class Whovian
{
    /**
     * @var string
     */
    protected $favoriteDoctor;

    /**
     * Constructor
     * @param  string $favoriteDoctor
     */
    public function __construct($favoriteDoctor)
    {
        $this->favoriteDoctor = (string)$favoriteDoctor;
    }

    /**
     * Say
     * @return string
     */
    public function say()
    {
        return 'The best doctor is ' . $this->favoriteDoctor;
    }

    /**
     * Respond to
     * @param  string $input
     * @return string
     * @throws \Exception
     */
    public function respondTo($input)
    {
        $input = strtolower($input);
        $myDoctor = strtolower($this->favoriteDoctor);

        if (strpos($input, $myDoctor) === false) {
            throw new Exception(
                sprintf(
                    'No way! %s is the best doctor ever!',
                    $this->favoriteDoctor
                )
            );
        }

        return 'I agree!';
    }
}
```

The `Whovian` class constructor sets the instance’s favorite doctor. The `say()` method returns a string with the instance’s favorite doctor. And its `respondTo()` method receives a statement from another `Whovian` instance and responds accordingly.

### The WhovianTest Test Case

The unit tests for our `Whovian` class live in the _test/WhovianTest.php_ file. We call a group of related tests a _test suite_. In our example, all tests beneath the _test/_ directory belong to the same test suite. Each class file beneath the _test/_ directory is called a _test case_, and its class methods that begin with `test` (e.g., `testThis` or `testThat`) are individual tests. Each individual test uses assertions to verify a given condition. An assertion can pass or fail.

Each PHPUnit test case is a class that extends the `PHPUnit_Framework_TestCase` class. Let’s declare a test case named `WhovianTest` in the _test/WhovianTest.php_ file:

```
<?php
require dirname(__DIR__) . '/src/Whovian.php';

class WhovianTest extends PHPUnit_Framework_TestCase
{
    // Individual tests go here
}

```

Remember, unit tests verify a public interface’s expected behavior. We’ll test the three public methods in the `Whovian` class. We’ll write a unit test to ensure that the `__construct()` method argument becomes the instance’s preferred doctor. Next, we’ll write a unit test to ensure that the `say()` method’s return value mentions the instance’s preferred doctor. Finally, we’ll write two tests for the `respondTo()` method. One test ensures that the method’s return value is the string `"I agree!"` if the input matches its preferred doctor. The second test that ensures the method throws an exception if the input does not match its preferred doctor.

#### Test 1: __construct()

Our first test confirms that the constructor sets the Whovian instance’s favorite doctor:

```
public function testSetsDoctorWithConstructor()
{
    $whovian = new Whovian('Peter Capaldi');
    $this->assertAttributeEquals('Peter Capaldi', 'favoriteDoctor', $whovian);
}
```

This test instantiates a new `Whovian` instance with one string argument: `"Peter Capaldi"`. We use the PHPUnit assertion method `assertAttributeEquals()` to assert the `favoriteDoctor` property on the `$whovian` instance equals the string `"Peter Capaldi"`.

The PHPUnit assertion `assertAttributeEquals()` receives three arguments. The first argument is the expected value; the second argument is the property name; and the final argument is the object to inspect. What’s neat is that the `assertAttributeEquals()` method can inspect and verify protected properties using PHP’s reflection capabilities.

Why do we inspect the favorite doctor value with the `assertAttributeEquals()` assertion instead of a getter method (e.g., `getFavoriteDoctor()`)? When we write a test, we test _only one specific method in isolation_. Ideally, our test does not rely on other methods. In this particular example, we test the `__construct()` method and verify that it assigns its argument value to the object’s `$favoriteDoctor` property. The `assertAttributeEquals()` assertion lets us inspect the object’s internal state without relying on a separate, untested getter method.

#### Test 2: say()

Our next test confirms that the Whovian instance’s say() method returns a string value that contains its favorite doctor’s name:

```
public function testSaysDoctorName()
{
    $whovian = new Whovian('David Tennant');
    $this->assertEquals('The best doctor is David Tennant', $whovian->say());
}
```

We use the PHPUnit assertion `assertEquals()` to compare two values. The assertion’s first argument is the expected value. Its second argument is the value to inspect.

#### Test 3: respondTo() in agreement

But what if a `Whovian` _disagrees_? Get out of the area as quickly as possible, because s#!t is going to hit the fan. Well, actually, it’ll just throw an exception. Let’s test that:

```
/**
 * @expectedException Exception
 */
public function testRespondToInDisagreement()
{
    $whovian = new Whovian('David Tennant');

    $opinion = 'No way. Matt Smith was awesome!';
    $whovian->respondTo($opinion);
}
```

If this test throws an exception, the test passes. Otherwise, the test fails. We can test this condition with the `@expectedException` annotation.

## Run Tests

After you write each test, you should run your test suite to ensure that it passes. This is really simple to do. Open your terminal application and navigate to your project’s topmost directory (the same directory as your _phpunit.xml_ configuration file). We’ll use the PHPUnit binary installed with Composer. Use this command to start the PHPUnit test runner:

    vendor/bin/phpunit -c phpunit.xml

The `-c` option specifies the path to the PHPUnit configuration file. The terminal shows the results from the PHPUnit command-line test runner, and they look like:

![](http://johnnyimages.qiniudn.com/php-unit-test.png)

These results tell us:

1.  PHPUnit read our configuration file.
2.  PHPUnit took 24 ms to complete.
3.  PHPUnit used 3.5 MB of memory.
4.  PHPUnit successfully ran five tests and five assertions.

## Code Coverage

We know our PHPUnit tests pass. However, are we sure we tested as much of our code as possible? Perhaps we forgot to test something. We can see exactly which code is tested (and untested) with PHPUnit’s code coverage report. We already specify the path(s) to our source code files in the PHPUnit configuration file. All PHP files in the whitelisted directories are included in PHPUnit’s code coverage report. We can generate code coverage each time we run the PHPUnit test runner:

    vendor/bin/phpunit -c phpunit.xml --coverage-html coverage

This is the same command we used earlier, except we append the new `--coverage-html` option whose value is the path to a the code coverage report directory. After you run this command, open the newly generated _coverage/index.html_ file in a web browser to see the code coverage results. Ideally, you want to see 100% coverage across the board. However, 100% coverage is _not realistic_ and definitely should not be a requirement. How much coverage is good is subjective and varies from project to project.

![](http://johnnyimages.qiniudn.com/php-test-covarage.png)

## Continuous Testing with Travis CI

Sometimes even the best PHP developers forget to write tests. This is why it is important to automate your tests. The best tests are like a good backup strategy—out of sight and out of mind. _Tests should run automatically_. My favorite continuous testing service is [Travis CI](https://travis-ci.org/) because it has native hooks into GitHub repositories. I can run my application tests within Travis CI every time I push code to GitHub. Travis CI runs my tests against multiple PHP versions, too.

### Setup

If you have not used Travis CI before, go to [_https://travis-ci.org_](https://travis-ci.org) (for public repositories) or [_https://travis-ci.com_](https://travis-ci.com) (for private repositories). Log in with your GitHub account. Follow the on-screen instructions to choose which repository to test with Travis CI. 

Next, create the _.travis.yml_ Travis CI configuration file in your application’s topmost directory. Don’t forget the leading _._ character! Save, commit, and push the Travis CI configuration file to your GitHub repository. Here’s an example Travis CI configuration:

```
language: php
php:
  - 5.4
  - 5.5
  - 5.6
  - hhvm
install:
  - composer install --no-dev --quiet
script: phpunit -c phpunit.xml --coverage-text
```

The Travis CI configuration is written in YAML format and includes these settings:

- language

    This is the language used for our application. We set this to php. This value is case-sensitive!

- php

    Travis CI runs our application tests against these PHP versions. It is important that you test against all PHP versions supported by your application.

- install

    This is a bash command executed by Travis CI before it runs application tests. This is where you instruct Travis CI to install your project’s Composer dependencies. It is important that you use the --no-dev option to avoid installing unnecessary development dependencies.

- script

    This is the bash command executed by Travis CI to run application tests. By default, this is phpunit. You can override Travis CI’s default command with this setting. In this example, we tell Travis CI to use our custom PHPUnit configuration file and generate plain text coverage results.

### Run

Travis CI automatically runs your application tests every time you push new commits to your GitHub repository and emails you the test results. How cool is that? There are, of course, many more Travis CI settings to further customize the Travis CI testing environment (e.g., install custom PHP extensions, use custom `ini` settings, and so on). Read more about Travis CI configuration for PHP at [Travis CI](http://bit.ly/build-php).

## Further Reading

Here are a few links to help you learn more about PHP application testing:

- <https://phpunit.de/>
- <http://www.phpspec.net/docs/introduction.html>
- <http://behat.org/>
- <https://leanpub.com/grumpy-phpunit>
- <https://leanpub.com/grumpy-testing>
- <http://www.littlehart.net/atthekeyboard/>