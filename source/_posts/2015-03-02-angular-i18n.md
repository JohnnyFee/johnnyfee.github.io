layout: post
title: "Angular i18n"
description: ""
category: Angular
tags: [angular, i18n]
--- 

## i18n and l10n

Many web applications need to support multiple languages. The process of building in this support in a piece of software can be split in two parts: Getting it technically ready to support multiple languages/regions, and getting it ready for a particular language/region. The first part is called _internationalization_, often abbreviated to i18n (18 being the number of characters left out in the abbreviation). The second part is called _localization_, abbreviated as L10n. In this blog post, we'll see how we can support i18n in an AngularJS-based web application. There is an example project available containing all source code. It's a Maven project based on Tomcat 7 (Servlet API 3.0) and JDK 6, and can be downloaded [here](http://blog.trifork.com/wp-content/uploads/2014/03/i18n-angular.zip). The example builds on a an example case I created as part of a [previous blog](http://blog.trifork.com/2014/03/20/web-forms-with-java-angularjs-and-other-approaches) on AngularJS.

<!-- more -->

It's useful to start by quickly reviewing what i18n includes, and what aspects of it we're going to implement. At a most basic level, we should eliminate hard coded texts. Instead, pieces of text should be identified by a label or unique key. The translation of this label to an actual piece of text will be dependent on the language. For each supported language, there is a translation table containing the actual texts for each label. In the Java world, this table is known as a [ResourceBundle](http://docs.oracle.com/javase/7/docs/api/java/util/ResourceBundle.html). This is the most elementary type of i18n, and we will see it in action in our example application.

It turns out that in actual applications, simply serving a static string for each label doesn't cut it. Consider the message "The compiler found 8 errors.". Here, the number 8 is obviously not a fixed part of the text. This should be a dynamic parameter of the message. The process of creating the actual message from a kind of template and a set of parameters is often called _interpolation_. But what if there is only 1 error? Then the text should read "1 error." and not "1 errors.". Getting this aspect right is called _pluralization_. In the Java world, both interpolation and pluralization can be done by the [MessageFormat](http://docs.oracle.com/javase/7/docs/api/java/text/MessageFormat.html) class. We'll see how these can be handled through AngularJS in our example application.

When doing interpolation, a specific aspect that is language-dependent is the formatting of the parameters. For instance, in case the parameter is of a number type, the decimal separator is a point (".") in English but it's a comma (",") in Dutch. A much more complex case is formatting dates in long form. This involves translating a technical representation of a date/time (for instance, an ISO8601 date like '2014-03-16') to its natural language representation (March 16th, 2014). This is an aspect that isn't included in our example project, although it could be handled along the same lines.

In addition to the things described above, there are some i18n fringe phenomena that I won't really cover in the discussion. One of those things is displaying the right currency sign. I personally believe this issue is wrongly placed under the i18n umbrella; if you have an international application dealing with money, currency handling is a business logic issue and not merely a presentation thing. Other things are time zones, i18n of non-text resources (e.g., images) and non-Western languages that use a direction of writing other than left-to-right.

### 什么是区域id（locale id）?

locale 是一个特定地理、政治、文化的地区。最常用的 locale id 由两部分组成：语言代码和国家代码。例如，en-US，en-AU，zh-CN 都是有效的 locale ID，都包含语言代码和国家代码。因为在 locale ID 中指定的国家编码是可选的，locale ID，例如 en、zh 和 sk 都是有效的。查看网站 [ICU](http://userguide.icu-project.org/locale)，那里有更多关于locale ID的信息。

## I18n and L10n in AngularJS

If you look at the [AngularJS developer guide](http://docs.angularjs.org/guide/i18n), you'll see that AngularJS supports some of the things we just described. There's formatting of date/time, numbers and currency. Also, there is support for pluralization. But there are two important limitations. First, there is no out of the box support for the process of translating a label/key to an actual text for a given language (which in my mind is an i18n requirement that is more basic than formatting dates and numbers). Second, the language to be used for date/time and number formatting must be chosen when the page is initialized and can't be changed dynamically. Overall, you could say that AngularJS has rather limited i18n support.

Although the out-of-the-box support of i18n by AngularJS is a bit disappointing, doing i18n with AngularJS still has a lot of potential. AngularJS has a filter syntax (things like `{{ 12 | currency }}` producing `$12.00`), which really seems to fit nicely with i18n. Why not have `{{ 'HORSE' | xlat }}` producing 'horse' in English and 'paard' in Dutch? Also, handling i18n in AngularJS (and thus in the client/browser) makes for a very nice architecture. i18n would be dealt with as a presentation-layer aspect only, and the server side business logic wouldn't have to know anything about it.

Looking at 3rd party i18n extensions to AngularJS, one quickly stumbles upon [angular-translate](http://angular-translate.github.io/). This is an implementation of the basic idea of using a filter to perform i18n in AngularJS. I've used it for a real-world application, and it generally works fine. The problem I have with it though, is caused by the fact that requirements and technical details surrounding i18n vary greatly between applications. For instance: How do you determine the initial language to be used for a user? Where do you store the current language? Where do the translation tables come from? If translation tables are changed/expanded dynamically, when does this take place and how? angular-translate deals with this variety by being very configurable and modular. The result is that I often find myself having to implement a custom implementation of some angular-translate component to get it to do what I need it to do; and that is somewhat tricky.

Just coding what you actually need, directly in AngularJS, may be a lot simpler in many cases. That's the approach taken in our example project, which we will discuss below.


## angular 对 18n、L10n 的支持？

当前，angular 对 [date](https://docs.angularjs.org/api/ng/filter/date), [number](https://docs.angularjs.org/api/ng/filter/number) and
[currency](https://docs.angularjs.org/api/ng/filter/currency) 过滤器提供 I18n、L10n 支持。

此外，angular通过 [ngPluralize directive](http://docs.angularjs.org/api/ng.directive:ngPluralize)支持多元化的本地化。

所有可本地化的控件都依赖于通过 `$locale` 服务管理的区域设定特性规则集。

为了让读者看到实际例子，官方准备了一些网页例子，展示如何通过区域规则集合变量使用 angular 过滤器。我们可以在 [e2e directory](https://github.com/angular/angular.js/tree/master/i18n/e2e) 中找到对应的例子。

### angular 支持的 locale

Angular separates number and datetime format rule sets into different files, each file for a
particular locale. You can find a list of currently supported locales
[here](https://github.com/angular/angular.js/tree/master/src/ngLocale)

## 在 angular 中定制 locale 规则

在angular中定制locale有两个方式：

### 预先绑定的规则集合（Pre-bundled rule sets）

我们可以通过将locale-specific的文件连接到 angular.js 或者 angular.min.js 之后，实现将angular和预先绑定（pre-bundle）期望的locale文件。

例如，在 *nix 中，我们可以通过以下命令来创建一个包含德国区域本地化规则的文件的angular.js文件：

    cat angular.js i18n/angular-locale_de-ge.js > angular_de-ge.js

当从应用程序使用 angular_de-ge.js 脚本代替一般的 angular.js 脚本开始，angular 开始自动预先配置（pre-configured）德国地区的本地化规则。

### 包含 locale js 脚本到 index.html 页

我们也可以包含指定区域的js文件到页面当中。例如，如果一个客户端需要德国区域文件，我们可以提供类似以下的页面：

```html
<html ng-app>
    <head>
    ...
    <script src="angular.js"></script>
    <script src="i18n/angular-locale_de-ge.js"></script>
    ...
    </head>
    ...
</html>
```

上述两种方法，都要求我们为本地化而提供各个区域的不同的 index.html 页或者 js 文件。我们还需要配置我们的服务器提供正确的、符合期望的区域设置文件。

然而，第二种方式（包含区域设置文件到页面中）会比较慢，因为需要多加载一个脚本。

## 陷阱（“Gotchas”）

### 货币符号陷阱

angular 的 currency filter 允许我们从 locale service 中使用默认的货币符号，我们也可以提供自定义的货币符号。如果我们的应用只在一个区域中使用，那么我们可以依赖（设置）默认货币符号。但是，如果我们预料到其他区域的用户也会使用到我们的应用的话，我们应该提供我们自定义的货币符号，确保用户能够明白实际的值。

例如，如果我们想通过绑定currency filter来显示账户余额为1000元：{%raw%}{{ 1000 | currency}}{%endraw%}，我们的应用当前是使用en-US的区域设置，那么将会显示”$1000.00”。然而，如果一些其他区域（例如中国大陆）的用户访问我们的应用，用户浏览器会指定区域设置为“中国大陆”，然后余额将显示为“￥1000.00”（很悲催的错误啊，汇率...）。

在这个例子中，当我们需要设置filter的时候，我们需要通过对currency filter（http://docs.angularjs.org/api/ng.filter:currency）提供货币符号作为参数来重写默认货币符号，参数如：USD$。这样，angular会忽略任何区域设置的变化，一直显示余额为“USD$1000.00”。

### 翻译长度陷阱

记住，翻译字符串、事件格式时，长度的变化可能会很大。例如“June 3, 1977”翻译为西班牙语时变为“3 de junio de 1977”。当然，还可能会有更加极端的状况。因此，当我们对应用进行国际化时，我们需要设置相应的CSS规则并且进行全面测试，确保UI组件不会折行（变型）。

### 时区

记住，angular的datetime filter是使用浏览器端设置的时区的。所以，同一个应用将根据运行应用的计算机的时区设置而显示不同的时间信息，而不是取决于javascript或者angular的开发者指定的时区。

## 自定义国际化和本地化机制

### The basics

The first thing we want to achieve is to have language-agnostic labels being translated into a language-specific text by a filter. In our HTML form, we want to write something like:

```html
<div>
  <!-- The raw label 'FIRST_NAME' will
     serve as input to the 'xlat' filter function. -->
  <label>{{ 'FIRST_NAME' | xlat }}</label>
  <input data-ng-model="data.firstName" type="text">
</div>
```

The basic task we need to achieve is to implement the `xlat` filter. A very rough implementation could be like this:

```js
formApp.filter('xlat', ['$rootScope', function($rootScope) {
  // The code here executes only once, during initialization.
  // We'll return the actual filter function that's executed
  // many times.
  var tables = {
    'en': { 'FIRST_NAME': 'First name:' },
    'nl': { 'FIRST_NAME': 'Voornaam:' }
  };
  $rootScope.currentLanguage = 'en';
  return function(label) {
    // tables is a nested map; by first selecting the
    // current language (kept in the $rootScope as a
    // global variable), and selecting the label,
    // we get the correct value.
    return tables[$rootScope.currentLanguage][label];
  };
}]);
```

Here, the translation table is hard coded into the filter function. We're creating a `$rootScope` variable (which is like a "global" variable) to keep track of the selected language. And this filter is part of the the same AngularJS module as our form itself. So there is room for improvement as far as software architecture goes. But the basic idea works fine. We cannot only use this filter in the `{{ ... }}` context, but also in other places where AngularJS expressions occur, such as in the `ng-options` attribute of a select input:

```html
<div>
  <label>{{ 'FAV_COLOR' | xlat }}</label> 
  <!-- AngularJS will create the HTML <option>s dynamically
   based on the ng-options attribute. It supports many
   different syntaxes, and we may simply use our filter
   within it. -->
  <select 
      data-ng-model="data.color" 
      data-ng-options="('COLOR_' + opt | xlat) 
                       for opt in colorOptions">
  </select>
</div>
```

### Improving the architecture

i18n is a shared concern among many parts of our application. It's best placed in a separate module, in its own JavaScript file. The actual logic of the i18n can be put in an AngularJS service factory. This service can be injected as a dependency into the filter (for doing translations) and in controllers (for having the user change the current language). The initial translation tables can be retrieved from a separate file (maybe generated dynamically by the server). The new `xlat.js` module looks like this:

```js
// We'll create a separate module that we can depend on
// in our main application module.
var xlat = angular.module('xlat', []);

xlat.factory('xlatService', function() {
  // This function will be executed once. We use it as
  // a scope to keep our current language in (thus avoiding
  // the ugly use of root scope).
  var currentLanguage = 'en';
  // We copy the initial translation table that we included
  // in a separate file to our scope. (As may might change
  // this dynamically, it's good practice to make a deep copy
  // rather than just refer to it.)
  var tables = $.extend(true, {}, initialXlatTables);
  // We return the service object that will be injected into
  // both our filter and our application module.
  return {
    setCurrentLanguage: function(newCurrentLanguage) {
      currentLanguage = newCurrentLanguage;
    },    
    getCurrentLanguage: function() {
      return currentLanguage;
    },    
    xlat: function(label, parameters) {
      // This is where we will add more functionality
      // once we start to do something more than
      // simply look up a label.
      return tables[currentLanguage][label];
    }    
  };
});

// The filter itself has now a very short definition; it simply
// acts as a proxy to the xlatService's xlat function.
xlat.filter('xlat', ['xlatService', function(xlatService) {
  return function(label) {
    return xlatService.xlat(label);
  };
}]);
```

And to support switching languages in the form, we modify our form.js module like this:

```
formApp.controller('FormController',
// We inject the xlatService in out controller.
    ['$scope', ..., 'xlatService',
     function($scope, ..., xlatService) {
  ...
// So we can create a $scope function that can be linked
// to the click of a change-language button.
  $scope.setCurrentLanguage = function(language) {
    xlatService.setCurrentLanguage(language);
  };
```

Now, everything is neatly factored out and the xlat functionality doesn't mess up our other modules and controllers.

### Adding functionality: interpolation

AngularJS itself has interpolation as one of its core functions. It's used to translate AngularJS expressions in `{{ ... }}` to text. Luckily, AngularJS exposes this functionality to the programmer as the `$interpolate` service. In a certain sense,  
`$interpolate` will be our AngularJS, client-side alternative to Java's `MessageFormat`. But how do we get the parameters to our filter function? AngularJS's filters support filter arguments, to be presented after a colon following the filter name.

As an example, consider the label

    'AGE_MAX': 'Age cannot be higher than {{years}}.'

Whenever the server returns an AGE_MAX message, it will return as well the value of the years parameter. We'll make sure the server returns a JSON message array like this:

    [ { "label": "AGE_MAX", "parameters": { "years": 130 } } ]

To support interpolation, we'll include the following in the HTML:

```html
<ul>
  <!-- Here, m is an object with properties 'label' and
     'parameters'. 'm.label' is the regular filter
     input, and 'm.parameters' is additional filter
     input provided after the colon. -->
  <li data-ng-repeat="m in messages">
    {{m.label | xlat:(m.parameters)}}
  </li>
</ul>
```

We have to modify our xlat filter to support the parameters argument:

```js
// Still just a proxy, but now including both the standard
// and additional arguments.
xlat.filter('xlat', ['xlatService', function(xlatService) {
  return function(label, parameters) {
    return xlatService.xlat(label, parameters);
  };
}]);
```

And finally, the xlatService will need to support this as well. Here, we'll inject the $interpolate service and modify our xlat function:

```js
xlat.factory('xlatService', ['$interpolate', function($interpolate) {
  // ...
  return {
    // ...
    xlat: function(label, parameters) {
      if(parameters == null || $.isEmptyObject(parameters)) {
        // No parameters, so we don't have to worry about
        // interpolation.
        return tables[currentLanguage][label];
      } else {
        // We got parameters. We'll provide our text to the
        // $interpolate service, that will return a function.
        // Applying the parameters to this function will give
        // us the actual text.
        return $interpolate(
                 tables[currentLanguage][label])(
                   parameters);
      }
    }    
  };
}]);
```

After building this, I found it remarkably simple. There is not much going on here besides wiring together the filter syntax with the existing `$interpolate` service.

### Adding functionality: pluralization

Pluralization (and related stuff like 'genderization') is a pretty complex topic if you think it through. The readme of the [messageformat.js](https://github.com/SlexAxton/messageformat.js) project gives a nice impression of the complexity involved. I wanted to do something powerful enough to handle most of the cases, yet simple enough to to be implemented in just a couple of lines of code.

The solution I've chosen is that the value contained in a translation table for a particular label, may be a function rather than a text. If it's a function, the xlat function will evaluate this function against the parameters. The result will be treated as the new label. Some example data to see it in action:

```js
'INCORRECT_FIELDS': function(parameters) {
  if(parameters.n == 1) return 'INCORRECT_FIELDS_SINGULAR';
  else return 'INCORRECT_FIELDS_PLURAL';
},
'INCORRECT_FIELDS_SINGULAR': '1 input field was incorrect.',
'INCORRECT_FIELDS_PLURAL': '{{n}} input fields were incorrect.'
```

The intention here is to correctly distinguish between "field was" and "fields were" depending on the number of fields. To use this in our xlat function, we simply add the following three lines of code:

```js
// If our supposed text is actually a function, we will apply
// this function to the parameters to obtain a new label. The
// text belonging to this label may be a function as well, so
// we keep following our functions until we have something that
// is not a function.
while($.isFunction(tables[currentLanguage][label])) {
  label = tables[currentLanguage][label](parameters);
}
```

### Conclusion

This completes our 'tour' of the code in the example project. The code you'll find in there is slightly more elaborate than this, as it has been made resilient against the case of missing texts for labels (in that case, the label itself will be shown). Also, the example project includes the server-side stuff making the form actually work as well; this part is straightforward Java / Spring MVC and hasn't been discussed here.

I've really come to like the idea of dealing with i18n client-side in AngularJS. The combination of the power of AngularJS and that of JavaScript as a dynamic language supporting function values, makes this surprisingly easy. Functionally, we get something great as well: language can change on the fly while keeping all other state of the web page. Given that it's so easy, and that this area always has many application-specific details, I would generally prefer to build it myself rather than use a pre-existing framework.

## angular-translate

See [angular translate - i18n for your Angular apps, made easy.](http://angular-translate.github.io/)

### Is there a way to get the current used language in a controller (without $translateProvider)?

See [angularjs - Get current language with angular-translate - Stack Overflow](http://stackoverflow.com/questions/20444578/get-current-language-with-angular-translate)

`$translate.use()` is a getter and setter.

See this demo found in links of docs: <http://jsfiddle.net/PascalPrecht/eUGWJ/7/>

## Ref

- [AngularJS: i18n and l10n](https://code.angularjs.org/1.0.2/docs/guide/i18n)
- [AngularJs学习笔记--I18n/L10n - Lcllao - 博客园](http://www.cnblogs.com/lcllao/archive/2012/09/20/2696195.html)
- [Internationalization with AngularJS « Trifork Blog / Trifork: Enterprise Java, Open Source, software solutions](http://blog.trifork.com/2014/04/10/internationalization-with-angularjs/)