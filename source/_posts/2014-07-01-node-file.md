---
layout: post
title: "Node File"
category: Node
tags: [node, file]
--- 

fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其他模块不同的是，fs 模块中所有的操作都提供了异步的和同步的两个版本， 例如读取文件内容的函数有异步的 fs.readFile() 和同步的fs.readFileSync()。

## Common APIs
### open

fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数，path 为文件的路径，flags 可以是以下值。

- r ：以读取模式打开文件。  
- r+ ：以读写模式打开文件。  
- w ：以写入模式打开文件，如果文件不存在则创建，如果存在，内容被清空。
- w+ ：以读写模式打开文件，如果文件不存在则创建。  
- a ：以追加模式打开文件，如果文件不存在则创建。  
- a+ ：以读取追加模式打开文件，如果文件不存在则创建。  

mode 参数用于创建文件时给文件指定权限，默认是 0666回调函数将会传递一个文件描述符 fd②。

    fs.open("test.txt", "w");

### read

    fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead,buffer)]) 

`fs.read` 是 POSIX read 函数的封装，相比fs.readFile 提供了更底层的接口。`fs.read`的功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。offset 是buffer 的写入偏移量。length 是要从文件中读取的字节数。position 是文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。回调函数传递bytesRead 和 buffer，分别表示读取的字节数和缓冲区对象。
实例:

```js
var fs = require('fs');
fs.open('content.txt', 'r', function(err, fd) {
    if (err) {
        console.error(err);
        return;
    }
    var buf = new Buffer(8);
    fs.read(fd, buf, 0, 8, null, function(err, bytesRead, buffer) {
        if (err) {
            console.error(err);
            return;
        }
        console.log('bytesRead: ' + bytesRead);
        console.log(buffer);
    });
});
```

    fs.readFile(filename,[encoding],[callback(err,data)])

`fs.readFile` 是最简单的读取文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding是可选的，表示文件的字符编码。callback 是回调函数，用于接收文件的内容。如果不指定 encoding，则 callback 就是第二个参数。回调函数提供两个参数 err 和 data，err 表示有没有错误发生，data 是文件内容。如果指定了 encoding，data 是一个解析后的字符串，否则 data 将会是以 Buffer 形式表示的二进制数据。
不指定编码方式就默认使用二进制的方式进行读取数据。

```js
var fs = require('fs');
fs.readFile('content.txt', function(err, data) {
    if (err) {
        console.error(err);
    } else {
        console.log(data);
    }
});
```

### mkdir

```js 
// fs.js
var fs = require('fs');
fs.mkdirSync('a', 0755);
fs.mkdirSync('a/b', 0755);
fs.mkdirSync('a/b/c', 0755);
```

那么它会在fs.js所在目录中创建一个a目录，a目录下再创建b目录，b目录下创建c目录。mkdirSync是一个同步方法，拥有三个参数，第一个是路径，第二个是[目录权限](http://hi.baidu.com/zhang_js521/blog/item/6976d10e2ca7d5fa36d122d6.html)，第三个是回调

但这样做有点不妥，如果指定目录已存在，就报错。如果要建立多级目录，一层层判定此目录是否存在，立即会陷入“回调地狱”的境地。虽然node.js对于IO操作的方法都提供了两个版本，一个是同步的，一个是异步的。想了想，搞出我自己的mkdirSync函数，实现比[mkdirp](https://github.com/substack/node-mkdirp/blob/master/index.js)的作者好很多。

```js    
var fs = require('fs');

function mkdirSync(url,mode,cb){
    var path = require("path"), arr = url.split("/");
    mode = mode || 0755;
    cb = cb || function(){};
    if(arr[0]==="."){//处理 ./aaa
        arr.shift();
    }
    if(arr[0] == ".."){//处理 ../ddd/d
        arr.splice(0,2,arr[0]+"/"+arr[1])
    }
    function inner(cur){
        if(!path.existsSync(cur)){//不存在就创建一个
            fs.mkdirSync(cur, mode)
        }
        if(arr.length){
            inner(cur + "/"+arr.shift());
        }else{
            cb();
        }
    }
    arr.length && inner(arr.shift());
}
//测试代码
mkdirSync("aaa/ddd/dd",0,function(e){
    if(e){
        console.log('出错了');
    }else{
        console.log("创建成功")
    }
});
```
    
有关目录的创建的讨论，详见[这里](http://stackoverflow.com/questions/5308514/prescriptive-nodejs)

### write

__write__

```js
var fs = require('fs');

fs.open("test.txt","w",0644,function(e,fd){
    if(e) throw e;
    fs.write(fd,"first fs!",0,'utf8',function(e){
        if(e) throw e;
        fs.closeSync(fd);
    })
});
```

__writeFile__
    
```js
var fs = require('fs');

fs.writeFile("test.txt","third fs!",function(e){
    //会先清空原先的内容
    if(e) throw e;
});
```

### delete

```js
var fs = require('fs');
fs.rmdir("aaa",function(e){
    if(e){
        console.log(e)
    }
})
/**
{ stack: [Getter/Setter],
  arguments: undefined,
  type: undefined,
  message: 'ENOTEMPTY, Directory not empty \'aaa\'',
  errno: 39,
  code: 'ENOTEMPTY',
  path: 'aaa' }
*/
```
    

报错，缘由是之前我们还为aaa创建了子目录，必须逐个删除，实在不人性化，于是又造了一个轮子。

```js
var fs = require('fs');
var getAllFolersAndFiles = (function(){
    function iterator(url, folders, files){
        var stat = fs.statSync(url);
        if(stat.isDirectory()){
            folders.unshift(url);//收集目录
            inner(url,folders, files);
        }else if(stat.isFile()){
            files.unshift(url);//收集文件
        }
    }
    function inner(path,folders,files){
        var arr = fs.readdirSync(path);
        for(var i = 0, el ; el = arr[i++];){
            iterator(path+"/"+el,folders,files);
        }
    }
    return function(dir){
        var folders = [], files = [];
        try{
            iterator(dir,folders,files);
        }catch(e){
        }finally{
            return {
                folders : folders,
                files   : files
            }
        }
    }
})()
```
    
如果我们只想取得指定目下的所有文件，还可以更精简些！

```js
function getAllFiles(root) {
  var result = [], files = fs.readdirSync(root)
  files.forEach(function(file) {
    var pathname = root+ "/" + file
      , stat = fs.lstatSync(pathname)
    if (stat === undefined) return

    // 不是文件夹就是文件
    if (!stat.isDirectory()) {
      result.push(pathname)
    // 递归自身
    } else {
      result = result.concat(getAllFiles(pathname))
    }
  });
  return result
}
```

### state

You want to get certain attributes of a given file such as whether or not it is a file or a directory, and you want to be able to set certain attributes such as the file’s name or the file’s permissions.

```js
var fs = require('fs');
fs.stat('data.txt', function(err, stats) {
    if (err) throw err;
    if (stats.isFile()) {
        console.log('It\'s a file!');
    }
    if (stats.isDirectory()) {
        console.log('It\'s a directory!');
    }
    for (var i in stats) {
        if ('function' !== typeof stats[i]) console.log(i + '\t= ' + stats[i]);
    }
});
``` 

### watch

就是使用watchFile及其同步版本。

```js
var fs = require("fs"),
sys = require("util");
fs.open("aaa.js","w",0644,function(e,fd){
    fs.writeSync(fd,"console.log(1111);");
    fs.closeSync(fd);
})

fs.watchFile("aaa.js", function(curr, prev) {
  sys.puts("\n\ttest_file.txt has been edited");
  sys.puts("\tThe current mtime is: " + curr.mtime);
  sys.puts("\tThe previous mtime was: " + prev.mtime + "\n");
});

fs.open("aaa.js","a",0644,function(e,fd){
    fs.writeSync(fd,"console.log(2222)");
    fs.closeSync(fd);
});
```

### rename and chmod

```js
fs.rename('data2.txt', 'data2_new.txt', function(err) {
    if (err) throw err;
    console.log('Renamed!');
});
fs.chmod('data3.txt', '0777', function(err) {
    if (err) throw err;
    console.log('File permissions changed!');
});
```

## Operation

### Traversing the file system

__Problem:__

You want to recursively read through a list of all of the files in a given directory location and display each file’s name or recursively traverse the file if it is a directory.

__Solution:__

```js
var fs = require('fs');
var traverseFileSystem = function(currentPath) {
    console.log(currentPath);
    var files = fs.readdirSync(currentPath);
    for (var i in files) {
        var currentFile = currentPath + '/' + files[i];
        var stats = fs.statSync(currentFile);
        if (stats.isFile()) {
            console.log(currentFile);
        } else if (stats.isDirectory()) {
            traverseFileSystem(currentFile);
        }
    }
};
traverseFileSystem('..');
```

## Library

- [aconbere/node-file-utils](https://github.com/aconbere/node-file-utils) Common higher level file and path operations.
- [mikeal/watch](https://github.com/mikeal/watch) Utilities for watching file trees in node.js.
- [sindresorhus/trash](https://github.com/sindresorhus/trash?) Cross-platform command-line app for moving files and directories to the trash - A safer alternative to `rm`.

## Reference

- [node.js 文件操作](http://www.cnblogs.com/rubylouvre/archive/2011/11/28/2264717.html)
- [Node.js学习(10) 文件系统fs](http://blog.csdn.net/gxhacx/article/details/12430969)