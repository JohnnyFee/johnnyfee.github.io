layout: post
title: "Qt 事件系统"
description: ""
category: Qt
tags: [qt, event]
---

> 原文： [Qt事件系统 - hai200501019的专栏 - 博客频道 - CSDN.NET](http://blog.csdn.net/hai200501019/article/details/9294631)

## The Event System

在Qt中，事件是继承了虚拟类[QEvent](http://qt-project.org/doc/qt-5.0/qtcore/qevent.html)的对象，它代表了程序所发生的事情或者程序需要知道的一个外部活动的结果。事件可以被任意  [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html)子类的实例接收和处理，是与 widgets 密切相关。本文描述了在一个典型的程序中事件是如何被传送和处理的。

<!--more-->

## How Events are Delivered 

当发生一个事件，Qt通过构造一个适当的 [QEvent](http://qt-project.org/doc/qt-5.0/qtcore/qevent.html)子类的实例来创建事件对象来代表它，并通过调用vevent()函数把它传送到特定的 [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html) 实例。

该函数本身不处理事件：根据传送的事件类型，它为特定的时间类型调用一个事件处理程序，并根据事件是被接受或忽略发送一个响应。

一些事件，如[QMouseEvent](http://qt-project.org/doc/qt-5.0/qtgui/qmouseevent.html) 和 [QKeyEvent](http://qt-project.org/doc/qt-5.0/qtgui/qkeyevent.html)来自windows系统。如[QTimerEvent](http://qt-project.org/doc/qt-5.0/qtcore/qtimerevent.html), 来自其他来源，一些来自程序本身。

## Event Types 

大多数的事件类型有特别的类，尤其是 [QResizeEvent](http://qt-project.org/doc/qt-5.0/qtgui/qresizeevent.html), [QPaintEvent](http://qt-project.org/doc/qt-5.0/qtgui/qpaintevent.html), [QMouseEvent](http://qt-project.org/doc/qt-5.0/qtgui/qmouseevent.html), [QKeyEvent](http://qt-project.org/doc/qt-5.0/qtgui/qkeyevent.html),and[QCloseEvent](http://qt-project.org/doc/qt-5.0/qtgui/qcloseevent.html). ，它们都继承了[QEvent](http://qt-project.org/doc/qt-5.0/qtcore/qevent.html) 和添加了特殊的函数。如 [QResizeEvent](http://qt-project.org/doc/qt-5.0/qtgui/qresizeevent.html) 添加了 [size()](http://qt-project.org/doc/qt-5.0/qtgui/qresizeevent.html#size)和 [oldSize()](http://qt-project.org/doc/qt-5.0/qtgui/qresizeevent.html#oldSize)函数使得widgets 可以获得其改变的规模。

一些类支持多于一种实际的事件类型。 [QMouseEvent](http://qt-project.org/doc/qt-5.0/qtgui/qmouseevent.html) 支持鼠标按下，双击，移动和其他相关操作。

每个事件都有一个定义在[QEvent::Type](http://qt-project.org/doc/qt-5.0/qtcore/qevent.html#Type-enum)的相关的类型，它可以用作运行时的类型信息以快速确定事件对象是构造自哪个子类。

由于程序需要多种复杂的方式的响应，Qt的事件传送机制也是灵活的。[QCoreApplication::notify](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#notify)()文档对称进行了确切的描述。

## Event Handlers 

通常事件被传送的方法是调用一个虚函数。例如， [QPaintEvent](http://qt-project.org/doc/qt-5.0/qtgui/qpaintevent.html) 通过调用 [QWidget::paintEvent](http://qt-project.org/doc/qt-5.0/qtwidgets/qwidget.html#paintEvent)().而被传送。该虚函数复杂作出适当的响应，通常是重绘widget。如果在你实现的虚函数里不能完成所需要的功能，可以调用基类的实现。

例如，下面的代码处理了自定义的checkbox 鼠标左键按下事件，把其他按键按下的事件传送给基类[QCheckBox](http://qt-project.org/doc/qt-5.0/qtwidgets/qcheckbox.html) ：

	void MyCheckBox::mousePressEvent(QMouseEvent*event)
	{
	    if (event->button() ==Qt::LeftButton) {
	        // handle left mouse button here
	    } else {
	        // pass on other buttons to base class
	        QCheckBox::mousePressEvent(event);
	    }
	}

如果你想取代基类的函数，你必须自己实现每件事。然而，如果你只想扩展基类的功能，你可以实现自己想实现的部分，在任何你不想处理情况，可以调用基类来获得默认的处理。

偶尔，可能没有特定事件的函数，或者特定事件的函数功能不充分。最常见的例子包含Tab 按下。通常， [QWidget](http://qt-project.org/doc/qt-5.0/qtwidgets/qwidget.html)拦截事件来移动键盘焦点，但是有的widget需要自己处理Tab 按下事件。

这些对象可以重新实现 [QObject::event](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#event)(),，一般的事件处理程序，可以在通常的事件处理之前或之后对它们的事件进行处理，或者完全取代整个函数的。一个既拦截Tab 也有自定义事件的widget 可能包含以下的[event()](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#event) 函数：

	bool MyWidget::event(QEvent*event)
	{
	    if (event->type() ==QEvent::KeyPress) {
	    QKeyEvent*ke =static_cast<QKeyEvent*>(event);
	    if (ke->key() ==Qt::Key_Tab) {
	        // special tab handling here
	        returntrue;
	    }
	    } elseif (event->type() == MyCustomEventType) {
	    MyCustomEvent *myEvent =static_cast<MyCustomEvent *>(event);
	    // custom event handling here
	    returntrue;
	    }
	 
	    returnQWidget::event(event);
	}

我们注意到对于没有处理的所有情况都调用了[QWidget::event](http://qt-project.org/doc/qt-5.0/qtwidgets/qwidget.html#event)() ，而且返回值表明了事件是否被处理。返回值true阻止了事件被传递给其他对象。

## Event Filters 

有时一个对象需要检查并可能拦截被传送给其他对象的事件。例如，对话框一般需要为一下widget过滤键盘按键事件。例如，修改返回键处理。

[QObject::installEventFilter](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#installEventFilter)()设置了eventfilter,，在目标对象的[QObject::eventFilter](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#eventFilter)() 函数里接收事件。事件过滤器在目标对象之前处理事件，根据需要允许对事件进行检查和丢弃。可以用 [QObject::removeEventFilter](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#removeEventFilter)()函数移除一个已经存在的事件过滤器。

当一个过滤器对象的[eventFilter()](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#eventFilter) 实现被调用，它可以接受或不接受事件，允许或拒绝更进一步的处理事件。如果所有的事件过滤器允许更进一步的处理事件，事件将被发送给目标对象本身。如果其中某个事件停止处理，目标对象和后面一些事件过滤器都接收不到该事件。

	bool FilterObject::eventFilter(QObject*object,QEvent*event)
	{
	    if (object == target && event->type() ==QEvent::KeyPress) {
	        QKeyEvent*keyEvent =static_cast<QKeyEvent*>(event);
	        if (keyEvent->key() ==Qt::Key_Tab) {
	            // Special tab handling
	            returntrue;
	        } else
	            returnfalse;
	    }
	    returnfalse;
	}

以上代码演示了另一种拦截Tab按键事件并发送到特定目标widget的方法。在这种情况下，事件过滤器处理了相关的事件并返回true阻止事件被进一步处理。其他的事件则被忽略，事件过滤器返回false以允许它们被发送到目标widget，通过任何已经安装的事件过滤器。

为整个程序过滤所有的事件也是可能的，通过为 [QApplication](http://qt-project.org/doc/qt-5.0/qtwidgets/qapplication.html) 或[QCoreApplication](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html) 安装事件过滤器。这样的全局事件过滤器将会在特定对象的过滤器之前被调用。这很强大，但是也会使得整个程序的事件发送变慢。

## Sending Events 

很多程序想创建和发送自己的事件。你可以用像Qt的事件循环一样的方法发送事件，通过构造合适的事件对象并用[QCoreApplication::sendEvent](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#sendEvent)()和[QCoreApplication::postEvent](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#postEvent)().发送事件。

[sendEvent()](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#sendEvent)立即处理事件。当它返回，事件过滤器和对象本身已经处理了事件。对于很多事件类型，有一个isAccepted()函数用来获取最近的处理过程事件是被接受还是不被接受。

[postEvent()](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#postEvent)把事件传递到队列等待分发。下一次主事件循环运行，它进行一些优化将分发所有的队列中的事件。例如，有一些resize 事件，将被压缩成一个事件。同样的应用与paint事件：[QWidget::update](http://qt-project.org/doc/qt-5.0/qtwidgets/qwidget.html#update)()调用 [postEvent()](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#postEvent)，它消除闪烁和增加速度以避免多次重绘。

[postEvent()](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#postEvent)在对象初始化过程中也被用到，因为发出的事件将在对象的初始化完成之后立即分发。当实现一个widget，意识到事件可能在其生命期的早期被分发这很重要，在其构造函数中，确保在早期初始化成员变量，在其有机会接收到事件之前。

要创建自定义的事件类型，需要定义一个事件号，必须大于 [QEvent::User](http://qt-project.org/doc/qt-5.0/qtcore/qevent.html#Type-enum).

