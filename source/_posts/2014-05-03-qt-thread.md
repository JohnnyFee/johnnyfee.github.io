---
layout: post
title: "Qt 线程"
description: ""
category: Qt
tags: [qt, thread]
--- 

## 概述

参考： [Qt线程QThread简析](http://blog.csdn.net/hai200501019/article/details/9535069)

QThread实例代表一个线程，我们可以重新实现QThread::run()，要新建一个线程，我们应该先继承QThread并重新实现run()函数。

需要注意的是：

1. 必须在创建QThread对象之前创建 QApplication (或QCoreApplication)对象。
2. QCoreApplication::exec() 必须只能从主线程调用，不能从QThread线程调用。

定义一个Thread：

	class MyThread : public  QThread
	{
		Q_OBJECT
	public:
		MyThread(QObject *parent = NULL);
		~MyThread();
	protected:
		void run();
	};

	void MyThread::run()
	{
		for( int count = 0; count < 20; count++ ){
	      	sleep( 1 );
		}

		qDebug( "finish!");
	}

我们可以在另外的函数这样调用：

	MyThread thread;
	thread.start();
	//必须要加的语句，等待thread结束。
	thread.wait();

当然我们先开的线程可能是要运行很久，会卡住主线程，使用 `QEventLoop` 就可以轻松解决此类问题：

	MyThread thread;
	thread.start();
	QEventLoop;
	connect(&thread,SIGNAL(finished ()),&eventLoop,SLOT(quit()));
	thread.wait(1);
	eventLoop.exec();

## 新建线程的方法

参考：[Qt新建线程的方法](http://blog.csdn.net/hai200501019/article/details/9899207)

### 继承QThread

继承 QThread，这应该是最常用的方法了。我们可以通过重写虚函数 `void QThread::run ()`实现我们自己想做的操作，实现新建线程的目的。前面已经介绍了 `QThread`，这里就不重复了。

这种方法，我们每一次要新建一个线程都需要继承QThread，实现一个新的类，有点不太方便。但是相对于QRunnable，这种方法的好处就是我们可以直接调用对象的`start()`函数启动线程，而Qrunnable必须借助 `QThreadPool`。

### 继承QRunnable

`QRunnable` 是所有可执行对象的基类。我们可以继承 `QRunnable`，并重写虚函数 `void QRunnable::run()` 。我们可以用 `QThreadPool` 让我们的一个 `QRunnable`对象在另外的线程中运行，如果 `autoDelete()` 返回 `true`(默认)，那么 `QThreadPool` 将会在 `run()`运行结束后自动删除 `Qrunnable` 对象。可以调用 `void QRunnable::setAutoDelete ( bool autoDelete )` 更改 `auto-deletion` 标记。需要注意的是，必须在调用 `QThreadPool::start()` 之前设置，在调用 `QThreadPool::start()` 之后设置的结果是未定义的。

下面是我写的简单的例子：

.h:

	class Runnable:public QRunnable
	{

	    //Q_OBJECT   注意了，QRunnable不是QObject的子类。
		public:
		       Runnable();
		       ~Runnable();
		       void run();
		protected:
		private:
	};

.cpp:

	// ...
	void Runnable::run()
	{
	   cout<<"Runnable::run()thread :"<<QThread::currentThreadId()<<endl;
	   cout<<"dosomething ...."<<endl;
	}

main:

	int main(int argc, char *argv[])
	{
	       QCoreApplication a(argc, argv);
	       
	       cout<<"mainthread :"<<QThread::currentThreadId()<<endl;
	       
	       Runnable runObj;
	       QThreadPool::globalInstance()->start(&runObj);

	       returna.exec();
	}

由结果可看出，run()确实是在不同于主线程的另外线程中运行的，而且在运行结束后就调用了析构函数，因为默认是可以自动被销毁的。
我们可以对同一个对象多次调用QThreadPool::start()，如果是可以自动被销毁的，Qrunnable对象会在最后一个线程离开了run函数之后才被销毁的。

	Runnable runObj;
	QThreadPool::globalInstance()->start(&runObj);
	QThreadPool::globalInstance()->start(&runObj);
	QThreadPool::globalInstance()->start(&runObj);   

三次调用QThreadPool::globalInstance()->start(&runObj);，但是在三次都执行完之后才运行析构函数。

这种新建线程的方法的最大的缺点就是：不能使用Qt的信号—槽机制，因为Qrunnable不是继承自QObject。所以我们要想知道线程是否运行结束或获取运行结果可能会比较麻烦。还有就是我们不能直接调用run()启动线程，必须借助于QthreadPool。

但是这种方法的好处就是，可以让 QThreadPool 来管理线程，QThreadPool 会自动的清理我们新建的Qrunnable对象。

### 使用 moveToThread

首先我们必须实现继承QObject的一个类，实现我们想要的功能。

	class Worker:publicQObject
	{
	       Q_OBJECT
	public:
		Worker();
		~Worker();
	protected slots:
		voidfun1();
		void fun2();
	};

	// ... 构造函数、析构函数实现
	void Worker::fun1()
	{
		cout<<"Worker::fun1()  thread : "<<QThread::currentThreadId()<<endl;
	}

接着创建一个对象，并调用:moveToThread ( QThread * targetThread )，让对象在新的线程中运行。

	int main(int argc, char *argv[])
	{
		QCoreApplication a(argc, argv);
		cout<<"mainthread :"<<QThread::currentThreadId()<<endl;

		QThread thread;
		Worker work;
		thread.start();              //注意记得启动线程

		work.moveToThread(&thread);

		//由于不能直接调用worker的函数，所以一般用信号触发调用
		QTimer::singleShot(0,&work,SLOT(fun1()));  
		QTimer::singleShot(0,&work,SLOT(fun1()));  
		returna.exec();
	}

这样就能让fun1()和fun2()都运行在thread线程中了。

需要注意的是：在work 的函数结束运行前，thread不能被析构。Thread的生命期不能小于work。否则的话程序就好崩掉了。

像下面的代码肯定是不行的。

	void Dialog::startWork()
	{
		QThread thread;
		Worker*work = new Worker;
		thread.start();
		work->moveToThread(&thread);
		QTimer::singleShot(0,work,SLOT(fun1()));
		QTimer::singleShot(0,work,SLOT(fun2()));
	}

所以thread 必须是new出来的。但是这样的话，就感觉有点麻烦，我们要同时管理thread和work，因为都是new 出来，我们需要负责清理。为了避免这样的麻烦，我想到的方法是，在work类中添加一个QThread成员。

	class Worker:publicQObject
	{
	       Q_OBJECT
	public:
		Worker();
		~Worker();

	protected slots:
		void fun1();
		void fun2();

	private:
		QThread m_thread;
	};
	 
	Worker::Worker():QObject()
	{
	   m_thread.start();
	   this->moveToThread(&m_thread);
	}

这样我们在用的时候只需要 new Work 就行了。

### 使用QtConcurrent::run

其实前面也有用到QtConcurrent::run启动新线程了。QtConcurrent命名空间提供了很多方法可以实现并发编程，这个以后再深入探讨了，这里只是大概讲一下启动线程。还是用上面的worker代码作为例子：

	void Worker::start()
	{
		QtConcurrent::run(this,&Worker::fun1);
		QtConcurrent::run(this,&Worker::fun2);
	}

QtConcurrent::run是个模板函数，有很多种形式，我们也可以让全局的函数允许在另外的线程中。

	void printMes(char*mes)
	{
		cout<<"pprintMes(char*mes)  thread : "<<QThread::currentThreadId()<<endl;
		cout<<mes<<endl;
	}

	int main(int argc, char *argv[])
	{
		QCoreApplication a(argc, argv);
		cout<<"mainthread :"<<QThread::currentThreadId()<<endl;
		char *mes= "hello world";
		QtConcurrent::run(printMes,mes);
		returna.exec();
	}	

## Threads and QObjects

[QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html) 继承 [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html)。它可以发送 started 和 finished 信号，也提供了一些 slot 函数。

[QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html) 可以用于多线程，可以发送信号调用存在于其他线程的 slot 函数，也可以 postEvent 给其他线程中的对象。之所以可以这样做，是因为每个线程都有自己的事件循环。

在进行下面的讲解之前，应该了解的重要的一点是： [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html)  对象所在的线程，和 [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html)  创建的线程，也就是 `run()` 函数执行的线程不是同一个线程。 [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html)  对象所在的线程，就是创建对象的线程。 我们通过一个例子说明更能清楚一点：

	MyThread::MyThread(QObject *parent /* = NULL */ ):QThread(parent)
	{
		qDebug()<< "MyThreadobject currentThreadId :" <<QThread::currentThreadId();
	}

	void MyThread::run()
	{
		qDebug()<< "run() currentThreadId : " <<QThread::currentThreadId();
	}

	int main( int argc, char *argv[])
	{
		QApplication a(argc, argv);

		MyThread thread;
		qDebug()<< "mainThread : " <<QThread::currentThreadId();
		thread.start();

		return a.exec();
	}

![](http://img.blog.csdn.net/20130804165846250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

输出结果： MyThread所在的线程就是主线程，run()函数是新开的线程。

## QObject Reentrancy 

[QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html). 是可重入的，它的大多数非 GUI 子类，例如：

- [QTimer](http://qt-project.org/doc/qt-5.0/qtcore/qtimer.html)
- [QTcpSocket](http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html)
- [QUdpSocket](http://qt-project.org/doc/qt-5.0/qtnetwork/qudpsocket.html)
- [QProcess](http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html)

都是可重入的，使得这些类可以同时用于多线程。需要注意的是，这些类设计为在一个单一的线程中创建和使用的，在一个线程创建对象，而从另外一个线程调用对象的函数并不能保证行得通。有三个限制需要注意：

1. [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html) 的子对象必须在创建其 `parent` 的线程中创建。这意味着，你不能把 [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html) 对象作为 `parent` 传递给在线程中创建的对象，因为[QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html) 对象本身在另外一个线程中创建。

2. 事件驱动对象只能用于单线程。尤其是在定时器机制和网络模块。例如，你不能在不是对象所处的线程中 start 一个计时器或者链接一个 socket 。简单的说就是，你不能在线程 A 创建了一个计时器 timer ，然后在线程 B 从启动 timer 。

我们可以验证一下：

	class MyThread : public QThread
	{
	Q_OBJECT

	public :
		MyThread(QObject *parent = NULL);
		~MyThread();
	public  slots :
		void timeOutSlot();
	protected :
		void run();
		QTimer *m_pTimer;
	};

	MyThread::MyThread(QObject*parent /* = NULL */ ):QThread(parent)
	{
		m_pTimer = new QTimer( this );
		qDebug()<< "MyThreadobject currentThreadId :" <<QThread::currentThreadId();
		connect(m_pTimer, SIGNAL (timeout()), this , SLOT (timeOutSlot()));
	}

	void MyThread::timeOutSlot()
	{
		qDebug()<< "timer timeout " ;
	}

	MyThread::~MyThread()
	{

	}

	void MyThread::run()
	{
		m_pTimer->start(500);
		qDebug()<< "run() currentThreadId : " <<QThread::currentThreadId();
		qDebug( "finish!" );
	}

	int main( int argc, char *argv[])
	{
		QApplication a(argc, argv);

		MyThread thread;
		qDebug()<< "mainThread : " <<QThread::currentThreadId();

		thread.start();
		return a.exec();
	}

![](http://img.blog.csdn.net/20130804165953515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

Timeout函数并没有被调用。我们还发现有多了一行输出：QObject::startTimer: timers cannot be startedfrom another thread

3. 你必须保证在线程中创建的对象要在线程销毁前 delete 。这很容易做到，只要是在 run() 函数栈里创建的对象就行。

尽管  [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html)  是可重入的，但是 GUI 类，特别是 [QWidget](http://qt-project.org/doc/qt-5.0/qtwidgets/qwidget.html)  和它的子类都是不可重入的。它们只能在主线程中用。就如前面提到的，  [QCoreApplication::exec](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#exec) () 必须从主线程进行调用。

## Per-Thread Event Loop 

每个线程都有自己的事件循环。起始的线程用 [QCoreApplication::exec](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#exec) () 开启事件循环。其他的线程用 [QThread::exec](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#exec) () 开始事件循环。与  [QCoreApplication](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html) 一样， [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html)也提供了  [exit](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#exit) (int) 函数 和 [quit()](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#quit)  槽函数。

线程里的事件循环，使得可以在线程里使用需要事件循环的非 GUI 类，例如 ( [QTimer](http://qt-project.org/doc/qt-5.0/qtcore/qtimer.html) , [QTcpSocket](http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html) , and [QProcess](http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html) )。也可以把任意的线程的信号连接到特定线程的槽。

[QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html) 实例存在于创建实例的线程中，发送给实例事件也是有线程的事件循环实现的。可以用  [QObject::thread](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#thread) () 获取对象存活于哪个线程。

	MyThread::MyThread(QObject*parent /* = NULL */ ):QThread(parent)
	{
		m_pTimer = new QTimer( this );
		qDebug()<< "MyThread object current ThreadId :" <<QThread::currentThread();
		
		QObject obj1;
		obj1.thread();
		qDebug()<< "obj1 live in the thread :" <<obj1.thread();

		connect(m_pTimer, SIGNAL(timeout()), this , SLOT(timeOutSlot()));
		//QThread::start();
	}

	void MyThread::run()
	{
		QObject obj2;
		obj2.thread();
		qDebug()<< "button2 live in the thread :" <<obj2.thread();
		//m_pTimer->start(500);
		qDebug()<< "run() currentThreadId : " <<QThread::currentThread();
		qDebug( "finish!" );
	}

![](http://img.blog.csdn.net/20130804170116140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这个再一次说明 了，对象所处的线程就是创建它的线程。

注意：对于那些在 [QApplication](http://qt-project.org/doc/qt-5.0/qtwidgets/qapplication.html)之前创建的对象，[QObject::thread](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#thread) () 返回 0 。这意味着，主线程只处理发送给那些对象的事件，那些没有 thread 的对象是不做任何的事件处理的。使用 [QObject::moveToThread](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#moveToThread) () 函数可以改变对象及其子对象的线程关联度，说白了就是把对象从当前的线程移到另外的线程里。但是如果一个对象已经有了 parent ，那是不能 move 了。

调用 delete 删除处于另外一个线程的 [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html) 对象是不安全的。除非你能保证对象当前不是在进行事件处理。应该用 [QObject::deleteLater](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#deleteLater) () 替代，并且将发出一个 [DeferredDelete](http://qt-project.org/doc/qt-5.0/qtcore/qevent.html#Type-enum)事件，这个事件会最终会被对象所在线程的事件循环所捕获。

如果没有事件循环，就不会有事件传递给对象。例如，如果你在一个线程中创建了一个[QTimer](http://qt-project.org/doc/qt-5.0/qtcore/qtimer.html)对象，但是不调用[exec()](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#exec) , ，那么 [QTimer](http://qt-project.org/doc/qt-5.0/qtcore/qtimer.html)永远不会发出[timeout()](http://qt-project.org/doc/qt-5.0/qtcore/qtimer.html#timeout)信号，调用[deleteLater()](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#deleteLater)  也不起作用。

	void MyThread::run()
	{
		m_pTimer = new QTimer();
		m_pTimer->start(500);
		connect(m_pTimer, SIGNAL (timeout()), this , SLOT (timeOutSlot()));
		
		qDebug()<< "run() currentThreadId : " <<QThread::currentThread();
		this ->exec();
		//qDebug("finish!" );
	}

	void MyThread::timeOutSlot()
	{
		qDebug()<< "timer timeout " ;
		//m_pTimer->stop();
	}

这时候是可以调用 `timeOutSlot()` 的。

	void MyThread::run()
	{
		m_pTimer = new QTimer();
		m_pTimer->start(500);
		connect(m_pTimer, SIGNAL (timeout()), this , SLOT (timeOutSlot()));
		qDebug()<< "run() currentThreadId : " <<QThread::currentThread();
		//this->exec();
		//qDebug("finish!" );
	}

如果注释 `this->exec();` ， `timeOutSlot()` 将不会被调用。

还有一点要注意的：[QTimer](http://qt-project.org/doc/qt-5.0/qtcore/qtimer.html)对象也不能在另外的线程 stop。如果把 timeOutSlot 里的 `m_pTimer->stop();` 取消注释。会看到一行输出： 

	QObject::killTimer: timers cannot be stopped fromanother thread

你可以用[QCoreApplication::postEvent](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#postEvent) () 函数在任意时间给任意线程中的任意对象发送事件。 事件自动被创建object的线程的事件循环分发。所有的线程都支持事件过滤器，唯一的限制就是，监视对象必须与被监视对象处于同一个线程。同样的，[QCoreApplication::sendEvent](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#sendEvent) () 只能用来给与调用 [QCoreApplication::sendEvent](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#sendEvent) () 函数处于同一个线程的对象发送事件。说白了就是， [QCoreApplication::sendEvent](http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#sendEvent) () 不能给处于另外线程的对象发送事件。

## Accessing QObjectSubclasses from Other Threads 

[QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html)  和它所有的子类都不是线程安全的。这包含了整个事件发送系统，需要记住的很重要的一点是：事件循环可能正在给一个对象发送一个事件，同时你可能从别的线程访问该对象。

如果你调用了一个不是出于当前线程 [QObject](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html)  子类对象的一个函数，而此时对象可能接收一个事件，你必须用一个 mutex 保护对象的内在的数据。否则，可能引起程序崩溃或者未定义的行为。

与其他的对象一样， [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html)对象存活于创建对象的线程中，而不是存在于[QThread::run](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run) () 线程。这点在前面讲到了。在自定义  [QThread](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html)子类中提供slot函数是不安全的，除非你用一个 mutex 保护了成员变量。然而，你可以在实现的  [QThread::run](http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run) () 里发出信号，因为信号发送是线程安全的。

## Signals and Slots AcrossThreads 

Qt 支持了几种信号 -- 槽的连接方式：

1. [Auto Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)  ( 默认 ) ：如果如果信号的发送方与接收方是处于同一个线程，这个连接就是  Direct Connection ，否则就跟  Queued Connection 一样。
2. [Direct Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)  ：当信号发出之后，槽会立即被调用。槽函数是在信号发送方的线程中运行的，不需要接收方的线程。
3. [Queued Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)：当控制权回到接收方线程时调用槽函数。槽函数是在接收方的线程中运行的。
4. [Blocking Queued Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)  ：调用方式跟  Queued Connection 一样，区别在于，当前线程会被阻塞直到槽函数返回。
5. [Unique Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)  ：这种方式跟  Auto Connection 一样，但是只有当不存在一个相同的连接时才会创建一个连接。如果已经存在相同的连接，则不会创建连接， `connect()` 返回 false 。

可以在 [connect()](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#connect)添加参数指定连接类型。需要注意的一点是：如果信号发送方和接收方处于不同的线程，而且接收方线程运行着一个事件循环，此时用 Direct Connection 是不安全，原因跟调用一个对象的函数，而这个对象处于另外的线程，那样的调用是不安全。

[QObject::connect](http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#connect) () 本身是线程安全的。

下面通过结果例子验证一下：

	class Receiver: public QObject
	{
		Q_OBJECT
		public :
			void sendmes()
			{
				emit emitSignal( "emit message from A To B" );
			}

			Receiver()
			{

			}

			protected  slots :
				void messageSlot(QString mes)
				{
					qDebug()<<mes;
				}
		signals :
			void emitSignal(QString mes);
	};

	int main( int argc, char *argv[])
	{

		QApplication a(argc, argv);
		Receiver objA,objB;
		QObject::connect(&objA, SIGNAL (emitSignal(QString)),&objB, SLOT (messageSlot(QString)));
		qDebug()<< "beforeemitsignal " ;
		objA.sendmes();
		qDebug()<< "afteremitsignal " ;
		return a.exec();
	}

objA,objB;出于同一个线程，所以connect的连接类型是[Direct Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)

由输出我们可以看出执行顺序，

![](http://img.blog.csdn.net/20130804170324765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

如果我们写了两句连接：

	QObject::connect(&objA, SIGNAL (emitSignal(QString)),&objB, SLOT (messageSlot(QString)));
	QObject::connect(&objA, SIGNAL (emitSignal(QString)),&objB, SLOT (messageSlot(QString)));

就会相应的有两句消息输出：

![](http://img.blog.csdn.net/20130804170411109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

如果指定了连接类型 Qt::UniqueConnection ，就会只有一句消息输出了。

	QObject::connect(&objA, SIGNAL (emitSignal(QString)),&objB, SLOT (messageSlot(QString)),Qt::UniqueConnection );
	QObject::connect(&objA, SIGNAL (emitSignal(QString)),&objB, SLOT (messageSlot(QString)),Qt::UniqueConnection);

![](http://img.blog.csdn.net/20130804170501765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

	int main( int argc, char *argv[])
	{
		QApplication a(argc, argv);
		QThread *thread = new QThread;
		thread->start();
		Receiver objA,objB;
		objB.moveToThread(thread);
		QObject::connect(&objA, SIGNAL(emitSignal(QString)), &objB, SLOT(messageSlot(QString)));
		qDebug()<< "beforeemitsignal " ;
		objA.sendmes();
		qDebug()<< "afteremitsignal " ;
		return a.exec();
	}

如果我们把 objB放到另外的线程，connect的连接类型应该是[Queued Connection](http://qt-project.org/doc/qt-5.0/qtcore/qt.html#ConnectionType-enum)  。

![](http://img.blog.csdn.net/20130804170600812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

	int main( int argc, char *argv[])
	{
		QApplication a(argc, argv);
		QThread *thread = new QThread;
		thread->start();
		Receiver objA,objB;
		objB.moveToThread(thread);
		QObject::connect(&objA, SIGNAL (emitSignal(QString)),&objB, SLOT (messageSlot(QString)) ,Qt::BlockingQueuedConnection);
		qDebug()<< "beforeemitsignal " ;
		objA.sendmes();
		qDebug()<< "afteremitsignal " ;
		return a.exec();
	}

显示的指定连接类型为 Qt::BlockingQueuedConnection，则输出为：

![](http://img.blog.csdn.net/20130804170644015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFpMjAwNTAxMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


## Web Service

- [QtSoap调用Web Service](http://blog.csdn.net/hai200501019/article/details/19755987)

## Tutorial

- [Qt线程基础](http://my.oschina.net/laopiao/blog/88158)

## 参考

- [QThread 与 QObject的关系](http://blog.csdn.net/hai200501019/article/details/9748173)
- [信号槽机制浅析](http://blog.csdn.net/harbinzju/article/details/10813635)