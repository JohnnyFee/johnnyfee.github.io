layout: post
title: "Sinon Tutorial"
category : JavaScript
tags : [javascript]
---

## What is Sinon

[cjohansen/Sinon.JS](https://github.com/cjohansen/Sinon.JS) Test spies, stubs and mocks for JavaScript.<http://sinonjs.org/>.

## Spy

### 创建Spy

```
var spy = sinon.spy()：创建一个默认的 spy。
var spy = sinon.spy(myFunc)：为一个指定的方法创建 spy。
var spy = sinon.spy(object, "method")：为一个对象的方法创建 spy。
```

### 监视方法被执行的次数

- spy.callCount：被监视方法执行的次数。
- spy.called：被监视方法至少执行过一次。
- spy.calledOnce：被监视方法只执行一次。
- spy.calledTwice：被监视方法只执行二次。
- spy.calledThrice：被监视方法只执行三次。

### 监视方法是否按照指定的参数执行

- spy.withArgs(arg1[, arg2, ...])：
- spy.calledWith(arg1, arg2, ...)：被监视方法至少一次按照指定的参数执行。注意：使用此 spy 的时候，Sinon 只检查被监视方法执行的时候参数是否有包含spy中指定的所有参数，如果被监视方法在执行的时候参数不仅包含spy中指定的所有参数，还有其他参数，测试也是会通过的。
- spy.alwaysCalledWith(arg1, arg2, ...)：被监视方法每次都是按照指定的参数执行。注意点同上。
- spy.calledWithExactly(arg1, arg2, ...)：被监视方法至少一次严格按照指定的参数执行，不包含其他参数。
- spy.alwaysCalledWithExactly(arg1, arg2, ...)：被监视方法每次都是严格按照指定的参数执行，不包含其他参数。
- spy.calledWithMatch(arg1, arg2, ...)：被监视方法至少一次按照匹配的参数执行。效果类似于：spy.calledWith(sinon.match(arg1), sinon.match(arg2), ...)。
- spy.alwaysCalledWithMatch(arg1, arg2, ...)：被监视方法每次都按照匹配的参数执行。效果类似于：spy.alwaysCalledWith(sinon.match(arg1), sinon.match(arg2), ...)。
- spy.neverCalledWith(arg1, arg2, ...)：被监视方法从未按照指定的参数执行。
- spy.neverCalledWithMatch(arg1, arg2, ...)：被监视方法从未按照匹配的参数执行。

### 获取被监视方法每次的调用

- spy.firstCall：获取被监视方法第一次的调用。
- spy.secondCall：获取被监视方法第二次的调用。
- spy.thirdCall：获取被监视方法第三次的调用。
- spy.lastCall：获取被监视方法最后一次的调用。
- var spyCall = spy.getCall(n)：获取被监视方法第 n 次的调用。
    
获取具体的某次调用以后，可针对该次调用进行以下检查测试：

- spyCall.calledOn(obj)：该次调用 this 指向 obj。
- spyCall.calledWith(arg1, arg2, ...)：该次调用按照指定的参数执行。注意点同spy.calledWith(arg1, arg2, ...)。
- spyCall.calledWithExactly(arg1, arg2, ...)：该次调用严格按照指定的参数执行。
- spyCall.calledWithMatch(arg1, arg2, ...)：该次调用按照匹配的参数执行。
- spyCall.notCalledWith(arg1, arg2, ...)：该次调用不按照指定的参数执行。
- spyCall.notCalledWithMatch(arg1, arg2, ...)：该次调用不按照匹配的参数执行。
- spyCall.threw()：该次调用有抛出异常。
- spyCall.threw(TypeError")：该次调用抛出指定类型的异常。
- spyCall.threw(obj)：该次调用抛出 obj 异常。
- spyCall.thisValue：该次调用的 this 对象。
- spyCall.args：该次调用的参数列表。
- spyCall.exception：该次调用抛出的异常。
- spyCall.returnValue：该次调用的返回值。

### 监视方法执行的顺序

- spy.calledBefore(anotherSpy)：在指定的另一个监视方法之前执行。
- spy.calledAfter(anotherSpy)：在指定的另一个监视方法之后执行。

### 监视方法是否按照指定的对象执行

- spy.calledOn(obj)：被监视方法至少一次在执行的时候，this 指向 obj。
- spy.alwaysCalledOn(obj)：被监视方法每次执行的时候，this 都指向 obj。

### 监视方法是否用 new 操作符执行

    spy.calledWithNew()

### 监视方法拋异常

- spy.threw()：被监视方法至少一次抛出异常。
- spy.threw("TypeError")：被监视方法至少一次抛出执行类型的异常。
- spy.threw(obj)：被监视方法至少一次抛出 obj 异常。
- spy.alwaysThrew()：被监视方法每次执行都抛出异常。
- spy.alwaysThrew("TypeError")：被监视方法每次都抛出指定类型的异常。
- spy.alwaysThrew(obj)：被监视方法每次都抛出 obj 异常。

### 监视方法的返回值

- spy.returned(obj)：被监视方法至少一次返回 obj。
- spy.alwaysReturned(obj)：被监视方法每次执行都返回 obj。

### 监视相关的值

- spy.thisValues：被监视方法每次调用的 this 对象列表。例如 spy.thisValues[0] 是被监视方法第一次调用的 this 对象。
- spy.args：被监视方法每次调用的参数列表。例如 spy.args[0] 是被监视方法第一次调用的参数列表。
- spy.exceptions：被监视方法每次调用抛出的异常对象列表。例如 spy.exceptions[0] 是被监视方法第一次调用抛出的异常。如果某次调用没有抛出异常，则该次调用的异常在 exceptions 中的值为 undefined，即 spy.exceptions[n] === undefined。
- spy.returnValues：被监视方法每次调用的返回值列表。例如 spy.returnValues[0] 是被监视方法第一次调用的返回值。如果某次调用没有返回值，则该次调用的返回值在 exceptions 中的值为 undefined，即 spy.returnValues[n] === undefined。

### 其他

- spy.reset()：重置某个 spy 的状态。
- spy.printf("format string", [arg1, arg2, ...])：返回格式化后的字符串。
- %n: spy 的名称 (默认为"spy")
- %c: spy 被调用的次数，既 ("once", "twice", 等等。)
- %C: 一个表示 spy 的调用的列表，每个调用都以一个新行和四个空格为前缀。
- %t: 用逗号分隔的 spy 被调用时的 this 对象列表。
- %i: 传递给 printf 的第 i 个要格式化的值。

%*: 逗号分隔的传递给 printf 的（未格式化的字符串）参数列表。

## Stub

Stub 提供了一些行为操作，当用 Stub 来包装一个方法时，原始方法将不会被执行，取而代之的是按照 Stub 指定的行为来执行。

### 创建 Stub：

- var stub = sinon.stub()：创建一个 Sinon 默认行为的 stub。
- var stub = sinon.stub(object, "method")：为一个对象的方法创建一个 Sinon 默认行为的 stub。
- var stub = sinon.stub(object, "method", func)：为一个对象的方法创建一个指定行为的 stub。
- var stub = sinon.stub(obj)：为一个对象创建一个 stub。此种方式不推荐使用，因为针对单个方法的测试目标会更明确些，更能定位到问题的所在。
    
### 获取某次调用

- stub.onFirstCall()：获取第一次调用。
- stub.onSecondCall()：获取第二次调用。
- stub.onThirdCall()：获取第三次调用。

### 返回指定的值

- stub.returns(obj)：返回 obj。
- stub.returnsArg(index)：返回指定 index 的参数。例如 stub.returnsArg(0) 将第一个参数作为返回值返回。
- stub.returnsThis()：返回 this 对象。

### 拋异常

- stub.throws()：抛出一个 Error 类型的异常。
- stub.throws("TypeError")：抛出一个执行类型的异常。
- stub.throws(obj)：抛出 obj 对象异常。

### 调用回调函数

- stub.callsArg(index)：将索引号为 index 的参数作为回调函数进行调用。
- stub.callsArgOn(index, context)：将索引号为 index 的参数作为回调函数进行调用，context 作为回调函数运行时的 this 对象。
- stub.callsArgWith(index, arg1, arg2, ...)：将索引号为 index 的参数作为回调函数，并使用指定的参数来执行回调。
- stub.callsArgOnWith(index, context, arg1, arg2, ...)：将索引号为 index 的参数作为回调函数，context 作为回调函数运行时的 this 对象，并使用指定的参数来执行回调。
- stub.yields([arg1, arg2, ...])：使用指定的参数来执行被监视方法的第一个回调函数。与 callsArg 的区别在于：当被监视方法的参数中有多个回调函数时，可以用 callArg 来执行指定参数索引的回调函数，而 yields 始终只是执行第一个回调函数。
- stub.yieldsOn(context, [arg1, arg2, ...])：使用指定的参数来执行被监视方法的第一个回调函数，context 作为回调函数运行时的 this 对象，并使用指定的参数来执行回调。
- stub.yieldsTo(property, [arg1, arg2, ...])：当被监视方法的参数是一个对象时，将该对象的指定属性作为函数，使用指定的参数进行调用。
- stub.yieldsToOn(property, context, [arg1, arg2, ...])：当被监视方法的参数是一个对象时，将该对象的指定属性作为函数，使用指定的参数进行调用，context 作为函数运行时的 this 对象。
- 异步的 stub 类似对应的同步 stub，区别在于回调函数的调用被推迟了（没有立即执行，而是通过一个短暂的 timeout 在另一个线程中执行）。

    - stub.callsArgAsync(index)
    - stub.callsArgOnAsync(index, context)
    - stub.callsArgWithAsync(index, arg1, arg2, ...)
    - stub.callsArgOnWithAsync(index, context, arg1, arg2, ...)
    - stub.yieldsAsync([arg1, arg2, ...])
    - stub.yieldsOnAsync(context, [arg1, arg2, ...])
    - stub.yieldsToAsync(property, [arg1, arg2, ...])
    - stub.yieldsToOnAsync(property, context, [arg1, arg2, ...])

- 以下四个有些不明白与 stub.yields 和 stub.callsArg 有什么区别：

    - spy.yield([arg1, arg2, ...])
    - spy.yieldTo(callback, [arg1, arg2, ...])
    - spy.callArg(argNum)
    - spy.callArgWith(argNum, [arg1, arg2, ...])

## Mock

### 相关API

- var mock = sinon.mock(obj)
- var expectation = mock.expects("method")
- mock.restore()
- mock.verify()

### Expectations

- var expectation = sinon.expectation.create([methodName])
- var expectation = sinon.mock()
- expectation.atLeast(number)
- expectation.atMost(number)
- expectation.never()
- expectation.once()
- expectation.twice()
- expectation.thrice()
- expectation.exactly(number)
- expectation.withArgs(arg1, arg2, ...)
- expectation.withExactArgs(arg1, arg2, ...)
- expectation.on(obj)：期望以 obj 为 this 对象来执行方法。
- expectation.verify()：检查此期望是否通过。

## Assertions

Assertions：使用 sinon 提供的断言的好处是：测试失败的时候能够提供更直接、更具体详细的错误信息。

## Matchers
