---
layout: post
title: Programming Android with Kotlin
category: Kotlin
---

# Kotlin Essentials

Kotlin was created by the JetBrains team from St. Petersburg, Russia. 

Like Java, Kotlin is a statically typed language. 

| Feature                                   | Java                                                         | Kotlin                                                       |
| :---------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| File contents                             | A single file contains a single top-level class.             | A single file can hold any number of classes, variables, or functions. |
| Variables                                 | Use `final` to make a variable immutable; variables are mutable by default. Defined at the class level. | Use `val` to make a variable read-only, or `var` for read/write values. Defined at the class level, or may exist independently outside of a class. |
| Type inferencing                          | Data types are required. `Date date = new Date();`           | Data types can be inferred, like `val date = Date()`, or explicitly defined, like `val date: Date = Date()`. |
| Boxing and unboxing types                 | In Java, data primitives like `int` are recommended for more expensive operations, since they are less expensive than boxed types like `Integer`. However, boxed types have lots of useful methods in Java’s wrapper classes. | Kotlin doesn’t have primitive types out of the box. Everything is an object. When compiled for the JVM, the generated bytecode performs automatic unboxing, when possible. |
| Access modifiers                          | Public and protected classes, functions, and variables can be extended and overridden. | As a functional language, Kotlin encourages immutability whenever possible. Classes and functions are final by default. |
| Access modifiers in multi-module projects | Default access is package-private.                           | There is no package-private, and default access is public. New `internal` access provides visibility in the same module. |
| Functions                                 | All functions are methods.                                   | Kotlin has function types. Function data types look like, for example, `(param: String) -> Boolean`. |
| Nullability                               | Any non-primitive object can be null.                        | Only explicitly nullable references, declared with the `?` suffix on the type, can be set to null: `val date: Date? = new Date()`. |
| Statics versus constants                  | The `static` keyword attaches a variable to a class definition, rather than an instance. | There is no `static` keyword. Use a private `const` or a `companion` object. |

## Kotlin Type System

### Primitive Types

The most obvious difference between Java’s and Kotlin’s type systems is that Kotlin has no notion of a *primitive type*.

### Null Safety

*Nullability* is part of Kotlin’s type system.

```kotlin
  val name: String? = null
```

`Any` is the root of the Kotlin type system, just like `Object` in Java. 

 all nonnullable types are subtypes of `Any` and all nullable types are subtypes of `Any?`.

Variables must be initialized. There is no default value for a variable. 

```kotlin
val name: String // error! Nonnullable types must be initialized!
```

### The Unit Type

In Kotlin, all functions, expressions and statement(like `if`) return a value and have a type. 

```kotlin
  val n = if (maybe) doThis() else doThat()
```

If the code for a function does not return a value explicitly, the function has the value `Unit`.

### Function Types

Kotlin’s type system supports *function types*. 

```kotlin
val func: (Double) -> Double = { x -> x.pow(2.0) }
```

The type of the function  type is `(Double) -> Double`.  If we supply that, though, we can omit the type specifier for the variable:

```kotlin
val func = { x: Double -> x.pow(2.0)}
```

Functions can receive other functions as parameters or return them as values. This kind of functions are higher-order functions.

```kotlin
fun getCurve(
    surface: (Double, Double) -> Int,
    x: Double
): (Double) -> Int {
    return { y -> surface(x, y) }
}
```

### Generics

A function (or a class) that uses a type variable is said to be *generic*. Like Java, Kotlin’s type system supports type variables. For instance:

```kotlin
fun <T> simplePair(x: T, y: T) = Pair(x, y)
```

## Variables and Functions

In Java the top-level syntactic entity is the class. All variables and methods are members of some class or other, and the class is the main element in a homonymous file.

Kotlin has no such limitations.

### Variables

There are two ways to declare a variable: with the keywords `val` and `var`.

The keyword `val` creates a variable that is read-only: it cannot be reassigned. 

```kotlin
val ronDeeLay = "the night time"
```

A `val` variable in Kotlin is more like a Java class’s field, which has a getter but no setter, as shown in the following code:

```kotlin
val surprising: Double
    get() = Math.random()
```

`var`, creates a familiar mutable variable: like a little box that holds the last thing that was put into it.

### Lambdas

Kotlin supports function literals: lambdas. 

```kotlin
{ x: Int, y: Int -> x * y; "down on the corner" }
```

By convention, the returned value is the value of the last expression in the body of the lambda. 

Kotlin has a very interesting feature that allows actually extending the language.

When the **last** argument to a function is another function (the function is higher-order), you can move the lambda expression passed as a parameter out of the parentheses that normally delimit the actual parameter list, as shown in the following code:

```kotlin
fun apiCall(param: Int, callback: () -> Unit)
```
  it can also be used like this:

```kotlin
apiCall(1) {
   println("I'm called back!")
}
```

### Extension Functions

In Kotlin, you have the ability to define a new method on a class, even though it isn’t a real member-function of that class. 

```kotlin
// declared inside FileUtils.kt
fun File.getWordAtIndex(index: Int): String {
    val context = this.readText()  // 'this' corresponds to the file
    return context.split(' ').getOrElse(index) { "" }
}
```

From inside the declaration of the extension function, `this` refers to the receiving type instance (here, a `File`). You only have access to `public` and `internal` attributes and methods, so `private` and `protected` fields are inaccessible.

We used `val` (instead of `fun`) to declare the extension property. 

```kotlin
// The Rectangle class has width and height properties
val Rectangle.area: Double
    get() = width * height
```

### Classes

One of Kotlin’s killer features, though, is the syntax for the constructor and the ability to declare properties within it. 

#### Class Initialization

```kotlin
class Point(val x: Int, var y: Int? = 3)

fun demo() {
    val pt1 = Point(4)
    assertEquals(3, pt1.y)
}
```

Note that the `var` and `val` keywords are very significant! The declaration `class Point(x: Int, y: Int)` is *very* different from the preceding declaration because it does not declare any member properties. Without the keywords, identifiers `x` and `y` are simply arguments to the constructor. 

You can also define both secondary constructors and initialization blocks:

```kotlin
class Segment(val start: Point, val end: Point) {
    val length: Double = sqrt(
            (end.x - start.x).toDouble().pow(2.0)
                    + (end.y - start.y).toDouble().pow(2.0))

    init {
        println("Point starting at $start with length $length")
    }

    constructor(x1: Int, y1: Int, x2: Int, y2: Int) :
            this(Point(x1, y1), Point(x2, y2)) {
        println("Secondary constructor")
    }
}
```

The output will be:

> ```kotlin
> >>> val s = Segment(1, 2, 3, 4)
> 
> Point starting at Point(x=1, y=2) with length 2.8284271247461903
> Secondary constructor
> ```
>

Kotlin guarantees this ordering: 

1. the primary constructor (if there is one) is run first. 
2. After it finishes, `init` blocks are run in declaration order (top to bottom). 
3. If the new instance is being created using a secondary constructor, the code block associated with that constructor is the last thing to run.

#### Properties

Kotlin variables, declared using `val` or `var` in a constructor, or at the top level of a class, actually define a *property*. 

Kotlin supports customizing the accessor and mutator for a property：

```kotlin
class Rectangle(val l: Int, val w: Int) {
    val area: Int
        get() = l * w
}
```

The identifier `field` has a special meaning only within the custom getter and setter, where it refers to the *backing field* that contains the property’s state.

```kotlin
class ExpensiveToHash(_summary: String) {

    var summary: String = _summary
        set(value) {
            field = value
            hashCode = computeHash()
        }

    //  other declarations here...
    var hashCode: Long = computeHash()

    private fun computeHash(): Long = ...
}
```

#### `lateinit` Properties

For Android developers, a UI widget used in an `Activity` or `Fragment`  is not initialized until the `onCreate` or `onCreateView` method. You can use nullable variable like this:

```kotlin
class MyFragment: Fragment() {
    private var button: Button? = null // will provide actual value later
}
```

You have to check for nullability when use it: `button?.setOnClickListener { .. }`

You can declare variables use `lateinit`,  Kotlin will let you declare it without assigning it a value. 

```kotlin
class MyFragment: Fragment() {
    private lateinit var button: Button // will initialize later
}
```

 By using the `lateinit` modifier, you disable Kotlin’s null safety for your variable. In our experience, using `lateinit` always resulted in runtime crashes. How did we fix that? By using a nullable type.

#### Lazy Properties

A Kotlin lazy value will not be initialized until a call is made at runtime. 

```kotlin
class Lightweight {
    val heavy by lazy { // Initialization block
        Heavyweight()
    }
}
```

The first time the property `heavy` is referenced, the initialization block will be run.

The code is thread-safe. Calls to `Lightweight::getHeavy()` will be synchronized so that only one thread at a time is in the initialization block.

#### Delegates

Lazy delegation is just one of many varieties of *property delegation*. A declaration uses the keyword `by` to define a delegate that is responsible for getting and setting the value of the property. 

The keyword `by` says that the next identifier in the declaration is an expression that will evaluate to the object that will be responsible for the value of `heavy`.

#### Companion Objects

In  Kotlin, there is no static variables, we use companion object instead.

A companion object is a *singleton object* always related to a Kotlin class. Most often the definition of a companion object is placed at the bottom of the related class.

A companion object is initialized when Kotlin loads the related class.

```kotlin
interface Formatter {
    val yearMonthDate: String
}

class TimeExtensions {
    //  other code

    companion object StdTimeExtension : Formatter {
        const val TAG = "TIME_EXTENSIONS"
        override val yearMonthDate = "yyyy-MM-d"
    }
}
```

#### Data Classes

In java, we often use *POJOs* (plain old Java objects) to represente simple structured data. They are a collection of data members (fields), most of which have getters and setters, and just a few other methods: `equals`, `hashCode`, and `toString`. 

In Kotlin, these kinds of classes are so common that Kotlin has made them part of the language. They are called *data classes*.

```kotlin
data class Point(var x: Int, var y: Int? = 3)
```

 A data class automatically includes overrides for the methods `equals`, `hashCode`, and `toString`. Each of these automatically generated methods depends on all of a class’s properties.

 A `data class` also provides the `copy` method. Here’s an example of its use:

```kotlin
data class Point(var x: Int, var y: Int? = 3)
val p = Point(1)          // x = 1, y = 3
val copy = p.copy(y = 2)  // x = 1, y = 2
```

#### Enum Classes

Remember when developers were being advised that enums were too expensive for Android? Fortunately, no one is even suggesting that anymore: use enum classes to your heart’s desire!

```kotlin
enum class GymActivity {
    BARRE, PILATES, YOGA, FLOOR, SPIN, WEIGHTS
}

enum class LENGTH(val value: Int) {
    TEN(10), TWENTY(20), THIRTY(30), SIXTY(60);
}
```

Enums work very well with Kotlin’s `when` expression. For example:

```kotlin
fun requiresEquipment(activity: GymActivity) = when (activity) {
    GymActivity.BARRE -> true
    GymActivity.PILATES -> true
    GymActivity.YOGA -> false
    GymActivity.FLOOR -> false
    GymActivity.SPIN -> true
    GymActivity.WEIGHTS -> true
}
```

Omitting the `else` clause like this has a really nice advantage: if we add a new value to the `GymActivity` enum, our code suddenly won’t compile. 

Omitting the `else` clause like this has a really nice advantage: if we add a new value to the `GymActivity` enum, our code suddenly won’t compile. 

#### Sealed Classes

Consider the following code. It defines a single type, `Result`, with exactly two subtypes. `Success` contains a value; `Failure` contains an `Exception`:

```kotlin
sealed class Result
data class Success(val data: List<Int>) : Result()
data class Failure(val error: Throwable?) : Result()
```

Notice that there is no way to do this with an `enum`. All of the values of an enum must be instances of the same type. 

Sealed classes do for types what enums do for instances. They allow you to announce to the compiler that there is a fixed, known set of subtypes

#### Visibility Modifiers

The default visibility is different in Kotlin—it’s *public*. There is no package-private in Kotlin.

*internal* is the fourth visibility modifier supported by Kotlin, which makes the reference visible anywhere within the containing *module*.

# Kotlin Collections Framework

## Collection Basics

### Java Interoperability

![image-20220426145646668](../resources/images/2022-04-20-klotlin-tutorial/image-20220426145822871.png)

For the most part, Kotlin extends, but does not alter the Java framework. It just adds the new, functional methods.

### Mutability

*Mutable* is the opposite of *immutable*. A mutable object can be changed and an immutable one cannot. The distinction is critical when trying to optimize code. Since they cannot change, immutable objects can be shared safely among multiple threads. A mutable object, however, must be made explicitly thread-safe if it is to be shared. Thread safety requires locking or copying, which may be expensive.

`kotlinx.collections.immutable` library is intended to be a set of truly immutable collections. To use them in your own Android/Kotlin project, add the following dependency to your `build.gradle` file:

```groovy
implementation \
'org.jetbrains.kotlinx:kotlinx-collections-immutable:$IC_VERSION'
```

While the *Kotlinx Immutable Collections Library* uses state-of-the-art algorithms and optimizes them so that they are very fast compared to other JVM implementations of immutable collections, these true immutable collections are still an order of magnitude slower than their mutable analogs.

```kotlin
val mutableList = mutableListOf(1, 2, 4, 5)
val immutableList = listOf(1, 2, 4, 5)
mutableList.add(4)    // compiles

// doesn't compile: ImmutableList has no `add` method.
immutableList.add(2)
```

### Overloaded Operators

The `+` and `-` operators preserve order when the underlying container is ordered. For instance:

```kotlin
(listOf(1, 2) + 3)
    .equals(listOf(1, 2, 3))    // true
(listOf(1, 2) + listOf(3, 4))
    .equals(listOf(1, 2, 3, 4)) // true
```

Adding a noncontainer object to a container creates a new container that has all of the elements from the left-hand operand (the container) with the new element (the right-hand operand) added. Adding two containers together creates a new container that has all of the elements from both.

### Creating Containers

Build a `Map` like this:

```kotlin
// Type is Map<Int, Int>
val map = mapOf(1 to 2, 4 to 5)

// Type is MutableMap<String, Int>
val map = mutableMapOf("Earth" to 3, "Venus" to 4)
```

Kotlin will choose the nearest type in the type hierarchy tree that is an ancestor of all of the elements of the container (this type is called the *upper bound type*). In this case it will choose `Number`, the nearest ancestor of both `Long` and `Double`. The variable `list` has the inferred type `List<Number>`:

```kotlin
val list = listOf(1L, 3.14)
```

In order to allow the list to contain `null`, we’d have to specify its type explicitly:

```kotlin
val list: MutableList<Any?> = mutablelistOf(1L, 3.14, "e")
```

## Functional Programming

*Object-oriented programming* (OOP) and *functional programming* (FP) are both paradigms for software design.

```kotlin
fun forAll() = collection.forEach(::doSomething)
```

That argument, `doSomething` in this case, is a function that takes a single parameter of the type contained in `collection`. 

## Transformation Functions

Kotlin brings functional capabilities to collections to provide elegant and safe ways of manipulating them.

### Boolean Functions

A convenient set of collection functions return a `Boolean` to indicate whether the collection has—or does not have—a given attribute. 

```kotlin
val nums = listOf(10, 20, 100, 5)

// return true if the predicate evaluates true for any element in the collection
val isAnyOdd = nums.any { it % 1 > 0 } // true

// returns true only if every element in the list matches the predicate
val isAll = nums.all { it % 1 > 0 } // false

// returns true only if the predicate evaluates to true for none of the elements in the collection
val isAny4 = nums.none { it == 4 }   // true
```

When a lambda takes only a single argument and the Kotlin compiler can figure that out using type inferencing (it usually can), you can omit the parameter declaration and use the implicit parameter named `it`. 

### Filter Functions

The basic `filter` function will return a new collection containing only the elements of the original collection that match the given predicate. 

```kotlin
val nums = listOf(10, 20, 100, 5)
val numbers = nums.filter { it > 20 }

// returns elements that do not match the predicate
val numbers = nums.filterNot { it > 20 }

val nums = listOf(null, 20, null, 5)
//  removes all of the nulls from a collection
val numbers = nums.filterNotNull() // { 20, 5 }
```

### Map

The *map* function applies its argument to each element in a collection and returns a collection of the resulting values.

```kotlin
val doubles: List<Double?> = listOf(1.0, 2.0, 3.0, null, 5.0)

// the variable squares will be the list [1.0, 4.0, 9.0, null, 25.0]
val squares: List<Double?> = doubles.map { it?.pow(2) }

// The value of the variable squares in this example is [1.0, 4.0, 9.0, 25.0].
val squares: List<Double?> = doubles.mapNotNull { it?.pow(2) }
```

Another variant of `map` is `mapIndexed`. `mapIndexed`’s functional argument takes the position in the collection as 1st parameter(0 for the first element, 1 for the second), an element of the collection as its second parameter.

There are mapping functions for most collection-like objects. There are even similar functions for `Map`s (though they are not subtypes of `Collection`): the functions `Map::mapKeys` and `Map::mapValues`.

### flatMap

See the definition and explaination in RxJava.

```kotlin
val list: List<List<Int>> = listOf(listOf(1, 2, 3, 4), listOf(5, 6))
val flatList: List<Int> = list.flatMap { it }
```

The variable `flatList` will have the value [1, 2, 3, 4, 5, 6].

### Grouping

```kotlin
val numbers = listOf(1, 20, 18, 37, 2)
val groupedNumbers = numbers.groupBy {
    when {
        it < 20 -> "less than 20"
        else -> "greater than or equal to 20"
    }
}
```

The variable `groupedNumbers` now contains a `Map<String, List<Int>>`. The map has two keys, “less than 20” and “greater than or equal to 20.” The value for the first key is the list [1, 18, 2]. The value for the second is [20, 37].

### Iterators Versus Sequences

A sequence differs from an iterator in a similar way. An iterator is a way of getting each element from an existing collection exactly once.

Sequences are backed by *generators*. A generator is a function that will provide the next item in the sequence. 

Because sequences are lazy—only generating the next element when it is needed—they can be very, very useful in optimizing operations, even on collections with fixed content.

```kotlin
val catPage = listOf(
    "http://ragdollies.com",
    "http://dogs.com",
    "http://moredogs.com")
    .map { fetchPage(it) }
    .first { hasCat(it) }
```

That algorithm will download all of the pages. If you do the same thing using a sequence:

```kotlin
val catPage = sequenceOf(
    "http://ragdollies.com",
    "http://dogs.com",
    "http://moredogs.com")
    .map { fetchPage(it) }
    .first { hasCat(it) }
```

only the first page will be downloaded. The sequence will provide the first URL, the `map` function will fetch it, and the `first` function will be satisfied. None of the other pages will be downloaded.

## Android Fundamentals



## Tip

## Find the types 

1. Click on `distinctCharacs` in the source code.

2. Hit Ctrl + Shift + P. You’ll see a drop-down window appear.

   ![image-20220426165949101](../resources/images/2022-04-20-klotlin-tutorial/image-20220426165949101.png)

3. Select the step you want and the inferred type will appear before your eyes!

   ![image-20220426170011078](../resources/images/2022-04-20-klotlin-tutorial/image-20220426170011078.png)

